/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/background.ts":
/*!***************************!*\
  !*** ./src/background.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawBackground\": () => (/* binding */ drawBackground),\n/* harmony export */   \"updateBackgroundOffset\": () => (/* binding */ updateBackgroundOffset)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _stripes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stripes */ \"./src/stripes.ts\");\n\n\nfunction drawBackground(ctx, { images, zone, nextZone, bgOffset, moveOffset, yOverride, }) {\n    const nextZoneIn = nextZone.start - moveOffset;\n    const roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.IH - (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    const stripes = (0,_stripes__WEBPACK_IMPORTED_MODULE_1__.generateStripes)({ roadHeight });\n    const roadDepth = (0,_stripes__WEBPACK_IMPORTED_MODULE_1__.stripesUnscaledHeight)(stripes);\n    const activeImage = imageByZoneKind(images, zone.kind);\n    let activeOpacity = 1;\n    if (nextZoneIn > 0 && nextZoneIn < roadDepth) {\n        const inOffset = roadDepth - nextZoneIn;\n        activeOpacity = 1 - inOffset / roadDepth;\n    }\n    drawBackgroundImage(ctx, {\n        image: activeImage,\n        opacity: activeOpacity,\n        bgOffset,\n        yOverride,\n    });\n    if (activeOpacity !== 1) {\n        const nextImage = imageByZoneKind(images, nextZone.kind);\n        const nextOpacity = 1 - activeOpacity;\n        const secondaryImage = drawBackgroundImage(ctx, {\n            image: nextImage,\n            opacity: nextOpacity,\n            bgOffset,\n            yOverride,\n        });\n    }\n}\nfunction drawBackgroundImage(ctx, { image, opacity, bgOffset, yOverride, }) {\n    const offsetX = bgOffset % image.width;\n    const offsetY = 0;\n    const horizonOffsetY = (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH) - _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n    // TODO: make it depend on the steepness of the hill\n    let parallaxMult = 1;\n    if (horizonOffsetY > 0) {\n        // looking up\n        parallaxMult = 0.4;\n    }\n    else if (horizonOffsetY < 0) {\n        // looking down\n        parallaxMult = 0.7;\n    }\n    const sourceOffsetY = 25;\n    const parallaxY = horizonOffsetY * parallaxMult;\n    const sourceX = offsetX;\n    const sourceY = sourceOffsetY - parallaxY;\n    const sourceWidth = _config__WEBPACK_IMPORTED_MODULE_0__.IW;\n    const sourceHeight = yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n    const destX = 0;\n    const destY = 0;\n    const destWidth = _config__WEBPACK_IMPORTED_MODULE_0__.IW;\n    const destHeight = yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n    ctx.globalAlpha = opacity;\n    ctx.drawImage(image, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);\n    if (sourceX < 0) {\n        const overflow = Math.abs(sourceX);\n        const newSourceX = image.width - overflow;\n        const newSourceWidth = overflow;\n        const newDestWidth = overflow;\n        ctx.drawImage(image, newSourceX, sourceY, newSourceWidth, sourceHeight, destX, destY, newDestWidth, destHeight);\n    }\n    if (sourceX > image.width - _config__WEBPACK_IMPORTED_MODULE_0__.IW) {\n        const overflow = sourceX - (image.width - _config__WEBPACK_IMPORTED_MODULE_0__.IW);\n        const newSourceX = 0;\n        const newSourceWidth = overflow;\n        const newDestX = _config__WEBPACK_IMPORTED_MODULE_0__.IW - overflow;\n        const newDestWidth = overflow;\n        ctx.drawImage(image, newSourceX, sourceY, newSourceWidth, sourceHeight, newDestX, destY, newDestWidth, destHeight);\n    }\n    ctx.globalAlpha = 1;\n}\nfunction imageByZoneKind(images, kind) {\n    switch (kind) {\n        case 'green':\n            return images.bgGreen;\n        case 'desert':\n            return images.bgDesert;\n        default:\n            throw new Error(`Unsupported bg zone kind: \"${kind}\"`);\n    }\n}\nfunction updateBackgroundOffset({ section, bgOffset, moveOffset, moveOffsetChange, moveSpeed, }) {\n    const entryGap = 200;\n    if (moveSpeed > 0) {\n        const inSectionOffset = moveOffset - section.start;\n        const bgOffsetChange = moveOffsetChange * _config__WEBPACK_IMPORTED_MODULE_0__.BG_SPEED_PER_MOVE_OFFSET;\n        if (section.kind === 'turn-left' && inSectionOffset > entryGap) {\n            return bgOffset - bgOffsetChange;\n        }\n        if (section.kind === 'turn-right' && inSectionOffset > entryGap) {\n            return bgOffset + bgOffsetChange;\n        }\n    }\n    return bgOffset;\n}\n\n\n//# sourceURL=webpack:///./src/background.ts?");

/***/ }),

/***/ "./src/car.ts":
/*!********************!*\
  !*** ./src/car.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MoveAudio\": () => (/* binding */ MoveAudio),\n/* harmony export */   \"defaultMoveSpeedState\": () => (/* binding */ defaultMoveSpeedState),\n/* harmony export */   \"defaultSteerState\": () => (/* binding */ defaultSteerState),\n/* harmony export */   \"drawCar\": () => (/* binding */ drawCar),\n/* harmony export */   \"getCarBox\": () => (/* binding */ getCarBox),\n/* harmony export */   \"updateMoveSpeedState\": () => (/* binding */ updateMoveSpeedState),\n/* harmony export */   \"updateSteerState\": () => (/* binding */ updateSteerState)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\nfunction drawCar(ctx, { images, steerOffset, }) {\n    const image = images.car;\n    const scale = 0.6 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const centerX = (_config__WEBPACK_IMPORTED_MODULE_0__.IW - image.width * scale) / 2;\n    const carSteerOffset = -1 * steerOffset * 0.02;\n    const x = centerX + carSteerOffset;\n    const y = _config__WEBPACK_IMPORTED_MODULE_0__.IH - 70 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    ctx.drawImage(image, x, y, image.width * scale, image.height * scale);\n}\nfunction getCarBox({ images, roadDepth, moveOffset, steerOffset, }) {\n    const image = images.car;\n    const scale = 0.6 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const centerX = (_config__WEBPACK_IMPORTED_MODULE_0__.IW - image.width * scale) / 2;\n    const carSteerOffset = -1 * steerOffset * 0.02;\n    const width = image.width * scale;\n    const height = image.height * scale;\n    const depth = 32;\n    const x = centerX + carSteerOffset;\n    const y = _config__WEBPACK_IMPORTED_MODULE_0__.IH - 70 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const z = 16;\n    return {\n        x,\n        y,\n        z,\n        width,\n        height,\n        depth,\n    };\n}\nconst defaultMoveSpeedState = {\n    moveGear: _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_GEAR_MIN,\n    moveSpeedChange: 0,\n    moveSpeed: 0,\n};\nfunction updateMoveSpeedState({ isThrottleActive, isReverseActive, moveGear: currentMoveGear, moveSpeedChange: currentMoveSpeedChange, moveSpeed: currentMoveSpeed, }) {\n    let gear = currentMoveGear;\n    let speedChange = currentMoveSpeedChange;\n    let speed = currentMoveSpeed;\n    const gearDesc = _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_GEARS[gear];\n    if (isThrottleActive) {\n        if (speedChange < 0) {\n            speedChange = 0;\n        }\n        speedChange = (speedChange + _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_ACCELERATION) / gearDesc.delim;\n        speed += speedChange;\n    }\n    else {\n        if (speed > 0) {\n            if (isReverseActive) {\n                speedChange =\n                    (speedChange - _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_DECELERATION_REVERSE) / gearDesc.delim;\n                speed = Math.max(0, speed + speedChange);\n            }\n            else {\n                speedChange = (speedChange - _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_DECELERATION_FREE) / gearDesc.delim;\n                speed = Math.max(0, speed + speedChange);\n            }\n        }\n    }\n    if (speed > gearDesc.endAt) {\n        gear = Math.min(gear + 1, _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_GEAR_MAX);\n    }\n    else if (speed < gearDesc.startAt) {\n        gear = Math.max(gear - 1, _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_GEAR_MIN);\n    }\n    speed = Math.min(speed, gearDesc.endAt);\n    return {\n        moveGear: gear,\n        moveSpeedChange: speedChange,\n        moveSpeed: speed,\n    };\n}\nconst defaultSteerState = {\n    steerOffset: 0,\n    steerSpeed: 0,\n};\nconst STEER_REDUCE_TILL_SPEED = 3;\nfunction updateSteerState({ steerOffset: currentSteerOffset, steerSpeed: currentSteerSpeed, section, isLeftTurnActive, isRightTurnActive, moveSpeed, moveOffset, }) {\n    let steerOffset = currentSteerOffset;\n    let steerSpeed = currentSteerSpeed;\n    const inSectionOffset = moveOffset - section.start;\n    if (moveSpeed >= 0) {\n        let t = 1;\n        if (moveSpeed < STEER_REDUCE_TILL_SPEED) {\n            t = moveSpeed / STEER_REDUCE_TILL_SPEED;\n        }\n        const steerSpeed = _config__WEBPACK_IMPORTED_MODULE_0__.STEER_SPEED * t;\n        if (isLeftTurnActive) {\n            steerOffset = Math.min(_config__WEBPACK_IMPORTED_MODULE_0__.STEER_LIMIT, steerOffset + steerSpeed);\n        }\n        else if (isRightTurnActive) {\n            steerOffset = Math.max(-_config__WEBPACK_IMPORTED_MODULE_0__.STEER_LIMIT, steerOffset - steerSpeed);\n        }\n    }\n    else {\n        steerSpeed = 0;\n    }\n    // The faster the car is going - turn will generate more counter-force\n    const turnCounterForce = _config__WEBPACK_IMPORTED_MODULE_0__.STEER_TURN_COUNTER_FORCE * (moveSpeed / _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_SPEED_MAX);\n    if (section.kind === 'turn-left') {\n        steerOffset -= turnCounterForce;\n    }\n    else if (section.kind === 'turn-right') {\n        steerOffset += turnCounterForce;\n    }\n    return {\n        steerSpeed,\n        steerOffset,\n    };\n}\nclass MoveAudio {\n    constructor(audioCtx) {\n        this.isMuted = true;\n        this.osc = audioCtx.createOscillator();\n        this.osc.type = 'sawtooth';\n        const biquadFilter = audioCtx.createBiquadFilter();\n        this.osc.connect(biquadFilter);\n        this.osc.start();\n        biquadFilter.connect(audioCtx.destination);\n    }\n    update({ isMuted, moveSpeed, moveSpeedChange, moveGear, }) {\n        const gear = _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_GEARS[moveGear];\n        const gearT = (moveSpeed - gear.startAt) / (gear.endAt - gear.startAt);\n        let soundStart = 30 + moveGear * 10;\n        let soundEnd = soundStart + moveGear * 15;\n        if (moveSpeedChange < 0) {\n            soundEnd = soundStart + moveGear * 8;\n        }\n        const soundValue = soundStart + (soundEnd - soundStart) * gearT;\n        this.osc.frequency.value = soundValue;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/car.ts?");

/***/ }),

/***/ "./src/collision.ts":
/*!**************************!*\
  !*** ./src/collision.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawCollisionBoxes\": () => (/* binding */ drawCollisionBoxes),\n/* harmony export */   \"findCollisions\": () => (/* binding */ findCollisions)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _stripes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stripes */ \"./src/stripes.ts\");\n\n\nfunction findCollisions(sourceBox, targetBoxes) {\n    const targetIndexes = [];\n    for (let i = 0; i < targetBoxes.length; i++) {\n        const targetBox = targetBoxes[i];\n        const intersects = sourceBox.x < targetBox.x + targetBox.width &&\n            sourceBox.x + sourceBox.width > targetBox.x &&\n            sourceBox.y < targetBox.y + targetBox.height &&\n            sourceBox.y + sourceBox.height > targetBox.y &&\n            sourceBox.z < targetBox.z + targetBox.depth &&\n            sourceBox.z + sourceBox.depth > targetBox.z;\n        if (intersects) {\n            targetIndexes.push(i);\n        }\n    }\n    return targetIndexes;\n}\nfunction drawCollisionBoxes(ctx, collidedBoxes, uncollidedBoxes, { stripes, roadDepth }) {\n    drawBoxes(ctx, uncollidedBoxes, {\n        boxColor: 'lightgreen',\n        depthColor: 'green',\n        stripes,\n        roadDepth,\n    });\n    drawBoxes(ctx, collidedBoxes, {\n        boxColor: 'orange',\n        depthColor: 'red',\n        stripes,\n        roadDepth,\n    });\n}\nfunction drawBoxes(ctx, boxes, { boxColor, depthColor, stripes, roadDepth, }) {\n    for (const box of boxes) {\n        ctx.strokeStyle = boxColor;\n        ctx.strokeRect(box.x, box.y, box.width, box.height);\n        ctx.strokeStyle = depthColor;\n        const zy = (0,_stripes__WEBPACK_IMPORTED_MODULE_1__.stripesToY)(stripes, { inOffset: roadDepth - box.z });\n        if (!zy) {\n            // console.log('zy not found: ', box.z);\n            continue;\n        }\n        const zy2 = (0,_stripes__WEBPACK_IMPORTED_MODULE_1__.stripesToY)(stripes, {\n            inOffset: roadDepth - box.z - box.depth,\n        });\n        if (!zy2) {\n            // console.log('zy2 not found', box.z, box.depth);\n            continue;\n        }\n        const bottomZ = _config__WEBPACK_IMPORTED_MODULE_0__.IH - zy;\n        const topZ = _config__WEBPACK_IMPORTED_MODULE_0__.IH - zy2;\n        const zHeight = bottomZ - topZ;\n        ctx.strokeRect(box.x, topZ, box.width, zHeight);\n    }\n}\n\n\n//# sourceURL=webpack:///./src/collision.ts?");

/***/ }),

/***/ "./src/config.ts":
/*!***********************!*\
  !*** ./src/config.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BG_SPEED_PER_MOVE_OFFSET\": () => (/* binding */ BG_SPEED_PER_MOVE_OFFSET),\n/* harmony export */   \"BH\": () => (/* binding */ BH),\n/* harmony export */   \"BW\": () => (/* binding */ BW),\n/* harmony export */   \"HH\": () => (/* binding */ HH),\n/* harmony export */   \"HW\": () => (/* binding */ HW),\n/* harmony export */   \"IH\": () => (/* binding */ IH),\n/* harmony export */   \"IW\": () => (/* binding */ IW),\n/* harmony export */   \"MOVE_ACCELERATION\": () => (/* binding */ MOVE_ACCELERATION),\n/* harmony export */   \"MOVE_DECELERATION_FREE\": () => (/* binding */ MOVE_DECELERATION_FREE),\n/* harmony export */   \"MOVE_DECELERATION_REVERSE\": () => (/* binding */ MOVE_DECELERATION_REVERSE),\n/* harmony export */   \"MOVE_GEARS\": () => (/* binding */ MOVE_GEARS),\n/* harmony export */   \"MOVE_GEAR_MAX\": () => (/* binding */ MOVE_GEAR_MAX),\n/* harmony export */   \"MOVE_GEAR_MIN\": () => (/* binding */ MOVE_GEAR_MIN),\n/* harmony export */   \"MOVE_SPEED\": () => (/* binding */ MOVE_SPEED),\n/* harmony export */   \"MOVE_SPEED_MAX\": () => (/* binding */ MOVE_SPEED_MAX),\n/* harmony export */   \"RENDER_SCALE\": () => (/* binding */ RENDER_SCALE),\n/* harmony export */   \"RS\": () => (/* binding */ RS),\n/* harmony export */   \"STEER_LIMIT\": () => (/* binding */ STEER_LIMIT),\n/* harmony export */   \"STEER_SPEED\": () => (/* binding */ STEER_SPEED),\n/* harmony export */   \"STEER_TURN_COUNTER_FORCE\": () => (/* binding */ STEER_TURN_COUNTER_FORCE)\n/* harmony export */ });\nconst RENDER_SCALE = 1;\nconst RS = RENDER_SCALE;\nconst BW = 380 * RENDER_SCALE;\nconst BH = 200 * RENDER_SCALE;\nconst IW = BW;\nconst IH = BH;\nconst HW = IW / 2; // half = 190\nconst HH = IH / 2; // half = 100\nconst STEER_LIMIT = Infinity;\nconst STEER_TURN_COUNTER_FORCE = 4 * RS;\nconst MOVE_SPEED = 4 * RS;\nconst STEER_SPEED = 8 * RS;\nconst BG_SPEED_PER_MOVE_OFFSET = 0.4;\nconst MOVE_ACCELERATION = 0.03;\nconst MOVE_DECELERATION_FREE = 0.05;\nconst MOVE_DECELERATION_REVERSE = 0.1;\nconst MOVE_SPEED_MAX = 8;\nconst MOVE_GEARS = {\n    1: { delim: 4, startAt: 0, endAt: 1.1 },\n    2: { delim: 5, startAt: 1, endAt: 2.6 },\n    3: { delim: 6, startAt: 2.5, endAt: 4.1 },\n    4: { delim: 7, startAt: 4, endAt: 6.1 },\n    5: { delim: 8, startAt: 6, endAt: MOVE_SPEED_MAX },\n};\n// export\nconst MOVE_GEAR_MIN = Number(Object.keys(MOVE_GEARS).shift());\nconst MOVE_GEAR_MAX = Number(Object.keys(MOVE_GEARS).pop());\n\n\n//# sourceURL=webpack:///./src/config.ts?");

/***/ }),

/***/ "./src/controls.ts":
/*!*************************!*\
  !*** ./src/controls.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InputControl\": () => (/* binding */ InputControl),\n/* harmony export */   \"listenKeyboard\": () => (/* binding */ listenKeyboard)\n/* harmony export */ });\nvar KeyboardButtonCode;\n(function (KeyboardButtonCode) {\n    KeyboardButtonCode[KeyboardButtonCode[\"Left\"] = 37] = \"Left\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Up\"] = 38] = \"Up\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Right\"] = 39] = \"Right\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Down\"] = 40] = \"Down\";\n    KeyboardButtonCode[KeyboardButtonCode[\"W\"] = 87] = \"W\";\n    KeyboardButtonCode[KeyboardButtonCode[\"A\"] = 65] = \"A\";\n    KeyboardButtonCode[KeyboardButtonCode[\"D\"] = 68] = \"D\";\n    KeyboardButtonCode[KeyboardButtonCode[\"S\"] = 83] = \"S\";\n})(KeyboardButtonCode || (KeyboardButtonCode = {}));\nvar InputControl;\n(function (InputControl) {\n    InputControl[InputControl[\"Up\"] = 0] = \"Up\";\n    InputControl[InputControl[\"Down\"] = 1] = \"Down\";\n    InputControl[InputControl[\"Left\"] = 2] = \"Left\";\n    InputControl[InputControl[\"Right\"] = 3] = \"Right\";\n})(InputControl || (InputControl = {}));\nconst binding = {\n    [InputControl.Up]: [KeyboardButtonCode.Up, KeyboardButtonCode.W],\n    [InputControl.Down]: [KeyboardButtonCode.Down, KeyboardButtonCode.S],\n    [InputControl.Left]: [KeyboardButtonCode.Left, KeyboardButtonCode.A],\n    [InputControl.Right]: [KeyboardButtonCode.Right, KeyboardButtonCode.D],\n};\nlet internalCodes = [];\nfunction listenKeyboard() {\n    document.addEventListener('keydown', (ev) => {\n        if (!internalCodes.includes(ev.keyCode)) {\n            internalCodes.push(ev.keyCode);\n        }\n    });\n    document.addEventListener('keyup', (ev) => {\n        internalCodes = internalCodes.filter((k) => k !== ev.keyCode);\n    });\n    return {\n        isDown(control) {\n            const codes = binding[control];\n            return codes.some((code) => internalCodes.includes(code));\n        },\n        getDownLastOf(controls) {\n            let latestIndex = -1;\n            let latestControl = undefined;\n            for (const control of controls) {\n                const codes = binding[control];\n                for (const code of codes) {\n                    const codeIndex = internalCodes.indexOf(code);\n                    if (codeIndex !== -1 && codeIndex > latestIndex) {\n                        latestIndex = codeIndex;\n                        latestControl = control;\n                    }\n                }\n            }\n            return latestControl;\n        },\n    };\n}\n\n\n//# sourceURL=webpack:///./src/controls.ts?");

/***/ }),

/***/ "./src/curve.ts":
/*!**********************!*\
  !*** ./src/curve.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DEFAULT_BOTTOM_DELTA\": () => (/* binding */ DEFAULT_BOTTOM_DELTA),\n/* harmony export */   \"DEFAULT_BOTTOM_LEFT_X\": () => (/* binding */ DEFAULT_BOTTOM_LEFT_X),\n/* harmony export */   \"DEFAULT_BOTTOM_RIGHT_X\": () => (/* binding */ DEFAULT_BOTTOM_RIGHT_X),\n/* harmony export */   \"curveXByY\": () => (/* binding */ curveXByY),\n/* harmony export */   \"drawCurve\": () => (/* binding */ drawCurve),\n/* harmony export */   \"leftRoadCurve\": () => (/* binding */ leftRoadCurve),\n/* harmony export */   \"lerpCurve\": () => (/* binding */ lerpCurve),\n/* harmony export */   \"pointOnCurve\": () => (/* binding */ pointOnCurve),\n/* harmony export */   \"rightRoadCurve\": () => (/* binding */ rightRoadCurve),\n/* harmony export */   \"steerCurve\": () => (/* binding */ steerCurve),\n/* harmony export */   \"translateCurve\": () => (/* binding */ translateCurve),\n/* harmony export */   \"translateCurveUniform\": () => (/* binding */ translateCurveUniform)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\n// Line equation:\n// left: 5x + 18y = 2700\n// right: 18 y - 5 x = 800\nconst DEFAULT_BOTTOM_DELTA = 180 * _config__WEBPACK_IMPORTED_MODULE_0__.RENDER_SCALE;\nconst DEFAULT_BOTTOM_LEFT_X = -DEFAULT_BOTTOM_DELTA;\nconst DEFAULT_BOTTOM_RIGHT_X = _config__WEBPACK_IMPORTED_MODULE_0__.IW + DEFAULT_BOTTOM_DELTA;\nfunction leftRoadCurve(controlX, controlY, topX, topY, bottomX = DEFAULT_BOTTOM_LEFT_X, bottomY = _config__WEBPACK_IMPORTED_MODULE_0__.IH) {\n    return { controlX, controlY, topX, topY, bottomX, bottomY };\n}\nfunction rightRoadCurve(controlX, controlY, topX, topY, bottomX = DEFAULT_BOTTOM_RIGHT_X, bottomY = _config__WEBPACK_IMPORTED_MODULE_0__.IH) {\n    return { controlX, controlY, topX, topY, bottomX, bottomY };\n}\nfunction translateCurveUniform(c, offset) {\n    return translateCurve(c, { control: offset, top: offset, bottom: offset });\n}\nfunction translateCurve(c, { control = 0, top = 0, bottom = 0, }) {\n    return Object.assign(Object.assign({}, c), { controlX: c.controlX + control, topX: c.topX + top, bottomX: c.bottomX + bottom });\n}\nfunction steerCurve(curve, { steerOffset }) {\n    const adjustedSteerOffset = steerOffset * 1;\n    return Object.assign(Object.assign({}, curve), { bottomX: curve.bottomX + adjustedSteerOffset });\n}\nfunction lerpCurve(c1, c2, t) {\n    console.assert(t >= 0 && t <= 1, 'd must be normalized: %d', t);\n    const controlX = c1.controlX + (c2.controlX - c1.controlX) * t;\n    const controlY = c1.controlY + (c2.controlY - c1.controlY) * t;\n    const topX = c1.topX + (c2.topX - c1.topX) * t;\n    const topY = c1.topY + (c2.topY - c1.topY) * t;\n    const bottomX = c1.bottomX + (c2.bottomX - c1.bottomX) * t;\n    const bottomY = c1.bottomY + (c2.bottomY - c1.bottomY) * t;\n    return {\n        controlX,\n        controlY,\n        topX,\n        topY,\n        bottomX,\n        bottomY,\n    };\n}\n// https://stackoverflow.com/a/5634528/1573638\nfunction pointOnCurve(curve, t) {\n    console.assert(t >= 0 && t <= 1, 't must be normalized: %d', t);\n    const x = (1 - t) * (1 - t) * curve.bottomX +\n        2 * (1 - t) * t * curve.controlX +\n        t * t * curve.topX;\n    const y = (1 - t) * (1 - t) * curve.bottomY +\n        2 * (1 - t) * t * curve.controlY +\n        t * t * curve.topY;\n    return { x, y };\n}\nfunction curveXByY(curve, y) {\n    // TODO: optimize: binary search? lut?\n    for (let t = 0; t <= 1; t += 0.01) {\n        const p = pointOnCurve(curve, t);\n        if (Math.abs(p.y - y) <= 1) {\n            return p.x;\n        }\n    }\n    return undefined;\n}\nfunction drawCurve(ctx, originalCurve, { moveOffset, steerOffset, color = 'orange', dashPattern, }) {\n    ctx.strokeStyle = color;\n    if (dashPattern) {\n        ctx.setLineDash(dashPattern);\n    }\n    ctx.lineDashOffset = moveOffset;\n    const curve = steerCurve(originalCurve, {\n        steerOffset,\n    });\n    ctx.beginPath();\n    ctx.moveTo(curve.bottomX, curve.bottomY);\n    ctx.quadraticCurveTo(curve.controlX, curve.controlY, curve.topX, curve.topY);\n    ctx.stroke();\n}\n\n\n//# sourceURL=webpack:///./src/curve.ts?");

/***/ }),

/***/ "./src/debug.ts":
/*!**********************!*\
  !*** ./src/debug.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawDebug\": () => (/* binding */ drawDebug),\n/* harmony export */   \"drawGrid\": () => (/* binding */ drawGrid),\n/* harmony export */   \"drawHorizon\": () => (/* binding */ drawHorizon),\n/* harmony export */   \"logClientCoordsOnClick\": () => (/* binding */ logClientCoordsOnClick)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\nfunction drawDebug(ctx, { section, bgOffset, steerOffset, moveOffset, moveSpeed, moveSpeedChange, moveGear, }) {\n    ctx.setLineDash([]);\n    ctx.strokeStyle = '#000';\n    ctx.font = '8px serif';\n    ctx.strokeText(`section kind: ${section.kind}`, 5, 10);\n    ctx.strokeText(`bg: ${bgOffset.toFixed(5)}`, 5, 20);\n    ctx.strokeText(`steer: ${steerOffset.toFixed(5)}`, 5, 30);\n    ctx.strokeText(`move offset: ${moveOffset.toFixed(5)}`, 5, 40);\n    ctx.strokeText(`move speed: ${moveSpeed.toFixed(5)}`, 5, 50);\n    ctx.strokeText(`move speed change: ${moveSpeedChange.toFixed(5)}`, 5, 60);\n    ctx.strokeText(`move gear: ${moveGear}`, 5, 70);\n}\nfunction drawHorizon(ctx, { yOverride } = {}) {\n    ctx.strokeStyle = 'green';\n    ctx.lineWidth = 1;\n    ctx.setLineDash([]);\n    ctx.beginPath();\n    ctx.moveTo(0, yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    ctx.lineTo(_config__WEBPACK_IMPORTED_MODULE_0__.IW, yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    ctx.stroke();\n}\nfunction drawGrid(ctx) {\n    ctx.setLineDash([]);\n    ctx.strokeStyle = '#cccccc77';\n    ctx.moveTo(_config__WEBPACK_IMPORTED_MODULE_0__.HW, 0);\n    ctx.lineTo(_config__WEBPACK_IMPORTED_MODULE_0__.HW, _config__WEBPACK_IMPORTED_MODULE_0__.IH);\n    ctx.stroke();\n}\nfunction logClientCoordsOnClick(canvas) {\n    canvas.addEventListener('click', (ev) => {\n        console.log(ev.clientX / 2, ev.clientY / 2);\n    });\n}\n\n\n//# sourceURL=webpack:///./src/debug.ts?");

/***/ }),

/***/ "./src/decor.ts":
/*!**********************!*\
  !*** ./src/decor.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawDecors\": () => (/* binding */ drawDecors),\n/* harmony export */   \"generateDecors\": () => (/* binding */ generateDecors)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve */ \"./src/curve.ts\");\n/* harmony import */ var _road__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./road */ \"./src/road.ts\");\n/* harmony import */ var _stripes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stripes */ \"./src/stripes.ts\");\n/* harmony import */ var _random__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./random */ \"./src/random.ts\");\n\n\n\n\n\n// TODO: they disappear when the bottom of the image hits the bottom of the screen\n//   -> better top of the image hits the bottom of the screen\n// TODO: variation in sizes\n// TODO: z-index with the car?\n// TODO: add preshow too?\nfunction drawDecors(ctx, { decors, images, path, section, moveOffset, steerOffset, yOverride, }) {\n    var _a;\n    let roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.IH - (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    // Not using yOverride because it will re-create the stripes when the road\n    // is transitioning from straight to uphill/downhill.\n    if (section.kind === 'uphill') {\n        roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n    }\n    else if (section.kind === 'downhill') {\n        roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.HH + section.steepness;\n    }\n    const stripes = (0,_stripes__WEBPACK_IMPORTED_MODULE_3__.generateStripes)({ roadHeight });\n    const travelDistance = (0,_stripes__WEBPACK_IMPORTED_MODULE_3__.stripesUnscaledHeight)(stripes);\n    for (const decor of decors) {\n        // Offset appearance so that decor positioned at 0 in the map is actually\n        // rendered visually at 0 right from the start.\n        const appearStart = decor.start - travelDistance;\n        const appearEnd = decor.start;\n        if (moveOffset >= appearStart && moveOffset <= appearEnd) {\n            const curbPath = (0,_road__WEBPACK_IMPORTED_MODULE_2__.getCurbPath)(path, { steerOffset });\n            const sourceCurve = decor.placement === 'right' ? curbPath.right : curbPath.left;\n            const placementSign = decor.placement === 'right' ? 1 : -1;\n            const decorCurve = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.translateCurve)(sourceCurve, {\n                top: 5 * placementSign,\n                control: 10 * placementSign,\n                bottom: 20 * placementSign,\n            });\n            const driftedCurve = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.translateCurveUniform)(decorCurve, ((_a = decor.driftOffset) !== null && _a !== void 0 ? _a : 0) * placementSign);\n            let inOffset = moveOffset - decor.start + travelDistance;\n            const stripesY = (0,_stripes__WEBPACK_IMPORTED_MODULE_3__.stripesToY)(stripes, { inOffset });\n            if (stripesY === undefined) {\n                continue;\n            }\n            const decorY = _config__WEBPACK_IMPORTED_MODULE_0__.IH - stripesY;\n            const decorX = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.curveXByY)((0,_curve__WEBPACK_IMPORTED_MODULE_1__.steerCurve)(driftedCurve, { steerOffset }), decorY);\n            if (decorX === undefined) {\n                continue;\n            }\n            const hhDecorT = stripesY / _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n            const image = imageByKind(images, decor.kind);\n            let imageScale = Math.max(0, 1 - (1 - 0.1 * _config__WEBPACK_IMPORTED_MODULE_0__.RENDER_SCALE) * hhDecorT);\n            if (roadHeight > _config__WEBPACK_IMPORTED_MODULE_0__.HH && decorY < _config__WEBPACK_IMPORTED_MODULE_0__.HH) {\n                imageScale = 0.05;\n            }\n            const imageWidth = image.width * imageScale;\n            const imageHeight = image.height * imageScale;\n            const imageX = decor.placement === 'right' ? decorX : decorX - imageWidth;\n            const imageY = decorY - imageHeight;\n            ctx.drawImage(image, imageX, imageY, imageWidth, imageHeight);\n        }\n    }\n}\nfunction imageByKind(images, kind) {\n    switch (kind) {\n        case 'bush':\n            return images.bush;\n        case 'tree':\n            return images.tree;\n        case 'rock':\n            return images.rock;\n        default:\n            throw new Error(`Unsupported decor kind: \"${kind}\"`);\n    }\n}\nfunction generateDecors({ startOffset, size, amount, }) {\n    const decors = [];\n    const areaSize = size / amount;\n    // Go reverse to have the farthest decors in the array first, which means the\n    // closest will be rendered last, which is better for zindex.\n    for (let i = amount - 1; i >= 0; i--) {\n        const areaStart = i * areaSize;\n        const inAreaOffset = (0,_random__WEBPACK_IMPORTED_MODULE_4__.randomNumber)(0, areaSize);\n        const start = startOffset + areaStart + inAreaOffset;\n        const kind = (0,_random__WEBPACK_IMPORTED_MODULE_4__.randomElement)(['bush', 'tree', 'rock']);\n        const driftOffset = (0,_random__WEBPACK_IMPORTED_MODULE_4__.randomNumber)(0, 50);\n        const placement = (0,_random__WEBPACK_IMPORTED_MODULE_4__.randomElement)(['left', 'right']);\n        decors.push({\n            start,\n            kind,\n            placement,\n            driftOffset,\n        });\n    }\n    return decors;\n}\n\n\n//# sourceURL=webpack:///./src/decor.ts?");

/***/ }),

/***/ "./src/fragment.ts":
/*!*************************!*\
  !*** ./src/fragment.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createDownhill\": () => (/* binding */ createDownhill),\n/* harmony export */   \"createTurn\": () => (/* binding */ createTurn),\n/* harmony export */   \"createUphill\": () => (/* binding */ createUphill),\n/* harmony export */   \"lerpFragments\": () => (/* binding */ lerpFragments),\n/* harmony export */   \"straightFragment\": () => (/* binding */ straightFragment)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve */ \"./src/curve.ts\");\n/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path */ \"./src/path.ts\");\n\n\n\nconst straightFragment = {\n    left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n    right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n    end: 0,\n};\nfunction createDownhill({ size, steepness, inOffset, steerOffset, }) {\n    const halfSize = size / 2;\n    const d = 1 - Math.abs((inOffset - halfSize) / halfSize);\n    const yOffset = -steepness * d;\n    const y = _config__WEBPACK_IMPORTED_MODULE_0__.HH + yOffset;\n    const minY = _config__WEBPACK_IMPORTED_MODULE_0__.HH - steepness;\n    let fragments = [\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 10, y),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 10, y),\n            end: 100 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 25, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 25, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 10, minY),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 25, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 25, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 10, minY),\n            end: 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 25, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 15, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 10, minY),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 25, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 15, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 10, minY),\n            end: size - 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        Object.assign(Object.assign({}, straightFragment), { end: size }),\n    ];\n    fragments = steerFragments(fragments, steerOffset);\n    return fragments;\n}\nfunction createUphill({ size, steepness, inOffset, steerOffset, }) {\n    const halfSize = size / 2;\n    const d = 1 - Math.abs((inOffset - halfSize) / halfSize);\n    const yOffset = steepness * d;\n    const y = _config__WEBPACK_IMPORTED_MODULE_0__.HH + yOffset;\n    const maxY = _config__WEBPACK_IMPORTED_MODULE_0__.HH + steepness;\n    const xCorrection = steerOffset * 0.15;\n    const bottomLeftCorrection = steerOffset * 0.1;\n    const cxCorrection = steerOffset * 0.2;\n    let fragments = [\n        // {\n        //   left: leftRoadCurve(\n        //     HW - 70,\n        //     y - 5,\n        //     HW - 60 + xCorrection,\n        //     y,\n        //     -180 - bottomLeftCorrection,\n        //   ),\n        //   right: rightRoadCurve(\n        //     HW + 70,\n        //     y - 5,\n        //     HW + 60 + xCorrection,\n        //     y,\n        //     560 - bottomLeftCorrection,\n        //   ),\n        //   end: 300,\n        // },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 120 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + cxCorrection, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 90 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + xCorrection, maxY, _curve__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_BOTTOM_LEFT_X - bottomLeftCorrection),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 120 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + cxCorrection, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 90 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + xCorrection, maxY, _curve__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_BOTTOM_RIGHT_X - bottomLeftCorrection),\n            end: 400 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 120 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + cxCorrection, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 90 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + xCorrection, maxY, _curve__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_BOTTOM_LEFT_X - bottomLeftCorrection),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 120 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + cxCorrection, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 90 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + xCorrection, maxY, _curve__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_BOTTOM_RIGHT_X - bottomLeftCorrection),\n            end: size - 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        Object.assign(Object.assign({}, straightFragment), { end: size }),\n    ];\n    fragments = steerFragments(fragments, steerOffset);\n    return fragments;\n}\nfunction createTurn({ size, direction, steerOffset, }) {\n    console.assert(size >= 600 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, 'turn too quick: %d', size);\n    let fragments = [\n        // {\n        //   left: [HW - 10, HH - 5, HW - 10, HH],\n        //   right: [HW + 190, HH + 50, HW + 10, HH],\n        //   end: 100,\n        // },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH - 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            end: 100 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 50 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH - 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 115 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 15 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 115 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            end: 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH - 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 80 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 15 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 115 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            end: size - 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH - 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 60 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 0 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 80 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            end: size - 100 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        Object.assign(Object.assign({}, straightFragment), { end: size }),\n    ];\n    if (direction === 'left') {\n        fragments = mirrorFragments(fragments);\n    }\n    fragments = steerFragments(fragments, steerOffset);\n    return fragments;\n}\nfunction mirrorFragments(fragments) {\n    return fragments.map((fragment) => {\n        const { left, right } = fragment;\n        return Object.assign(Object.assign({}, fragment), { left: Object.assign(Object.assign({}, left), { controlX: _config__WEBPACK_IMPORTED_MODULE_0__.HW + (_config__WEBPACK_IMPORTED_MODULE_0__.HW - right.controlX), controlY: right.controlY, topX: _config__WEBPACK_IMPORTED_MODULE_0__.HW + (_config__WEBPACK_IMPORTED_MODULE_0__.HW - right.topX), topY: right.topY }), right: Object.assign(Object.assign({}, right), { controlX: _config__WEBPACK_IMPORTED_MODULE_0__.HW + (_config__WEBPACK_IMPORTED_MODULE_0__.HW - left.controlX), controlY: left.controlY, topX: _config__WEBPACK_IMPORTED_MODULE_0__.HW + (_config__WEBPACK_IMPORTED_MODULE_0__.HW - left.topX), topY: left.topY }) });\n    });\n}\nfunction steerFragments(fragments, steerOffset) {\n    const topOffset = steerOffset * 0.01;\n    return fragments.map((fragment) => {\n        const { left, right } = fragment;\n        return Object.assign(Object.assign({}, fragment), { left: Object.assign(Object.assign({}, left), { controlX: left.controlX + topOffset, topX: left.topX + topOffset }), right: Object.assign(Object.assign({}, right), { controlX: right.controlX + topOffset, topX: right.topX + topOffset }) });\n    });\n}\nfunction lerpFragments({ fragments, inOffset, }) {\n    const activeIndex = fragments.findIndex((fragment) => {\n        return inOffset < fragment.end;\n    });\n    const prevIndex = activeIndex !== -1 ? activeIndex - 1 : -1;\n    const prevFragment = fragments[prevIndex] || straightFragment;\n    const activeFragment = fragments[activeIndex] || straightFragment;\n    let d = 0;\n    const fragmentSize = activeFragment.end - prevFragment.end;\n    const inFragmentOffset = inOffset - prevFragment.end;\n    if (fragmentSize !== 0) {\n        d = inFragmentOffset / fragmentSize;\n    }\n    const path = (0,_path__WEBPACK_IMPORTED_MODULE_2__.lerpPath)(prevFragment, activeFragment, d);\n    return path;\n}\n\n\n//# sourceURL=webpack:///./src/fragment.ts?");

/***/ }),

/***/ "./src/images.ts":
/*!***********************!*\
  !*** ./src/images.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"loadImages\": () => (/* binding */ loadImages)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction loadImages() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return {\n            car: yield loadImage('data/graphics/car.png'),\n            bgDebug: yield loadImage('data/graphics/bg-debug.png'),\n            bgGreen: yield loadImage('data/graphics/bg-green.png'),\n            bgDesert: yield loadImage('data/graphics/bg-desert.png'),\n            bush: yield loadImage('data/graphics/bush.png'),\n            tree: yield loadImage('data/graphics/tree.png'),\n            rock: yield loadImage('data/graphics/rock.png'),\n        };\n    });\n}\nfunction loadImage(imagePath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve) => {\n            const image = new Image();\n            image.src = imagePath;\n            image.addEventListener('load', () => {\n                resolve(image);\n            });\n        });\n    });\n}\n\n\n//# sourceURL=webpack:///./src/images.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _car__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./car */ \"./src/car.ts\");\n/* harmony import */ var _collision__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./collision */ \"./src/collision.ts\");\n/* harmony import */ var _controls__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./controls */ \"./src/controls.ts\");\n/* harmony import */ var _background__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./background */ \"./src/background.ts\");\n/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./debug */ \"./src/debug.ts\");\n/* harmony import */ var _decor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./decor */ \"./src/decor.ts\");\n/* harmony import */ var _images__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./images */ \"./src/images.ts\");\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./map */ \"./src/map.ts\");\n/* harmony import */ var _prop__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./prop */ \"./src/prop.ts\");\n/* harmony import */ var _road__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./road */ \"./src/road.ts\");\n/* harmony import */ var _section__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./section */ \"./src/section.ts\");\n/* harmony import */ var _stripes__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./stripes */ \"./src/stripes.ts\");\n/* harmony import */ var _zone__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./zone */ \"./src/zone.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst canvas = document.querySelector('canvas');\nconst ctx = canvas.getContext('2d');\ncanvas.width = _config__WEBPACK_IMPORTED_MODULE_0__.IW;\ncanvas.height = _config__WEBPACK_IMPORTED_MODULE_0__.IH;\nconst offCanvas = new OffscreenCanvas(_config__WEBPACK_IMPORTED_MODULE_0__.IW, _config__WEBPACK_IMPORTED_MODULE_0__.IH);\nconst offCtx = offCanvas.getContext('2d');\nconst keyboardListener = (0,_controls__WEBPACK_IMPORTED_MODULE_3__.listenKeyboard)();\nconst muteControl = document.querySelector('[data-control=\"mute\"]');\nconst audioCtx = new AudioContext();\nconst moveAudio = new _car__WEBPACK_IMPORTED_MODULE_1__.MoveAudio(audioCtx);\nconst resources = {\n    map: _map__WEBPACK_IMPORTED_MODULE_8__.coolMap,\n    images: undefined,\n};\nconst state = {\n    speedState: _car__WEBPACK_IMPORTED_MODULE_1__.defaultMoveSpeedState,\n    steerState: _car__WEBPACK_IMPORTED_MODULE_1__.defaultSteerState,\n    moveOffset: 0,\n    moveOffsetChange: 0,\n    bgOffset: 0,\n};\n(0,_debug__WEBPACK_IMPORTED_MODULE_5__.logClientCoordsOnClick)(canvas);\nfunction draw({ zone, nextZone, section, path, propBoxes, yOverride, }) {\n    ctx.clearRect(0, 0, _config__WEBPACK_IMPORTED_MODULE_0__.IW, _config__WEBPACK_IMPORTED_MODULE_0__.IH);\n    const { bgOffset, moveOffset, steerState: { steerOffset }, } = state;\n    // Draw the road stripes full width. Then cut it out and keep the area that is\n    // actually covered by the road (the ground area will become transparent\n    // again). Do it offscreen because we have to apply another mask and it's hard\n    // to do on a single canvas.\n    offCtx.globalCompositeOperation = 'source-over';\n    (0,_stripes__WEBPACK_IMPORTED_MODULE_12__.drawRoadStripes)(offCtx, { zone, nextZone, moveOffset, yOverride });\n    offCtx.globalCompositeOperation = 'destination-in';\n    (0,_road__WEBPACK_IMPORTED_MODULE_10__.drawRoadMask)(offCtx, path, { steerOffset });\n    ctx.drawImage(offCanvas, 0, 0);\n    // Ditto for the road. Except the curbs are drawn to the main canvas behind\n    // the already present road.\n    offCtx.globalCompositeOperation = 'source-over';\n    (0,_stripes__WEBPACK_IMPORTED_MODULE_12__.drawCurbStripes)(offCtx, { zone, nextZone, moveOffset, yOverride });\n    offCtx.globalCompositeOperation = 'destination-in';\n    (0,_road__WEBPACK_IMPORTED_MODULE_10__.drawCurbMask)(offCtx, path, { steerOffset });\n    ctx.globalCompositeOperation = 'destination-over';\n    ctx.drawImage(offCanvas, 0, 0);\n    // Then draw the ground stripes full widths but behind the road - it will keep\n    // the road+curbs that were drawn on the previous step and only fill in the\n    // ground stripes on the sides.\n    ctx.globalCompositeOperation = 'destination-over';\n    (0,_stripes__WEBPACK_IMPORTED_MODULE_12__.drawGroundStripes)(ctx, { zone, nextZone, moveOffset, yOverride });\n    // Then draw everything on top\n    ctx.globalCompositeOperation = 'source-over';\n    (0,_background__WEBPACK_IMPORTED_MODULE_4__.drawBackground)(ctx, {\n        images: resources.images,\n        zone,\n        nextZone,\n        moveOffset,\n        bgOffset,\n        yOverride,\n    });\n    (0,_decor__WEBPACK_IMPORTED_MODULE_6__.drawDecors)(ctx, {\n        decors: resources.map.decors,\n        images: resources.images,\n        path,\n        section,\n        moveOffset,\n        steerOffset,\n        yOverride,\n    });\n    (0,_prop__WEBPACK_IMPORTED_MODULE_9__.drawProps)(ctx, {\n        propBoxes,\n        images: resources.images,\n        moveOffset,\n        steerOffset,\n    });\n    (0,_car__WEBPACK_IMPORTED_MODULE_1__.drawCar)(ctx, { images: resources.images, steerOffset });\n    (0,_debug__WEBPACK_IMPORTED_MODULE_5__.drawDebug)(ctx, Object.assign(Object.assign({ section,\n        bgOffset,\n        moveOffset }, state.speedState), state.steerState));\n    // drawHorizon(ctx);\n}\nfunction main() {\n    return __awaiter(this, void 0, void 0, function* () {\n        resources.images = yield (0,_images__WEBPACK_IMPORTED_MODULE_7__.loadImages)();\n        loop();\n    });\n}\nfunction getInput() {\n    const isUp = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Up);\n    const isDown = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Down);\n    const lastPressedThrottleControl = keyboardListener.getDownLastOf([\n        _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Up,\n        _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Down,\n    ]);\n    const isThrottleActive = lastPressedThrottleControl === _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Up;\n    const isReverseActive = lastPressedThrottleControl === _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Down;\n    const lastPressedTurnControl = keyboardListener.getDownLastOf([\n        _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Left,\n        _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Right,\n    ]);\n    const isLeftTurnActive = lastPressedTurnControl === _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Left;\n    const isRightTurnActive = lastPressedTurnControl === _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Right;\n    return {\n        isThrottleActive,\n        isReverseActive,\n        isRightTurnActive,\n        isLeftTurnActive,\n    };\n}\nfunction updateState() {\n    // NOTE: don't destructure the state here because it is constantly updated\n    const { isThrottleActive, isReverseActive, isRightTurnActive, isLeftTurnActive, } = getInput();\n    const section = (0,_section__WEBPACK_IMPORTED_MODULE_11__.getActiveSection)({\n        sections: resources.map.sections,\n        moveOffset: state.moveOffset,\n    });\n    state.speedState = (0,_car__WEBPACK_IMPORTED_MODULE_1__.updateMoveSpeedState)(Object.assign({ isThrottleActive,\n        isReverseActive }, state.speedState));\n    state.moveOffsetChange = state.speedState.moveSpeed;\n    state.moveOffset += state.moveOffsetChange;\n    state.steerState = (0,_car__WEBPACK_IMPORTED_MODULE_1__.updateSteerState)(Object.assign({ section,\n        isLeftTurnActive,\n        isRightTurnActive, moveSpeed: state.speedState.moveSpeed, moveOffset: state.moveOffset }, state.steerState));\n    state.bgOffset = (0,_background__WEBPACK_IMPORTED_MODULE_4__.updateBackgroundOffset)({\n        section,\n        bgOffset: state.bgOffset,\n        moveOffset: state.moveOffset,\n        moveOffsetChange: state.moveOffsetChange,\n        moveSpeed: state.speedState.moveSpeed,\n    });\n}\nfunction updateCollisions({ path, section, nextSection, roadDepth, yOverride, }) {\n    const carBox = (0,_car__WEBPACK_IMPORTED_MODULE_1__.getCarBox)({\n        images: resources.images,\n        roadDepth,\n        moveOffset: state.moveOffset,\n        steerOffset: state.steerState.steerOffset,\n    });\n    const propBoxes = (0,_prop__WEBPACK_IMPORTED_MODULE_9__.getPropBoxes)({\n        props: resources.map.props,\n        images: resources.images,\n        path,\n        section,\n        nextSection,\n        moveOffset: state.moveOffset,\n        steerOffset: state.steerState.steerOffset,\n        yOverride,\n    });\n    const collidedBoxes = [];\n    const uncollidedBoxes = [];\n    const targetIndexes = (0,_collision__WEBPACK_IMPORTED_MODULE_2__.findCollisions)(carBox, propBoxes);\n    if (targetIndexes.length > 0) {\n        collidedBoxes.push(carBox);\n        collidedBoxes.push(...targetIndexes.map((index) => propBoxes[index]));\n    }\n    else {\n        uncollidedBoxes.push(carBox, ...propBoxes);\n    }\n    return {\n        collidedBoxes,\n        uncollidedBoxes,\n        propBoxes,\n    };\n}\nfunction loop() {\n    updateState();\n    const { map: { sections, zones }, } = resources;\n    const { moveOffset, steerState: { steerOffset }, } = state;\n    const section = (0,_section__WEBPACK_IMPORTED_MODULE_11__.getActiveSection)({ sections, moveOffset });\n    const nextSection = (0,_section__WEBPACK_IMPORTED_MODULE_11__.getNextSection)({ sections, moveOffset });\n    const zone = (0,_zone__WEBPACK_IMPORTED_MODULE_13__.getActiveZone)({ zones, moveOffset });\n    const nextZone = (0,_zone__WEBPACK_IMPORTED_MODULE_13__.getNextZone)({ zones, moveOffset });\n    const { path, yOverride } = (0,_section__WEBPACK_IMPORTED_MODULE_11__.createSectionFragments)({\n        section,\n        moveOffset,\n        steerOffset,\n    });\n    let roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.IH - (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    const stripes = (0,_stripes__WEBPACK_IMPORTED_MODULE_12__.generateStripes)({ roadHeight });\n    const roadDepth = (0,_stripes__WEBPACK_IMPORTED_MODULE_12__.stripesUnscaledHeight)(stripes);\n    const { collidedBoxes, uncollidedBoxes, propBoxes } = updateCollisions({\n        section,\n        nextSection,\n        path,\n        roadDepth,\n        yOverride,\n    });\n    draw({ zone, nextZone, section, path, yOverride, propBoxes });\n    // drawCollisionBoxes(ctx, collidedBoxes, uncollidedBoxes, {\n    //   stripes,\n    //   roadDepth,\n    // });\n    const isMuted = !muteControl.checked;\n    if (isMuted && audioCtx.state === 'running') {\n        audioCtx.suspend();\n    }\n    else if (!isMuted && audioCtx.state !== 'running') {\n        audioCtx.resume();\n    }\n    moveAudio.update(Object.assign({ isMuted }, state.speedState));\n    requestAnimationFrame(loop);\n}\nmain();\n\n\n//# sourceURL=webpack:///./src/main.ts?");

/***/ }),

/***/ "./src/map.ts":
/*!********************!*\
  !*** ./src/map.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"coolMap\": () => (/* binding */ coolMap),\n/* harmony export */   \"longLeftTurnMap\": () => (/* binding */ longLeftTurnMap),\n/* harmony export */   \"longUphillMap\": () => (/* binding */ longUphillMap),\n/* harmony export */   \"straightMap\": () => (/* binding */ straightMap)\n/* harmony export */ });\n/* harmony import */ var _decor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decor */ \"./src/decor.ts\");\n/* harmony import */ var _prop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./prop */ \"./src/prop.ts\");\n\n\nconst zones = [\n    {\n        start: 0,\n        kind: 'green',\n    },\n    {\n        start: 2000,\n        kind: 'desert',\n    },\n];\nconst straightMap = {\n    zones,\n    sections: [],\n    decors: [\n        ...(0,_decor__WEBPACK_IMPORTED_MODULE_0__.generateDecors)({\n            startOffset: 100,\n            amount: 1,\n            size: 5000,\n        }),\n    ],\n    props: [\n        {\n            kind: 'tree',\n            start: 500,\n            position: 0.2,\n            moveSpeed: 1,\n        },\n    ],\n};\nconst longUphillMap = {\n    zones,\n    sections: [\n        {\n            kind: 'uphill',\n            start: 100,\n            size: 15000,\n            steepness: 30,\n        },\n    ],\n    decors: [],\n    props: [\n        // {\n        //   kind: 'rock',\n        //   start: 500,\n        //   position: 0.1,\n        // },\n        ...(0,_prop__WEBPACK_IMPORTED_MODULE_1__.generateProps)({\n            startOffset: 300,\n            size: 15000,\n            amount: 30,\n        }),\n    ],\n};\nconst longLeftTurnMap = {\n    zones,\n    sections: [\n        {\n            kind: 'turn-right',\n            start: 0,\n            size: Infinity,\n        },\n    ],\n    decors: [],\n    props: [\n        ...(0,_prop__WEBPACK_IMPORTED_MODULE_1__.generateProps)({\n            startOffset: 300,\n            size: 15000,\n            amount: 30,\n        }),\n    ],\n};\nconst coolMap = {\n    zones,\n    sections: [\n        {\n            kind: 'uphill',\n            start: 100,\n            size: 700,\n            steepness: 30,\n        },\n        {\n            kind: 'turn-left',\n            start: 1000,\n            size: 600,\n        },\n        {\n            kind: 'turn-right',\n            start: 1500,\n            size: 1000,\n        },\n        {\n            kind: 'downhill',\n            start: 2600,\n            size: 1000,\n            steepness: 50,\n        },\n    ],\n    decors: [\n        ...(0,_decor__WEBPACK_IMPORTED_MODULE_0__.generateDecors)({\n            startOffset: 300,\n            size: 15000,\n            amount: 100,\n        }),\n    ],\n    props: [\n        ...(0,_prop__WEBPACK_IMPORTED_MODULE_1__.generateProps)({\n            startOffset: 300,\n            size: 15000,\n            amount: 30,\n        }),\n    ],\n};\n\n\n//# sourceURL=webpack:///./src/map.ts?");

/***/ }),

/***/ "./src/path.ts":
/*!*********************!*\
  !*** ./src/path.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getCenterCurve\": () => (/* binding */ getCenterCurve),\n/* harmony export */   \"lerpPath\": () => (/* binding */ lerpPath),\n/* harmony export */   \"steerPath\": () => (/* binding */ steerPath),\n/* harmony export */   \"translatePath\": () => (/* binding */ translatePath)\n/* harmony export */ });\n/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve */ \"./src/curve.ts\");\n\nfunction getCenterCurve(path) {\n    return {\n        topX: path.left.topX + (path.right.topX - path.left.topX) / 2,\n        topY: path.left.topY,\n        controlX: path.left.controlX + (path.right.controlX - path.left.controlX) / 2,\n        controlY: path.left.controlY,\n        bottomX: path.left.bottomX + (path.right.bottomX - path.left.bottomX) / 2,\n        bottomY: path.left.bottomY,\n    };\n}\nfunction steerPath(path, { steerOffset }) {\n    return Object.assign(Object.assign({}, path), { left: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.steerCurve)(path.left, { steerOffset }), right: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.steerCurve)(path.right, { steerOffset }) });\n}\nfunction translatePath(path, { top, bottom, }) {\n    return Object.assign(Object.assign({}, path), { left: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.translateCurve)(path.left, { top: -top, bottom: -bottom }), right: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.translateCurve)(path.right, { top, bottom }) });\n}\nfunction lerpPath(p1, p2, d) {\n    return {\n        left: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.lerpCurve)(p1.left, p2.left, d),\n        right: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.lerpCurve)(p1.right, p2.right, d),\n    };\n}\n\n\n//# sourceURL=webpack:///./src/path.ts?");

/***/ }),

/***/ "./src/prop.ts":
/*!*********************!*\
  !*** ./src/prop.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawProps\": () => (/* binding */ drawProps),\n/* harmony export */   \"generateProps\": () => (/* binding */ generateProps),\n/* harmony export */   \"getPropBoxes\": () => (/* binding */ getPropBoxes)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve */ \"./src/curve.ts\");\n/* harmony import */ var _stripes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stripes */ \"./src/stripes.ts\");\n/* harmony import */ var _random__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./random */ \"./src/random.ts\");\n/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./path */ \"./src/path.ts\");\n\n\n\n\n\nfunction getPropBoxes({ props, images, path, section, nextSection, moveOffset, steerOffset, yOverride, }) {\n    var _a;\n    let roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.IH - (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    const stripes = (0,_stripes__WEBPACK_IMPORTED_MODULE_2__.generateStripes)({ roadHeight });\n    const roadDepth = (0,_stripes__WEBPACK_IMPORTED_MODULE_2__.stripesUnscaledHeight)(stripes);\n    const propBoxes = [];\n    let preshowSize = 700;\n    if (section.kind === 'uphill' || (nextSection === null || nextSection === void 0 ? void 0 : nextSection.kind) === 'uphill') {\n        preshowSize = 400;\n    }\n    else if (section.kind === 'downhill' || (nextSection === null || nextSection === void 0 ? void 0 : nextSection.kind) === 'downhill') {\n        preshowSize = 0;\n    }\n    for (const prop of props) {\n        const propMoveOffset = (_a = prop.moveOffset) !== null && _a !== void 0 ? _a : 0;\n        const appearStart = prop.start - propMoveOffset - roadDepth;\n        const appearEnd = prop.start - propMoveOffset;\n        const preshowAppearStart = appearStart - preshowSize;\n        if (moveOffset >= preshowAppearStart && moveOffset <= appearEnd) {\n            const isPreshow = moveOffset < appearStart;\n            const centerCurve = (0,_path__WEBPACK_IMPORTED_MODULE_4__.getCenterCurve)(path);\n            let curve = centerCurve;\n            if (prop.position > 0.5) {\n                curve = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.lerpCurve)(centerCurve, path.right, (prop.position - 0.5) * 2);\n            }\n            else if (prop.position < 0.5) {\n                curve = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.lerpCurve)(path.left, centerCurve, prop.position * 2);\n            }\n            const steeredCurve = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.steerCurve)(curve, { steerOffset });\n            if (prop.moveSpeed != null) {\n                prop.moveOffset = propMoveOffset - prop.moveSpeed;\n            }\n            let inOffset = moveOffset - prop.start + roadDepth + propMoveOffset;\n            if (isPreshow) {\n                inOffset = 1;\n            }\n            const stripesY = (0,_stripes__WEBPACK_IMPORTED_MODULE_2__.stripesToY)(stripes, { inOffset });\n            if (stripesY === undefined) {\n                continue;\n            }\n            const propY = _config__WEBPACK_IMPORTED_MODULE_0__.IH - stripesY;\n            const propX = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.curveXByY)(steeredCurve, propY);\n            if (propX === undefined) {\n                continue;\n            }\n            let inHalfHeightT = stripesY / _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n            let imageScale = Math.max(0, 1 - (1 - 0.1 * _config__WEBPACK_IMPORTED_MODULE_0__.RS) * inHalfHeightT);\n            if (roadHeight > _config__WEBPACK_IMPORTED_MODULE_0__.HH && propY < _config__WEBPACK_IMPORTED_MODULE_0__.HH) {\n                const inOverHeightT = Math.max(0, 1 - (_config__WEBPACK_IMPORTED_MODULE_0__.HH - propY) / (roadHeight - _config__WEBPACK_IMPORTED_MODULE_0__.HH));\n                imageScale = 0.1 * inOverHeightT;\n            }\n            else if (isPreshow) {\n                imageScale *= 1 - (appearStart - moveOffset) / preshowSize;\n            }\n            const image = imageByKind(images, prop.kind);\n            const imageWidth = image.width * imageScale;\n            const imageHeight = image.height * imageScale;\n            const imageX = propX - imageWidth / 2;\n            const imageY = propY - imageHeight;\n            propBoxes.push({\n                prop,\n                curve: steeredCurve,\n                x: imageX,\n                y: imageY,\n                z: roadDepth - inOffset,\n                width: imageWidth,\n                height: imageHeight,\n                depth: 20,\n            });\n        }\n    }\n    return propBoxes;\n}\nfunction drawProps(ctx, { propBoxes, images, moveOffset, steerOffset, }) {\n    for (const propBox of propBoxes) {\n        const image = imageByKind(images, propBox.prop.kind);\n        // drawCurve(ctx, propBox.curve, { moveOffset, steerOffset: 0 });\n        ctx.drawImage(image, propBox.x, propBox.y, propBox.width, propBox.height);\n    }\n}\nfunction imageByKind(images, kind) {\n    switch (kind) {\n        case 'bush':\n            return images.bush;\n        case 'tree':\n            return images.tree;\n        case 'rock':\n            return images.rock;\n        default:\n            throw new Error(`Unsupported decor kind: \"${kind}\"`);\n    }\n}\nfunction generateProps({ startOffset, size, amount, }) {\n    const props = [];\n    const areaSize = size / amount;\n    // Go reverse to have the farthest props in the array first, which means the\n    // closest will be rendered last, which is better for zindex.\n    for (let i = amount - 1; i >= 0; i--) {\n        const areaStart = i * areaSize;\n        const inAreaOffset = (0,_random__WEBPACK_IMPORTED_MODULE_3__.randomNumber)(0, areaSize);\n        const start = startOffset + areaStart + inAreaOffset;\n        const kind = (0,_random__WEBPACK_IMPORTED_MODULE_3__.randomElement)(['bush', 'tree', 'rock']);\n        const position = (0,_random__WEBPACK_IMPORTED_MODULE_3__.randomNumber)(10, 90) / 100;\n        props.push({\n            start,\n            kind,\n            position,\n        });\n    }\n    return props;\n}\n\n\n//# sourceURL=webpack:///./src/prop.ts?");

/***/ }),

/***/ "./src/random.ts":
/*!***********************!*\
  !*** ./src/random.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"randomElement\": () => (/* binding */ randomElement),\n/* harmony export */   \"randomNumber\": () => (/* binding */ randomNumber)\n/* harmony export */ });\nfunction randomElement(items) {\n    const index = Math.floor(Math.random() * items.length);\n    return items[index];\n}\nfunction randomNumber(from = 0, to = 1) {\n    return Math.floor(Math.random() * (to - from + 1) + from);\n}\n\n\n//# sourceURL=webpack:///./src/random.ts?");

/***/ }),

/***/ "./src/road.ts":
/*!*********************!*\
  !*** ./src/road.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawCurbMask\": () => (/* binding */ drawCurbMask),\n/* harmony export */   \"drawRoadLines\": () => (/* binding */ drawRoadLines),\n/* harmony export */   \"drawRoadMask\": () => (/* binding */ drawRoadMask),\n/* harmony export */   \"getCurbPath\": () => (/* binding */ getCurbPath)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path */ \"./src/path.ts\");\n\n\nfunction drawRoadMask(ctx, path, { steerOffset, color = 'black' }) {\n    const { left, right } = (0,_path__WEBPACK_IMPORTED_MODULE_1__.steerPath)(path, {\n        steerOffset,\n    });\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(left.bottomX, left.bottomY);\n    ctx.quadraticCurveTo(left.controlX, left.controlY, left.topX, left.topY);\n    ctx.lineTo(right.topX, right.topY);\n    ctx.quadraticCurveTo(right.controlX, right.controlY, right.bottomX, right.bottomY);\n    ctx.lineTo(left.bottomX, left.bottomY);\n    ctx.fill();\n}\nfunction getCurbPath(path, { steerOffset }) {\n    return (0,_path__WEBPACK_IMPORTED_MODULE_1__.translatePath)(path, {\n        // TODO: maybe make it wider for uphills\n        top: 1 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        bottom: 50 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n    });\n}\nfunction drawCurbMask(ctx, path, { steerOffset, color = 'black' }) {\n    const steeredPath = (0,_path__WEBPACK_IMPORTED_MODULE_1__.steerPath)(path, {\n        steerOffset,\n    });\n    const { left, right } = getCurbPath(steeredPath, { steerOffset });\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(left.bottomX, left.bottomY);\n    ctx.quadraticCurveTo(left.controlX, left.controlY, left.topX, left.topY);\n    ctx.lineTo(right.topX, right.topY);\n    ctx.quadraticCurveTo(right.controlX, right.controlY, right.bottomX, right.bottomY);\n    ctx.fill();\n}\nfunction drawRoadLines(ctx, path, { moveOffset, steerOffset, color = 'red' }) {\n    ctx.strokeStyle = color;\n    ctx.setLineDash([10]);\n    ctx.lineDashOffset = moveOffset;\n    const { left, right } = (0,_path__WEBPACK_IMPORTED_MODULE_1__.steerPath)(path, {\n        steerOffset,\n    });\n    ctx.beginPath();\n    ctx.moveTo(left.bottomX, left.bottomY);\n    ctx.quadraticCurveTo(left.controlX, left.controlY, left.topX, left.topY);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.moveTo(right.bottomX, right.bottomY);\n    ctx.quadraticCurveTo(right.controlX, right.controlY, right.topX, right.topY);\n    ctx.stroke();\n}\n\n\n//# sourceURL=webpack:///./src/road.ts?");

/***/ }),

/***/ "./src/section.ts":
/*!************************!*\
  !*** ./src/section.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createSectionFragments\": () => (/* binding */ createSectionFragments),\n/* harmony export */   \"getActiveSection\": () => (/* binding */ getActiveSection),\n/* harmony export */   \"getNextSection\": () => (/* binding */ getNextSection)\n/* harmony export */ });\n/* harmony import */ var _fragment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fragment */ \"./src/fragment.ts\");\n\nfunction createSectionFragments({ section, moveOffset, steerOffset, }) {\n    const inSectionOffset = moveOffset - section.start;\n    if (section.kind === 'straight') {\n        return { path: _fragment__WEBPACK_IMPORTED_MODULE_0__.straightFragment };\n    }\n    if (section.kind === 'turn-right' || section.kind === 'turn-left') {\n        const fragments = (0,_fragment__WEBPACK_IMPORTED_MODULE_0__.createTurn)({\n            size: section.size,\n            direction: section.kind === 'turn-right' ? 'right' : 'left',\n            steerOffset,\n        });\n        const path = (0,_fragment__WEBPACK_IMPORTED_MODULE_0__.lerpFragments)({\n            fragments,\n            inOffset: inSectionOffset,\n        });\n        return { path };\n    }\n    if (section.kind === 'downhill') {\n        const fragments = (0,_fragment__WEBPACK_IMPORTED_MODULE_0__.createDownhill)({\n            size: section.size,\n            inOffset: inSectionOffset,\n            steepness: section.steepness,\n            steerOffset,\n        });\n        const path = (0,_fragment__WEBPACK_IMPORTED_MODULE_0__.lerpFragments)({\n            fragments,\n            inOffset: inSectionOffset,\n        });\n        const yOverride = path.left.topY;\n        return { path, yOverride };\n    }\n    if (section.kind === 'uphill') {\n        const fragments = (0,_fragment__WEBPACK_IMPORTED_MODULE_0__.createUphill)({\n            size: section.size,\n            inOffset: inSectionOffset,\n            steepness: section.steepness,\n            steerOffset,\n        });\n        const path = (0,_fragment__WEBPACK_IMPORTED_MODULE_0__.lerpFragments)({\n            fragments,\n            inOffset: inSectionOffset,\n        });\n        const yOverride = path.left.topY;\n        return { path, yOverride };\n    }\n    throw new Error(`Unknown section: \"${section.kind}\"`);\n}\nfunction getActiveSection({ sections, moveOffset, }) {\n    let activeSection = sections.find((s) => {\n        return moveOffset >= s.start && moveOffset <= s.start + s.size;\n    });\n    if (!activeSection || hasSectionEnded(activeSection, moveOffset)) {\n        activeSection = { start: moveOffset, kind: 'straight', size: 0 };\n    }\n    return activeSection;\n}\nfunction getNextSection({ sections, moveOffset, }) {\n    const activeSectionIndex = sections.findIndex((s) => {\n        return moveOffset >= s.start && moveOffset <= s.start + s.size;\n    });\n    if (activeSectionIndex !== -1) {\n        const nextSectionIndex = activeSectionIndex + 1;\n        return sections[nextSectionIndex];\n    }\n    return sections.find((s) => {\n        return s.start > moveOffset;\n    });\n}\nfunction hasSectionEnded(section, moveOffset) {\n    return section.start + section.size < moveOffset;\n}\n\n\n//# sourceURL=webpack:///./src/section.ts?");

/***/ }),

/***/ "./src/stripes.ts":
/*!************************!*\
  !*** ./src/stripes.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawCurbStripes\": () => (/* binding */ drawCurbStripes),\n/* harmony export */   \"drawGroundStripes\": () => (/* binding */ drawGroundStripes),\n/* harmony export */   \"drawRoadStripes\": () => (/* binding */ drawRoadStripes),\n/* harmony export */   \"generateStripes\": () => (/* binding */ generateStripes),\n/* harmony export */   \"stripesToY\": () => (/* binding */ stripesToY),\n/* harmony export */   \"stripesUnscaledHeight\": () => (/* binding */ stripesUnscaledHeight)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\nconst NEAR_TEXTURE_HEIGHT = 32 * _config__WEBPACK_IMPORTED_MODULE_0__.RENDER_SCALE;\nconst GROUND_COLORS = new Map();\nGROUND_COLORS.set('green', ['#889827', '#9aa545']);\nGROUND_COLORS.set('desert', ['#b7b467', '#c9c67c']);\nfunction drawGroundStripes(ctx, opts) {\n    const colors = GROUND_COLORS.get(opts.zone.kind);\n    drawStripes(ctx, Object.assign(Object.assign({}, opts), { colorMap: GROUND_COLORS }));\n}\nconst ROAD_COLORS = new Map();\nROAD_COLORS.set('green', ['#69696a', '#444446']);\nROAD_COLORS.set('desert', ['#9d7634', '#8b6b36']);\nfunction drawRoadStripes(ctx, opts) {\n    const colors = ROAD_COLORS.get(opts.zone.kind);\n    drawStripes(ctx, Object.assign(Object.assign({}, opts), { colorMap: ROAD_COLORS }));\n}\nconst CURB_COLORS = new Map();\nCURB_COLORS.set('green', ['#c5bfbf', '#dc3961']);\nCURB_COLORS.set('desert', ['#c57f4c', '#a15541']);\n// TODO: make them appear more often?? but keep stripes match with bigger ones\nfunction drawCurbStripes(ctx, opts) {\n    drawStripes(ctx, Object.assign(Object.assign({}, opts), { colorMap: CURB_COLORS }));\n}\nfunction drawStripes(ctx, { colorMap, zone, nextZone, moveOffset, yOverride, }) {\n    const colors = colorMap.get(zone.kind);\n    const nextColors = colorMap.get(nextZone.kind);\n    const roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.IH - (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    // const roadHeight = HH;\n    const nextZoneIn = nextZone.start - moveOffset;\n    const stripes = generateStripes({ roadHeight });\n    const texturedStripes = textureSplitStripes(stripes, { moveOffset });\n    const roadDepth = stripesUnscaledHeight(stripes);\n    if (nextZoneIn > 0 && nextZoneIn < roadDepth) {\n        const inOffset = roadDepth - nextZoneIn;\n        const divideY = stripesToY(stripes, { inOffset });\n        const closestStripe = texturedStripes.find((stripe, i) => {\n            var _a;\n            return (stripe.y2 >= divideY &&\n                stripe.textureIndex === 0 &&\n                ((_a = texturedStripes[i + 1]) === null || _a === void 0 ? void 0 : _a.textureIndex) !== 0);\n        });\n        for (let i = 0; i < texturedStripes.length; i++) {\n            const stripe = texturedStripes[i];\n            const nextStripe = texturedStripes[i + 1];\n            let usedColors = colors;\n            if (stripe.stripeIndex >= (closestStripe === null || closestStripe === void 0 ? void 0 : closestStripe.stripeIndex)) {\n                usedColors = nextColors;\n            }\n            if (stripe.stripeIndex + 1 === (closestStripe === null || closestStripe === void 0 ? void 0 : closestStripe.stripeIndex) &&\n                stripe.textureIndex === (nextStripe === null || nextStripe === void 0 ? void 0 : nextStripe.textureIndex) &&\n                stripe.textureIndex === 0) {\n                usedColors = nextColors;\n            }\n            ctx.fillStyle = usedColors[stripe.textureIndex];\n            ctx.fillRect(0, _config__WEBPACK_IMPORTED_MODULE_0__.IH - stripe.y2, _config__WEBPACK_IMPORTED_MODULE_0__.IW, stripe.height);\n        }\n    }\n    else {\n        for (const stripe of texturedStripes) {\n            ctx.fillStyle = colors[stripe.textureIndex];\n            ctx.fillRect(0, _config__WEBPACK_IMPORTED_MODULE_0__.IH - stripe.y2, _config__WEBPACK_IMPORTED_MODULE_0__.IW, stripe.height);\n        }\n    }\n}\nfunction stripesUnscaledHeight(stripes) {\n    const nearTextureHeight = stripes[0].height;\n    return stripes.length * nearTextureHeight;\n}\nfunction stripesToY(stripes, { inOffset }) {\n    // First stripe travels 1 to 1 with the move offset -> 32 to 32.\n    // Let's say second stripe is smaller in size by 2 (32 / 2 = 16), which means\n    // that if inOffset travels +32, then this stripe will travel +16,\n    // or if inOffset travels +16, then this stripe will travel +8.\n    // Find a stripe we are in first using inOffset. Then figure out how much\n    // into a stripe we have travelled and return it as an y position.\n    const nearTextureHeight = stripes[0].height;\n    const roadHeight = stripes[stripes.length - 1].y2;\n    let unscaledOffset = 0;\n    let scaledY = 0;\n    const unscaledHeight = stripes.length * nearTextureHeight;\n    const unscaledIn = unscaledHeight - inOffset;\n    const unscaledT = unscaledIn / nearTextureHeight;\n    const stripeIndex = Math.floor(unscaledT);\n    const inStripeT = unscaledT % 1;\n    if (stripeIndex < 0) {\n        const firstStripe = stripes[0];\n        return undefined;\n        // return firstStripe.y2;\n    }\n    if (stripeIndex > stripes.length - 1) {\n        const lastStripe = stripes[stripes.length - 1];\n        return undefined;\n        // return lastStripe.y2;\n    }\n    const stripe = stripes[stripeIndex];\n    if (stripe == null) {\n        return undefined;\n    }\n    const y = stripe.y + stripe.height * inStripeT;\n    return y;\n}\nfunction generateStripes({ roadHeight, nearTextureHeight = NEAR_TEXTURE_HEIGHT, }) {\n    const stripes = [];\n    // Will be used in a function to calculate how much the next road stripe will\n    // be downscaled compared to the previous one because next stripe is further\n    // into the road.\n    let downscaleIndex = 1;\n    let stripeIndex = 0;\n    let currentY = 0;\n    let roadLeftToParse = roadHeight;\n    while (roadLeftToParse >= 0) {\n        const y = currentY;\n        if (y >= roadHeight) {\n            break;\n        }\n        const downscaleMultiplier = 1 / downscaleIndex;\n        const stripeHeight = Math.ceil(downscaleMultiplier * nearTextureHeight);\n        let y2 = y + stripeHeight;\n        let height = stripeHeight;\n        if (y2 > roadHeight) {\n            y2 = roadHeight;\n            height = Math.round(y2 - y);\n        }\n        if (height > 0) {\n            stripes.push({\n                y,\n                y2,\n                height,\n                stripeIndex,\n            });\n        }\n        roadLeftToParse -= stripeHeight;\n        currentY += stripeHeight;\n        downscaleIndex++;\n        stripeIndex++;\n    }\n    return stripes;\n}\n// TODO: allow custom texture count, not just two, to split the curb\nfunction textureSplitStripes(stripes, { moveOffset, }) {\n    const splitStripes = [];\n    if (stripes.length === 0) {\n        return splitStripes;\n    }\n    const isNegativeMoveOffset = moveOffset < 0;\n    const nearTextureHeight = stripes[0].height;\n    // Based on the nearest stripe and global offset calculate how much this\n    // nearest stripe is offset from zero position. We are going to offset\n    // all of the following stripes based on the same percentages.\n    let restFillPercent = Math.abs(moveOffset % nearTextureHeight) / nearTextureHeight;\n    let primFillPercent = 1 - restFillPercent;\n    // If we are going below zero swap the percentages because the other texture\n    // will be rendered first\n    if (isNegativeMoveOffset) {\n        primFillPercent = 1 - primFillPercent;\n        restFillPercent = 1 - restFillPercent;\n    }\n    // Figure out which texture is rendered first in the current loop based on the\n    // global offset\n    let primTextureIndex = Math.floor(Math.abs(moveOffset) / nearTextureHeight) % 2;\n    // If we are going negative choose the other texture\n    if (isNegativeMoveOffset) {\n        primTextureIndex = 1 - primTextureIndex;\n    }\n    let stripeIndex = 0;\n    for (const stripe of stripes) {\n        // Stripe is split into two sub-stripes based on the global offset.\n        // Each stripe has it's own texture.\n        const primTextureHeight = Math.round(stripe.height * primFillPercent);\n        const restTextureHeight = stripe.height - primTextureHeight;\n        // Add both sub-stripes as separate entries of their own height with\n        // corresponding texture indexes\n        if (primTextureHeight !== 0) {\n            splitStripes.push(Object.assign(Object.assign({}, stripe), { height: primTextureHeight, y2: stripe.y + primTextureHeight, textureIndex: primTextureIndex, stripeIndex }));\n        }\n        if (restTextureHeight !== 0) {\n            splitStripes.push(Object.assign(Object.assign({}, stripe), { height: restTextureHeight, y: stripe.y2 - restTextureHeight, textureIndex: 1 - primTextureIndex, stripeIndex }));\n        }\n        // Alernate to the other texture and make it primary\n        primTextureIndex = 1 - primTextureIndex;\n        stripeIndex++;\n    }\n    return splitStripes;\n}\n\n\n//# sourceURL=webpack:///./src/stripes.ts?");

/***/ }),

/***/ "./src/zone.ts":
/*!*********************!*\
  !*** ./src/zone.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getActiveZone\": () => (/* binding */ getActiveZone),\n/* harmony export */   \"getNextZone\": () => (/* binding */ getNextZone)\n/* harmony export */ });\nfunction getActiveZone({ zones, moveOffset, }) {\n    for (let i = zones.length - 1; i >= 0; i--) {\n        const zone = zones[i];\n        if (moveOffset >= zone.start) {\n            return zone;\n        }\n    }\n}\nfunction getNextZone({ zones, moveOffset, }) {\n    let activeIndex = -1;\n    for (let i = zones.length - 1; i >= 0; i--) {\n        const zone = zones[i];\n        if (moveOffset >= zone.start) {\n            activeIndex = i;\n        }\n    }\n    if (activeIndex !== -1) {\n        const nextIndex = activeIndex + 1;\n        return zones[nextIndex];\n    }\n    return getActiveZone({ zones, moveOffset });\n}\n\n\n//# sourceURL=webpack:///./src/zone.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;