/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/background.ts":
/*!***************************!*\
  !*** ./src/background.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawBackground\": () => (/* binding */ drawBackground),\n/* harmony export */   \"updateBackgroundOffset\": () => (/* binding */ updateBackgroundOffset)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _stripes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stripes */ \"./src/stripes.ts\");\n\n\nfunction drawBackground(ctx, { images, zone, nextZone, bgOffset, moveOffset, yOverride, }) {\n    const nextZoneIn = nextZone.start - moveOffset;\n    const roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.IH - (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    const stripes = (0,_stripes__WEBPACK_IMPORTED_MODULE_1__.generateStripes)({ roadHeight });\n    const roadDepth = (0,_stripes__WEBPACK_IMPORTED_MODULE_1__.stripesUnscaledHeight)(stripes);\n    const activeImage = imageByZoneKind(images, zone.kind);\n    let activeOpacity = 1;\n    if (nextZoneIn > 0 && nextZoneIn < roadDepth) {\n        const inOffset = roadDepth - nextZoneIn;\n        activeOpacity = 1 - inOffset / roadDepth;\n    }\n    drawBackgroundImage(ctx, {\n        image: activeImage,\n        opacity: activeOpacity,\n        bgOffset,\n        yOverride,\n    });\n    if (activeOpacity !== 1) {\n        const nextImage = imageByZoneKind(images, nextZone.kind);\n        const nextOpacity = 1 - activeOpacity;\n        const secondaryImage = drawBackgroundImage(ctx, {\n            image: nextImage,\n            opacity: nextOpacity,\n            bgOffset,\n            yOverride,\n        });\n    }\n}\nfunction drawBackgroundImage(ctx, { image, opacity, bgOffset, yOverride, }) {\n    const offsetX = bgOffset % image.width;\n    const offsetY = 0;\n    const horizonOffsetY = (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH) - _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n    // TODO: make it depend on the steepness of the hill\n    let parallaxMult = 1;\n    if (horizonOffsetY > 0) {\n        // looking up\n        parallaxMult = 0.4;\n    }\n    else if (horizonOffsetY < 0) {\n        // looking down\n        parallaxMult = 0.7;\n    }\n    const sourceOffsetY = 25;\n    const parallaxY = horizonOffsetY * parallaxMult;\n    const sourceX = offsetX;\n    const sourceY = sourceOffsetY - parallaxY;\n    const sourceWidth = _config__WEBPACK_IMPORTED_MODULE_0__.IW;\n    const sourceHeight = yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n    const destX = 0;\n    const destY = 0;\n    const destWidth = _config__WEBPACK_IMPORTED_MODULE_0__.IW;\n    const destHeight = yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n    ctx.globalAlpha = opacity;\n    ctx.drawImage(image, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);\n    if (sourceX < 0) {\n        const overflow = Math.abs(sourceX);\n        const newSourceX = image.width - overflow;\n        const newSourceWidth = overflow;\n        const newDestWidth = overflow;\n        ctx.drawImage(image, newSourceX, sourceY, newSourceWidth, sourceHeight, destX, destY, newDestWidth, destHeight);\n    }\n    if (sourceX > image.width - _config__WEBPACK_IMPORTED_MODULE_0__.IW) {\n        const overflow = sourceX - (image.width - _config__WEBPACK_IMPORTED_MODULE_0__.IW);\n        const newSourceX = 0;\n        const newSourceWidth = overflow;\n        const newDestX = _config__WEBPACK_IMPORTED_MODULE_0__.IW - overflow;\n        const newDestWidth = overflow;\n        ctx.drawImage(image, newSourceX, sourceY, newSourceWidth, sourceHeight, newDestX, destY, newDestWidth, destHeight);\n    }\n    ctx.globalAlpha = 1;\n}\nfunction imageByZoneKind(images, kind) {\n    switch (kind) {\n        case 'green':\n            return images.bgGreen;\n        case 'desert':\n            return images.bgDesert;\n        case 'forest':\n            return images.bgForest;\n        case 'beach':\n            return images.bgBeach;\n        default:\n            throw new Error(`Unsupported bg zone kind: \"${kind}\"`);\n    }\n}\nfunction updateBackgroundOffset({ section, bgOffset, moveOffset, moveOffsetChange, moveSpeed, }) {\n    const entryGap = 200;\n    if (moveSpeed > 0) {\n        const inSectionOffset = moveOffset - section.start;\n        const bgOffsetChange = moveOffsetChange * _config__WEBPACK_IMPORTED_MODULE_0__.BG_SPEED_PER_MOVE_OFFSET;\n        if (section.kind === 'turn-left' && inSectionOffset > entryGap) {\n            return bgOffset - bgOffsetChange;\n        }\n        if (section.kind === 'turn-right' && inSectionOffset > entryGap) {\n            return bgOffset + bgOffsetChange;\n        }\n    }\n    return bgOffset;\n}\n\n\n//# sourceURL=webpack:///./src/background.ts?");

/***/ }),

/***/ "./src/car.ts":
/*!********************!*\
  !*** ./src/car.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultCarState\": () => (/* binding */ defaultCarState),\n/* harmony export */   \"drawCar\": () => (/* binding */ drawCar),\n/* harmony export */   \"getCarBox\": () => (/* binding */ getCarBox),\n/* harmony export */   \"updateCarState\": () => (/* binding */ updateCarState)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve */ \"./src/curve.ts\");\n\n\nfunction drawCar(ctx, { images, upgrades, steerOffset, state, }) {\n    const image = images.car;\n    const scale = 0.7 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const carWidth = image.width * scale;\n    const carHeight = image.height * scale;\n    const centerX = (_config__WEBPACK_IMPORTED_MODULE_0__.IW - carWidth) / 2;\n    const carSteerOffset = -1 * steerOffset * 0.02 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    let x = centerX + carSteerOffset;\n    let y = _config__WEBPACK_IMPORTED_MODULE_0__.IH - 78 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    if (state.curbTimePassed > 0 && state.flipTimePassed === 0) {\n        if (state.curbFrameIndex % 5 === 0) {\n            y += 3;\n            x += 2;\n        }\n        else if (state.curbFrameIndex % 10 === 0) {\n            y += 5;\n            x -= 2;\n        }\n    }\n    if (state.flipTimePassed > 0) {\n        let angle = 0;\n        if (state.flipTimePassed > 0.3) {\n            angle = -90;\n        }\n        if (state.flipTimePassed > 0.9) {\n            angle = -180;\n        }\n        let yOffset = 0;\n        if (state.flipTimePassed > 0) {\n            yOffset = -10;\n        }\n        if (state.flipTimePassed > 0.3) {\n            yOffset = 0;\n        }\n        if (state.flipTimePassed > 0.6) {\n            yOffset = -10;\n        }\n        if (state.flipTimePassed > 0.9) {\n            yOffset = 0;\n        }\n        if (state.flipTimePassed > 1.2) {\n            yOffset = -5;\n        }\n        if (state.flipTimePassed > 1.5) {\n            yOffset = 0;\n        }\n        if (state.flipTimePassed > 1.6) {\n            yOffset = -5;\n        }\n        if (state.flipTimePassed > 1.7) {\n            yOffset = 0;\n        }\n        if (state.flipTimePassed > 1.8) {\n            yOffset = -5;\n        }\n        if (state.flipTimePassed > 1.9) {\n            yOffset = 0;\n        }\n        y += yOffset;\n        const angleInRadians = (Math.PI / 180) * angle;\n        ctx.translate(x + carWidth / 2, y + carHeight / 2);\n        ctx.rotate(angleInRadians);\n        ctx.drawImage(image, -carWidth / 2, -carHeight / 2, carWidth, carHeight);\n        ctx.rotate(-angleInRadians);\n        ctx.translate(-x - carWidth / 2, -y - carHeight / 2);\n    }\n    else {\n        if (state.invincibleTimePassed > 0) {\n            const shouldAlpha = Math.round(state.invincibleTimePassed / 0.1) % 2 === 0;\n            if (shouldAlpha) {\n                ctx.globalAlpha = 0.3;\n            }\n        }\n        ctx.drawImage(image, x, y, carWidth, carHeight);\n        if (state.curbTimePassed > 0) {\n            const curbDurationUpgrade = upgrades.find((u) => u.kind === 'curb-duration');\n            let allowedTime = CURB_ALLOWED_TIME;\n            if (curbDurationUpgrade && curbDurationUpgrade.usagePassed != null) {\n                allowedTime = CURB_ALLOWED_TIME_UPGRADE;\n            }\n            const displayTime = (allowedTime - state.curbTimePassed).toFixed(1);\n            ctx.strokeStyle = '#d78a35';\n            ctx.lineWidth = 1;\n            ctx.font = `10px ${_config__WEBPACK_IMPORTED_MODULE_0__.FONT_PRIMARY}`;\n            ctx.strokeText(displayTime, x + carWidth / 2 - 6, y + carHeight / 2 + 15);\n        }\n        const parachuteUpgrade = upgrades.find((u) => u.kind === 'parachute');\n        if (parachuteUpgrade && parachuteUpgrade.usagePassed != null) {\n            const parachuteImage = images.upgradeParachute;\n            let parachuteY = y;\n            if (Math.round(parachuteUpgrade.usagePassed / 0.05) % 2 === 0) {\n                parachuteY -= 2 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n            }\n            ctx.drawImage(parachuteImage, x, parachuteY, parachuteImage.width, parachuteImage.height);\n        }\n        const nitroUpgrade = upgrades.find((u) => u.kind === 'anti-nitro');\n        if (nitroUpgrade && nitroUpgrade.usagePassed != null) {\n            const nitroImage = images.upgradeNitro;\n            let nitroY = y;\n            if (Math.round(nitroUpgrade.usagePassed / 0.01) % 2 === 0) {\n                nitroY -= 1 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n            }\n            ctx.drawImage(nitroImage, x, nitroY, nitroImage.width, nitroImage.height);\n        }\n        ctx.globalAlpha = 1;\n    }\n}\nfunction getCarBox({ images, steerOffset, }) {\n    const image = images.car;\n    const scale = 0.7 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const width = image.width * scale - 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const height = image.height * scale;\n    const centerX = (_config__WEBPACK_IMPORTED_MODULE_0__.IW - width) / 2;\n    const carSteerOffset = -1 * steerOffset * 0.02 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const depth = 32 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const x = centerX + carSteerOffset;\n    const y = _config__WEBPACK_IMPORTED_MODULE_0__.IH - 78 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const z = 16 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    return {\n        x,\n        y,\n        z,\n        width,\n        height,\n        depth,\n    };\n}\nconst CURB_ALLOWED_OVERFLOW = 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\nconst CURB_ALLOWED_TIME = 2;\nconst CURB_ALLOWED_TIME_UPGRADE = 4;\nconst INVINCIBLE_DURATION = 2;\nconst defaultCarState = {\n    curbTimePassed: 0,\n    curbFrameIndex: 0,\n    flipTimePassed: 0,\n    invincibleTimePassed: 0,\n    isDead: false,\n};\nfunction updateCarState({ soundController, path, state, stripes, upgrades, carBox, collidedBoxes, deltaTime, steerOffset, }) {\n    let curbTimePassed = state.curbTimePassed;\n    let curbFrameIndex = state.curbFrameIndex;\n    let flipTimePassed = state.flipTimePassed;\n    let invincibleTimePassed = state.invincibleTimePassed;\n    if (invincibleTimePassed > 0) {\n        invincibleTimePassed += deltaTime;\n        if (invincibleTimePassed > INVINCIBLE_DURATION) {\n            invincibleTimePassed = 0;\n        }\n    }\n    if (flipTimePassed > 0) {\n        flipTimePassed += deltaTime;\n        curbFrameIndex = curbFrameIndex + 1;\n        return Object.assign(Object.assign({}, state), { curbFrameIndex,\n            flipTimePassed });\n    }\n    const hasHitSomething = collidedBoxes.length > 0;\n    const isInvincible = invincibleTimePassed > 0;\n    if (hasHitSomething && !isInvincible) {\n        // Prioritize bumper over lives is bumper is available\n        const bumperUpgrade = upgrades.find((u) => u.kind === 'bumper');\n        if (bumperUpgrade && bumperUpgrade.cooldownPassed == null) {\n            invincibleTimePassed += deltaTime;\n            bumperUpgrade.cooldownPassed = 0;\n            bumperUpgrade.usagePassed = 0;\n            soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_BRAKE_ID);\n            soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_BUMPER_ID);\n            return Object.assign(Object.assign({}, state), { invincibleTimePassed });\n        }\n        const livesUpgrade = upgrades.find((u) => u.kind === 'lives');\n        if ((livesUpgrade === null || livesUpgrade === void 0 ? void 0 : livesUpgrade.count) > 0) {\n            livesUpgrade.count -= 1;\n            soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_LIFE_LOST_ID);\n            invincibleTimePassed += deltaTime;\n            return Object.assign(Object.assign({}, state), { invincibleTimePassed });\n        }\n        flipTimePassed += deltaTime;\n        soundController.stopAll();\n        soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_HIT_ID);\n        soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_DEATH_ID);\n        return Object.assign(Object.assign({}, state), { flipTimePassed });\n    }\n    const leftCurbX = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.curveXByY)((0,_curve__WEBPACK_IMPORTED_MODULE_1__.steerCurve)(path.left, { steerOffset }), carBox.y + carBox.height);\n    const rightCurbX = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.curveXByY)((0,_curve__WEBPACK_IMPORTED_MODULE_1__.steerCurve)(path.right, { steerOffset }), carBox.y + carBox.height);\n    const isTouchingLeftCurb = leftCurbX - CURB_ALLOWED_OVERFLOW > carBox.x;\n    const isTouchingRightCurb = rightCurbX + CURB_ALLOWED_OVERFLOW < carBox.x + carBox.width;\n    const curbDurationUpgrade = upgrades.find((u) => u.kind === 'curb-duration');\n    if (isTouchingLeftCurb || isTouchingRightCurb) {\n        curbTimePassed += deltaTime;\n        curbFrameIndex = curbFrameIndex + 1;\n        let allowedTime = CURB_ALLOWED_TIME;\n        if (curbDurationUpgrade &&\n            curbDurationUpgrade.usagePassed == null &&\n            curbDurationUpgrade.cooldownPassed == null) {\n            curbDurationUpgrade.cooldownPassed = 0;\n            curbDurationUpgrade.usagePassed = 0;\n        }\n        if (curbDurationUpgrade && curbDurationUpgrade.usagePassed != null) {\n            allowedTime = CURB_ALLOWED_TIME_UPGRADE;\n        }\n        if (curbTimePassed > allowedTime) {\n            flipTimePassed += deltaTime;\n            soundController.stopAll();\n            soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_DEATH_ID);\n        }\n        else {\n            soundController.playLoopIfNotPlaying(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_CURB_ID);\n        }\n    }\n    else {\n        curbTimePassed = 0;\n        curbFrameIndex = 0;\n        soundController.stop(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_CURB_ID);\n        if (curbDurationUpgrade && curbDurationUpgrade.usagePassed != null) {\n            curbDurationUpgrade.usagePassed = null;\n        }\n    }\n    return Object.assign(Object.assign({}, state), { curbTimePassed,\n        curbFrameIndex,\n        flipTimePassed,\n        invincibleTimePassed });\n}\n\n\n//# sourceURL=webpack:///./src/car.ts?");

/***/ }),

/***/ "./src/collision.ts":
/*!**************************!*\
  !*** ./src/collision.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawCollisionBoxes\": () => (/* binding */ drawCollisionBoxes),\n/* harmony export */   \"findCollisions\": () => (/* binding */ findCollisions)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _stripes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stripes */ \"./src/stripes.ts\");\n\n\nfunction findCollisions(sourceBox, targetBoxes) {\n    const targetIndexes = [];\n    for (let i = 0; i < targetBoxes.length; i++) {\n        const targetBox = targetBoxes[i];\n        const intersects = sourceBox.x < targetBox.x + targetBox.width &&\n            sourceBox.x + sourceBox.width > targetBox.x &&\n            sourceBox.y < targetBox.y + targetBox.height &&\n            sourceBox.y + sourceBox.height > targetBox.y &&\n            sourceBox.z < targetBox.z + targetBox.depth &&\n            sourceBox.z + sourceBox.depth > targetBox.z;\n        if (intersects) {\n            targetIndexes.push(i);\n        }\n    }\n    return targetIndexes;\n}\nfunction drawCollisionBoxes(ctx, collidedBoxes, uncollidedBoxes, { stripes, roadDepth }) {\n    drawBoxes(ctx, uncollidedBoxes, {\n        boxColor: 'lightgreen',\n        depthColor: 'green',\n        stripes,\n        roadDepth,\n    });\n    drawBoxes(ctx, collidedBoxes, {\n        boxColor: 'orange',\n        depthColor: 'red',\n        stripes,\n        roadDepth,\n    });\n}\nfunction drawBoxes(ctx, boxes, { boxColor, depthColor, stripes, roadDepth, }) {\n    for (const box of boxes) {\n        ctx.strokeStyle = boxColor;\n        ctx.strokeRect(box.x, box.y, box.width, box.height);\n        ctx.strokeStyle = depthColor;\n        const zy = (0,_stripes__WEBPACK_IMPORTED_MODULE_1__.stripesToY)(stripes, { inOffset: roadDepth - box.z });\n        if (!zy) {\n            // console.log('zy not found: ', box.z);\n            continue;\n        }\n        const zy2 = (0,_stripes__WEBPACK_IMPORTED_MODULE_1__.stripesToY)(stripes, {\n            inOffset: roadDepth - box.z - box.depth,\n        });\n        if (!zy2) {\n            // console.log('zy2 not found', box.z, box.depth);\n            continue;\n        }\n        const bottomZ = _config__WEBPACK_IMPORTED_MODULE_0__.IH - zy;\n        const topZ = _config__WEBPACK_IMPORTED_MODULE_0__.IH - zy2;\n        const zHeight = bottomZ - topZ;\n        ctx.strokeRect(box.x, topZ, box.width, zHeight);\n    }\n}\n\n\n//# sourceURL=webpack:///./src/collision.ts?");

/***/ }),

/***/ "./src/config.ts":
/*!***********************!*\
  !*** ./src/config.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BG_SPEED_PER_MOVE_OFFSET\": () => (/* binding */ BG_SPEED_PER_MOVE_OFFSET),\n/* harmony export */   \"BH\": () => (/* binding */ BH),\n/* harmony export */   \"BW\": () => (/* binding */ BW),\n/* harmony export */   \"FONT_PRIMARY\": () => (/* binding */ FONT_PRIMARY),\n/* harmony export */   \"GH_LINK\": () => (/* binding */ GH_LINK),\n/* harmony export */   \"HH\": () => (/* binding */ HH),\n/* harmony export */   \"HW\": () => (/* binding */ HW),\n/* harmony export */   \"IH\": () => (/* binding */ IH),\n/* harmony export */   \"ITCH_LINK\": () => (/* binding */ ITCH_LINK),\n/* harmony export */   \"IW\": () => (/* binding */ IW),\n/* harmony export */   \"MOVE_ACCELERATION\": () => (/* binding */ MOVE_ACCELERATION),\n/* harmony export */   \"MOVE_DECELERATION_BUMPER_UPGRADE\": () => (/* binding */ MOVE_DECELERATION_BUMPER_UPGRADE),\n/* harmony export */   \"MOVE_DECELERATION_FREE\": () => (/* binding */ MOVE_DECELERATION_FREE),\n/* harmony export */   \"MOVE_DECELERATION_NITRO_UPGRADE\": () => (/* binding */ MOVE_DECELERATION_NITRO_UPGRADE),\n/* harmony export */   \"MOVE_DECELERATION_PARACHUTE_UPGRADE\": () => (/* binding */ MOVE_DECELERATION_PARACHUTE_UPGRADE),\n/* harmony export */   \"MOVE_DECELERATION_REVERSE\": () => (/* binding */ MOVE_DECELERATION_REVERSE),\n/* harmony export */   \"MOVE_DECELERATION_UPHILL_UPGRADE\": () => (/* binding */ MOVE_DECELERATION_UPHILL_UPGRADE),\n/* harmony export */   \"MOVE_SPEED\": () => (/* binding */ MOVE_SPEED),\n/* harmony export */   \"MOVE_SPEED_MAX\": () => (/* binding */ MOVE_SPEED_MAX),\n/* harmony export */   \"MOVE_SPEED_MAX_UPGRADE\": () => (/* binding */ MOVE_SPEED_MAX_UPGRADE),\n/* harmony export */   \"POLE_DRIVE\": () => (/* binding */ POLE_DRIVE),\n/* harmony export */   \"POLE_FULL_STOP\": () => (/* binding */ POLE_FULL_STOP),\n/* harmony export */   \"POLE_START\": () => (/* binding */ POLE_START),\n/* harmony export */   \"RENDER_SCALE\": () => (/* binding */ RENDER_SCALE),\n/* harmony export */   \"RS\": () => (/* binding */ RS),\n/* harmony export */   \"SOUND_BRAKE_ID\": () => (/* binding */ SOUND_BRAKE_ID),\n/* harmony export */   \"SOUND_BUMPER_ID\": () => (/* binding */ SOUND_BUMPER_ID),\n/* harmony export */   \"SOUND_CURB_ID\": () => (/* binding */ SOUND_CURB_ID),\n/* harmony export */   \"SOUND_DEATH_ID\": () => (/* binding */ SOUND_DEATH_ID),\n/* harmony export */   \"SOUND_GAME_THEME_ID\": () => (/* binding */ SOUND_GAME_THEME_ID),\n/* harmony export */   \"SOUND_HIT_ID\": () => (/* binding */ SOUND_HIT_ID),\n/* harmony export */   \"SOUND_LIFE_LOST_ID\": () => (/* binding */ SOUND_LIFE_LOST_ID),\n/* harmony export */   \"SOUND_MENU_FOCUS_ID\": () => (/* binding */ SOUND_MENU_FOCUS_ID),\n/* harmony export */   \"SOUND_MENU_SELECT_ID\": () => (/* binding */ SOUND_MENU_SELECT_ID),\n/* harmony export */   \"SOUND_MENU_THEME_ID\": () => (/* binding */ SOUND_MENU_THEME_ID),\n/* harmony export */   \"SOUND_NITRO_ID\": () => (/* binding */ SOUND_NITRO_ID),\n/* harmony export */   \"STEER_LIMIT\": () => (/* binding */ STEER_LIMIT),\n/* harmony export */   \"STEER_SPEED\": () => (/* binding */ STEER_SPEED),\n/* harmony export */   \"STEER_SPEED_IMPROVED\": () => (/* binding */ STEER_SPEED_IMPROVED),\n/* harmony export */   \"STEER_TURN_COUNTER_FORCE\": () => (/* binding */ STEER_TURN_COUNTER_FORCE)\n/* harmony export */ });\nconst RENDER_SCALE = 1.5;\nconst RS = RENDER_SCALE;\nconst BW = 380 * RENDER_SCALE;\nconst BH = 200 * RENDER_SCALE;\nconst IW = BW;\nconst IH = BH;\nconst HW = IW / 2; // half = 190\nconst HH = IH / 2; // half = 100\nconst STEER_LIMIT = Infinity;\nconst STEER_TURN_COUNTER_FORCE = 4 * RS;\nconst MOVE_SPEED = 5 * RS;\nconst STEER_SPEED = 5 * RS;\nconst STEER_SPEED_IMPROVED = 8 * RS;\nconst BG_SPEED_PER_MOVE_OFFSET = 0.4;\nconst MOVE_ACCELERATION = 0.03;\nconst MOVE_DECELERATION_UPHILL_UPGRADE = 0.01;\nconst MOVE_DECELERATION_BUMPER_UPGRADE = 0.07;\nconst MOVE_DECELERATION_PARACHUTE_UPGRADE = 0.15;\nconst MOVE_DECELERATION_NITRO_UPGRADE = 0.11;\nconst MOVE_DECELERATION_FREE = 0.05;\nconst MOVE_DECELERATION_REVERSE = 0.1;\nconst MOVE_SPEED_MAX = 8;\nconst MOVE_SPEED_MAX_UPGRADE = 7;\nconst POLE_START = 1000;\nconst POLE_DRIVE = 500;\nconst POLE_FULL_STOP = 100;\nconst FONT_PRIMARY = 'retro_gaming';\nconst SOUND_MENU_SELECT_ID = 'menuSelect1';\nconst SOUND_MENU_FOCUS_ID = 'menuFocus1';\nconst SOUND_MENU_THEME_ID = 'menu3';\nconst SOUND_GAME_THEME_ID = 'theme1';\nconst SOUND_CURB_ID = 'curb2';\nconst SOUND_DEATH_ID = 'death1';\nconst SOUND_HIT_ID = 'hit1';\nconst SOUND_LIFE_LOST_ID = 'life1';\nconst SOUND_BRAKE_ID = 'brake2';\nconst SOUND_BUMPER_ID = 'bumper1';\nconst SOUND_NITRO_ID = 'brake3';\nconst GH_LINK = 'https://github.com/dogballs/gimme-a-brake';\nconst ITCH_LINK = 'https://heckx2.itch.io/';\n\n\n//# sourceURL=webpack:///./src/config.ts?");

/***/ }),

/***/ "./src/controls.ts":
/*!*************************!*\
  !*** ./src/controls.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InputControl\": () => (/* binding */ InputControl),\n/* harmony export */   \"KeyboardListener\": () => (/* binding */ KeyboardListener)\n/* harmony export */ });\nvar KeyboardButtonCode;\n(function (KeyboardButtonCode) {\n    KeyboardButtonCode[KeyboardButtonCode[\"Enter\"] = 13] = \"Enter\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Esc\"] = 27] = \"Esc\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Space\"] = 32] = \"Space\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Left\"] = 37] = \"Left\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Up\"] = 38] = \"Up\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Right\"] = 39] = \"Right\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Down\"] = 40] = \"Down\";\n    KeyboardButtonCode[KeyboardButtonCode[\"W\"] = 87] = \"W\";\n    KeyboardButtonCode[KeyboardButtonCode[\"A\"] = 65] = \"A\";\n    KeyboardButtonCode[KeyboardButtonCode[\"D\"] = 68] = \"D\";\n    KeyboardButtonCode[KeyboardButtonCode[\"S\"] = 83] = \"S\";\n})(KeyboardButtonCode || (KeyboardButtonCode = {}));\nvar InputControl;\n(function (InputControl) {\n    InputControl[InputControl[\"Up\"] = 0] = \"Up\";\n    InputControl[InputControl[\"Down\"] = 1] = \"Down\";\n    InputControl[InputControl[\"Left\"] = 2] = \"Left\";\n    InputControl[InputControl[\"Right\"] = 3] = \"Right\";\n    InputControl[InputControl[\"Select\"] = 4] = \"Select\";\n    InputControl[InputControl[\"Back\"] = 5] = \"Back\";\n})(InputControl || (InputControl = {}));\nconst binding = {\n    [InputControl.Up]: [KeyboardButtonCode.Up, KeyboardButtonCode.W],\n    [InputControl.Down]: [KeyboardButtonCode.Down, KeyboardButtonCode.S],\n    [InputControl.Left]: [KeyboardButtonCode.Left, KeyboardButtonCode.A],\n    [InputControl.Right]: [KeyboardButtonCode.Right, KeyboardButtonCode.D],\n    [InputControl.Select]: [KeyboardButtonCode.Enter, KeyboardButtonCode.Space],\n    [InputControl.Back]: [KeyboardButtonCode.Esc],\n};\nclass KeyboardListener {\n    constructor(target = undefined) {\n        this.target = target;\n        this.listenedDownCodes = [];\n        this.downCodes = [];\n        this.holdCodes = [];\n        this.upCodes = [];\n        this.handleWindowKeyDown = (ev) => {\n            const { keyCode } = ev;\n            if (!this.listenedDownCodes.includes(keyCode)) {\n                this.listenedDownCodes.push(keyCode);\n            }\n        };\n        this.handleWindowKeyUp = (ev) => {\n            const { keyCode } = ev;\n            const index = this.listenedDownCodes.indexOf(keyCode);\n            if (index !== -1) {\n                this.listenedDownCodes.splice(index, 1);\n            }\n        };\n        this.handleWindowBlur = () => {\n            this.listenedDownCodes = [];\n        };\n    }\n    listen() {\n        document.addEventListener('keydown', this.handleWindowKeyDown);\n        document.addEventListener('keyup', this.handleWindowKeyUp);\n        window.addEventListener('blur', this.handleWindowBlur);\n    }\n    unlisten() {\n        document.removeEventListener('keydown', this.handleWindowKeyDown);\n        document.removeEventListener('keyup', this.handleWindowKeyUp);\n        window.removeEventListener('blur', this.handleWindowBlur);\n    }\n    update() {\n        const codes = this.listenedDownCodes;\n        const downCodes = [];\n        const holdCodes = [];\n        for (const code of codes) {\n            // Newly pressed key, which was not previously down or hold\n            if (!this.downCodes.includes(code) && !this.holdCodes.includes(code)) {\n                downCodes.push(code);\n            }\n            // Key that was down on previous frame is now considered hold, because\n            // it is still down on current frame.\n            // Hold key continues to be hold.\n            if (this.downCodes.includes(code) || this.holdCodes.includes(code)) {\n                holdCodes.push(code);\n            }\n        }\n        // Find keycodes that were down or hold on previous frame, which means\n        // that in current frame they are considered up\n        const upCodes = [];\n        for (const code of this.downCodes) {\n            if (!codes.includes(code)) {\n                upCodes.push(code);\n            }\n        }\n        for (const code of this.holdCodes) {\n            if (!codes.includes(code)) {\n                upCodes.push(code);\n            }\n        }\n        this.downCodes = downCodes;\n        this.holdCodes = holdCodes;\n        this.upCodes = upCodes;\n    }\n    isDownAny() {\n        return this.downCodes.length > 0;\n    }\n    isDown(control) {\n        const codes = binding[control];\n        return codes.some((code) => this.downCodes.includes(code));\n    }\n    isHold(control) {\n        const codes = binding[control];\n        return codes.some((code) => this.holdCodes.includes(code));\n    }\n    getHoldLastOf(controls) {\n        let latestIndex = -1;\n        let latestControl = undefined;\n        for (const control of controls) {\n            const codes = binding[control];\n            for (const code of codes) {\n                const codeIndex = this.holdCodes.indexOf(code);\n                if (codeIndex !== -1 && codeIndex > latestIndex) {\n                    latestIndex = codeIndex;\n                    latestControl = control;\n                }\n            }\n        }\n        return latestControl;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/controls.ts?");

/***/ }),

/***/ "./src/curve.ts":
/*!**********************!*\
  !*** ./src/curve.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DEFAULT_BOTTOM_DELTA\": () => (/* binding */ DEFAULT_BOTTOM_DELTA),\n/* harmony export */   \"DEFAULT_BOTTOM_LEFT_X\": () => (/* binding */ DEFAULT_BOTTOM_LEFT_X),\n/* harmony export */   \"DEFAULT_BOTTOM_RIGHT_X\": () => (/* binding */ DEFAULT_BOTTOM_RIGHT_X),\n/* harmony export */   \"curveXByY\": () => (/* binding */ curveXByY),\n/* harmony export */   \"drawCurve\": () => (/* binding */ drawCurve),\n/* harmony export */   \"leftRoadCurve\": () => (/* binding */ leftRoadCurve),\n/* harmony export */   \"lerpCurve\": () => (/* binding */ lerpCurve),\n/* harmony export */   \"pointOnCurve\": () => (/* binding */ pointOnCurve),\n/* harmony export */   \"rightRoadCurve\": () => (/* binding */ rightRoadCurve),\n/* harmony export */   \"steerCurve\": () => (/* binding */ steerCurve),\n/* harmony export */   \"translateCurve\": () => (/* binding */ translateCurve),\n/* harmony export */   \"translateCurveUniform\": () => (/* binding */ translateCurveUniform)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\n// Line equation:\n// left: 5x + 18y = 2700\n// right: 18 y - 5 x = 800\nconst DEFAULT_BOTTOM_DELTA = 180 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\nconst DEFAULT_BOTTOM_LEFT_X = -DEFAULT_BOTTOM_DELTA;\nconst DEFAULT_BOTTOM_RIGHT_X = _config__WEBPACK_IMPORTED_MODULE_0__.IW + DEFAULT_BOTTOM_DELTA;\nfunction leftRoadCurve(controlX, controlY, topX, topY, bottomX = DEFAULT_BOTTOM_LEFT_X, bottomY = _config__WEBPACK_IMPORTED_MODULE_0__.IH) {\n    return { controlX, controlY, topX, topY, bottomX, bottomY };\n}\nfunction rightRoadCurve(controlX, controlY, topX, topY, bottomX = DEFAULT_BOTTOM_RIGHT_X, bottomY = _config__WEBPACK_IMPORTED_MODULE_0__.IH) {\n    return { controlX, controlY, topX, topY, bottomX, bottomY };\n}\nfunction translateCurveUniform(c, offset) {\n    return translateCurve(c, { control: offset, top: offset, bottom: offset });\n}\nfunction translateCurve(c, { control = 0, top = 0, bottom = 0, }) {\n    return Object.assign(Object.assign({}, c), { controlX: c.controlX + control, topX: c.topX + top, bottomX: c.bottomX + bottom });\n}\nfunction steerCurve(curve, { steerOffset }) {\n    const adjustedSteerOffset = steerOffset * 1;\n    return Object.assign(Object.assign({}, curve), { bottomX: curve.bottomX + adjustedSteerOffset });\n}\nfunction lerpCurve(c1, c2, t) {\n    console.assert(t >= 0 && t <= 1, 'd must be normalized: %d', t);\n    const controlX = c1.controlX + (c2.controlX - c1.controlX) * t;\n    const controlY = c1.controlY + (c2.controlY - c1.controlY) * t;\n    const topX = c1.topX + (c2.topX - c1.topX) * t;\n    const topY = c1.topY + (c2.topY - c1.topY) * t;\n    const bottomX = c1.bottomX + (c2.bottomX - c1.bottomX) * t;\n    const bottomY = c1.bottomY + (c2.bottomY - c1.bottomY) * t;\n    return {\n        controlX,\n        controlY,\n        topX,\n        topY,\n        bottomX,\n        bottomY,\n    };\n}\n// https://stackoverflow.com/a/5634528/1573638\nfunction pointOnCurve(curve, t) {\n    console.assert(t >= 0 && t <= 1, 't must be normalized: %d', t);\n    const x = (1 - t) * (1 - t) * curve.bottomX +\n        2 * (1 - t) * t * curve.controlX +\n        t * t * curve.topX;\n    const y = (1 - t) * (1 - t) * curve.bottomY +\n        2 * (1 - t) * t * curve.controlY +\n        t * t * curve.topY;\n    return { x, y };\n}\nfunction curveXByY(curve, y) {\n    // TODO: optimize: binary search? lut?\n    for (let t = 0; t <= 1; t += 0.01) {\n        const p = pointOnCurve(curve, t);\n        if (Math.abs(p.y - y) <= 1 * _config__WEBPACK_IMPORTED_MODULE_0__.RS) {\n            return p.x;\n        }\n    }\n    return undefined;\n}\nfunction drawCurve(ctx, originalCurve, { moveOffset, steerOffset, color = 'orange', dashPattern, }) {\n    ctx.strokeStyle = color;\n    if (dashPattern) {\n        ctx.setLineDash(dashPattern);\n    }\n    ctx.lineDashOffset = moveOffset;\n    const curve = steerCurve(originalCurve, {\n        steerOffset,\n    });\n    ctx.beginPath();\n    ctx.moveTo(curve.bottomX, curve.bottomY);\n    ctx.quadraticCurveTo(curve.controlX, curve.controlY, curve.topX, curve.topY);\n    ctx.stroke();\n}\n\n\n//# sourceURL=webpack:///./src/curve.ts?");

/***/ }),

/***/ "./src/decor.ts":
/*!**********************!*\
  !*** ./src/decor.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawDecors\": () => (/* binding */ drawDecors),\n/* harmony export */   \"generateDecors\": () => (/* binding */ generateDecors),\n/* harmony export */   \"generateDecorsForZones\": () => (/* binding */ generateDecorsForZones)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve */ \"./src/curve.ts\");\n/* harmony import */ var _road__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./road */ \"./src/road.ts\");\n/* harmony import */ var _stripes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stripes */ \"./src/stripes.ts\");\n/* harmony import */ var _random__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./random */ \"./src/random.ts\");\n\n\n\n\n\n// TODO: they disappear when the bottom of the image hits the bottom of the screen\n//   -> better top of the image hits the bottom of the screen\n// TODO: variation in sizes\n// TODO: z-index with the car?\n// TODO: add preshow too?\nfunction drawDecors(ctx, { decors, images, path, section, moveOffset, steerOffset, yOverride, }) {\n    var _a;\n    let roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.IH - (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    // Not using yOverride because it will re-create the stripes when the road\n    // is transitioning from straight to uphill/downhill.\n    if (section.kind === 'uphill') {\n        roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n    }\n    else if (section.kind === 'downhill') {\n        roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.HH + section.steepness;\n    }\n    const stripes = (0,_stripes__WEBPACK_IMPORTED_MODULE_3__.generateStripes)({ roadHeight });\n    const travelDistance = (0,_stripes__WEBPACK_IMPORTED_MODULE_3__.stripesUnscaledHeight)(stripes);\n    let preshowSize = 200;\n    for (const decor of decors) {\n        // Offset appearance so that decor positioned at 0 in the map is actually\n        // rendered visually at 0 right from the start.\n        const appearStart = decor.start - travelDistance;\n        const appearEnd = decor.start;\n        const preshowAppearStart = appearStart - preshowSize;\n        if (moveOffset >= preshowAppearStart && moveOffset <= appearEnd) {\n            const isPreshow = moveOffset < appearStart;\n            const curbPath = (0,_road__WEBPACK_IMPORTED_MODULE_2__.getCurbPath)(path, { steerOffset });\n            const sourceCurve = decor.placement === 'right' ? curbPath.right : curbPath.left;\n            const placementSign = decor.placement === 'right' ? 1 : -1;\n            const decorCurve = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.translateCurve)(sourceCurve, {\n                top: 5 * placementSign,\n                control: 10 * placementSign,\n                bottom: 20 * placementSign,\n            });\n            const driftedCurve = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.translateCurveUniform)(decorCurve, ((_a = decor.driftOffset) !== null && _a !== void 0 ? _a : 0) * placementSign);\n            let inOffset = moveOffset - decor.start + travelDistance;\n            if (isPreshow) {\n                inOffset = 1;\n            }\n            const stripesY = (0,_stripes__WEBPACK_IMPORTED_MODULE_3__.stripesToY)(stripes, { inOffset });\n            if (stripesY === undefined) {\n                continue;\n            }\n            const decorY = _config__WEBPACK_IMPORTED_MODULE_0__.IH - stripesY;\n            const decorX = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.curveXByY)((0,_curve__WEBPACK_IMPORTED_MODULE_1__.steerCurve)(driftedCurve, { steerOffset }), decorY);\n            if (decorX === undefined) {\n                continue;\n            }\n            let inHalfHeightT = stripesY / _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n            let imageScale = Math.max(0, 1 - (1 - 0.1 * _config__WEBPACK_IMPORTED_MODULE_0__.RENDER_SCALE) * inHalfHeightT);\n            let imageOpacity = 1;\n            if (roadHeight > _config__WEBPACK_IMPORTED_MODULE_0__.HH && decorY < _config__WEBPACK_IMPORTED_MODULE_0__.HH) {\n                const inOverHeightT = Math.max(0, 1 - (_config__WEBPACK_IMPORTED_MODULE_0__.HH - decorY) / (roadHeight - _config__WEBPACK_IMPORTED_MODULE_0__.HH));\n                imageScale = 0.1 * inOverHeightT;\n            }\n            else if (isPreshow) {\n                imageScale *= 1 - (appearStart - moveOffset) / preshowSize;\n                imageOpacity = 1 - (appearStart - moveOffset) / preshowSize;\n            }\n            const image = imageByKind(images, decor.kind);\n            const imageWidth = image.width * imageScale;\n            const imageHeight = image.height * imageScale;\n            const imageX = decor.placement === 'right' ? decorX : decorX - imageWidth;\n            const imageY = decorY - imageHeight;\n            ctx.globalAlpha = imageOpacity;\n            ctx.drawImage(image, imageX, imageY, imageWidth, imageHeight);\n            ctx.globalAlpha = 1;\n        }\n    }\n}\nfunction imageByKind(images, kind) {\n    switch (kind) {\n        case 'green-bush':\n            return images.decorGreenBush;\n        case 'green-tree':\n            return images.decorGreenTree;\n        case 'green-rock':\n            return images.decorGreenRock;\n        case 'desert-cactus':\n            return images.decorDesertCactus;\n        case 'desert-sand':\n            return images.decorDesertSand;\n        case 'desert-bush':\n            return images.decorDesertBush;\n        case 'forest-tree':\n            return images.decorForestTree;\n        case 'forest-spruce':\n            return images.decorForestSpruce;\n        case 'beach-buoy':\n            return images.decorBeachBuoy;\n        default:\n            throw new Error(`Unsupported decor kind: \"${kind}\"`);\n    }\n}\nfunction generateDecors({ startOffset, size, amount = 0, driftMax = 50, kinds = ['green-bush', 'green-rock', 'green-tree'], }) {\n    const decors = [];\n    if (size === 0 || amount === 0) {\n        return decors;\n    }\n    const areaSize = size / amount;\n    // Go reverse to have the farthest decors in the array first, which means the\n    // closest will be rendered last, which is better for zindex.\n    for (let i = amount - 1; i >= 0; i--) {\n        const areaStart = i * areaSize;\n        const inAreaOffset = (0,_random__WEBPACK_IMPORTED_MODULE_4__.randomNumber)(0, areaSize);\n        const start = startOffset + areaStart + inAreaOffset;\n        const kind = (0,_random__WEBPACK_IMPORTED_MODULE_4__.randomElement)(kinds);\n        const driftOffset = (0,_random__WEBPACK_IMPORTED_MODULE_4__.randomNumber)(0, driftMax);\n        const placement = (0,_random__WEBPACK_IMPORTED_MODULE_4__.randomElement)(['left', 'right']);\n        decors.push({\n            start,\n            kind,\n            placement,\n            driftOffset,\n        });\n    }\n    return decors;\n}\nconst KINDS_BY_ZONE = new Map();\nKINDS_BY_ZONE.set('green', ['green-bush', 'green-rock', 'green-tree']);\nKINDS_BY_ZONE.set('desert', ['desert-cactus', 'desert-bush', 'desert-sand']);\nKINDS_BY_ZONE.set('forest', ['forest-tree', 'forest-spruce']);\nKINDS_BY_ZONE.set('beach', ['beach-buoy']);\nfunction generateDecorsForZones({ zones }) {\n    var _a;\n    const decors = [];\n    for (let i = 0; i < zones.length; i++) {\n        const zone = zones[i];\n        const nextZone = zones[i + 1];\n        const zoneDecors = generateDecors({\n            startOffset: zone.start,\n            size: nextZone ? nextZone.start - zone.start : 0,\n            amount: (_a = zone.decorCount) !== null && _a !== void 0 ? _a : 0,\n            kinds: KINDS_BY_ZONE.get(zone.kind),\n        });\n        decors.push(...zoneDecors);\n    }\n    return decors;\n}\n\n\n//# sourceURL=webpack:///./src/decor.ts?");

/***/ }),

/***/ "./src/ending.ts":
/*!***********************!*\
  !*** ./src/ending.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultEndingState\": () => (/* binding */ defaultEndingState),\n/* harmony export */   \"drawEnding\": () => (/* binding */ drawEnding),\n/* harmony export */   \"updateEndingState\": () => (/* binding */ updateEndingState)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\nconst defaultEndingState = {\n    isInitiated: false,\n    isLight: false,\n    isSteerDone: false,\n    isCarGone: false,\n    initiatedPassed: 0,\n    isDone: false,\n    lightPassed: 0,\n};\nfunction drawEnding(ctx, { images, state, }) {\n    const { lightPassed, initiatedPassed } = state;\n    if (lightPassed === 0) {\n        return;\n    }\n    let lightIndex = Math.min(9, Math.round(lightPassed * 2));\n    let changeAlpha = Math.round(lightPassed / 0.05) % 2 === 0;\n    if (lightIndex >= 9) {\n        changeAlpha = false;\n    }\n    if (lightPassed > 5) {\n        lightIndex = 0;\n    }\n    if (lightPassed > 5) {\n        lightIndex = -1;\n    }\n    if (lightIndex === -1) {\n        if (initiatedPassed > 14) {\n            const ufoImage = images.ufo;\n            let scale = 1;\n            if (initiatedPassed > 22) {\n                scale = Math.max(0, 1 - (initiatedPassed - 22) / 1);\n            }\n            ctx.globalAlpha =\n                Math.round(initiatedPassed / 0.05) % 2 === 0 ? 0.2 : 0.1;\n            ctx.drawImage(ufoImage, 100, 100, ufoImage.width * scale, ufoImage.height * scale);\n            ctx.globalAlpha = 1;\n        }\n        return;\n    }\n    const frameWidth = 140;\n    const frameHeight = 200;\n    const frameX = lightIndex * frameWidth;\n    const frameY = 0;\n    const lightImage = images.ufoLight;\n    const destWidth = frameWidth * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const destHeight = frameHeight * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const destX = (_config__WEBPACK_IMPORTED_MODULE_0__.IW - destWidth) / 2;\n    const destY = 0;\n    if (changeAlpha) {\n        ctx.globalAlpha = 0.5;\n    }\n    ctx.drawImage(lightImage, frameX, frameY, frameWidth, frameHeight, destX, destY, destWidth, destHeight);\n    ctx.globalAlpha = 1;\n}\nfunction updateEndingState({ keyboardListener, soundController, deltaTime, zone, state, }) {\n    let lightPassed = state.lightPassed;\n    let initiatedPassed = state.initiatedPassed;\n    let isCarGone = state.isCarGone;\n    let isLight = state.isLight;\n    let isDone = state.isDone;\n    if (zone.isEnding && !state.isInitiated) {\n        soundController.play('ufo4');\n        keyboardListener.unlisten();\n        return Object.assign(Object.assign({}, state), { isInitiated: true });\n    }\n    if (!state.isInitiated) {\n        return state;\n    }\n    initiatedPassed += deltaTime;\n    if (!isLight) {\n        if (initiatedPassed > 5) {\n            soundController.stop('theme1');\n            soundController.play('ufo3');\n            return Object.assign(Object.assign({}, state), { initiatedPassed, isLight: true });\n        }\n        return Object.assign(Object.assign({}, state), { initiatedPassed });\n    }\n    if (!isCarGone) {\n        lightPassed += deltaTime;\n        if (lightPassed > 5) {\n            isCarGone = true;\n            soundController.stop('car');\n            soundController.play('ufo1');\n        }\n    }\n    if (!isDone) {\n        if (initiatedPassed > 26) {\n            return Object.assign(Object.assign({}, state), { isDone: true });\n        }\n    }\n    return Object.assign(Object.assign({}, state), { lightPassed,\n        initiatedPassed,\n        isCarGone });\n}\n\n\n//# sourceURL=webpack:///./src/ending.ts?");

/***/ }),

/***/ "./src/fragment.ts":
/*!*************************!*\
  !*** ./src/fragment.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createDownhill\": () => (/* binding */ createDownhill),\n/* harmony export */   \"createTurn\": () => (/* binding */ createTurn),\n/* harmony export */   \"createUphill\": () => (/* binding */ createUphill),\n/* harmony export */   \"lerpFragments\": () => (/* binding */ lerpFragments),\n/* harmony export */   \"straightFragment\": () => (/* binding */ straightFragment)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve */ \"./src/curve.ts\");\n/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path */ \"./src/path.ts\");\n\n\n\nconst straightFragment = {\n    left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n    right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n    end: 0,\n};\nfunction createDownhill({ size, steepness, inOffset, steerOffset, }) {\n    const halfSize = size / 2;\n    const d = 1 - Math.abs((inOffset - halfSize) / halfSize);\n    const yOffset = -steepness * d;\n    const y = _config__WEBPACK_IMPORTED_MODULE_0__.HH + yOffset;\n    const minY = _config__WEBPACK_IMPORTED_MODULE_0__.HH - steepness;\n    let fragments = [\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 10, y),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 10, y),\n            end: 100 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 25, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 25, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 10, minY),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 25, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 25, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 10, minY),\n            end: 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 25, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 15, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 10, minY),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 25, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 15, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 10, minY),\n            end: size - 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        Object.assign(Object.assign({}, straightFragment), { end: size }),\n    ];\n    fragments = steerFragments(fragments, steerOffset);\n    return fragments;\n}\nfunction createUphill({ size, steepness, inOffset, steerOffset, }) {\n    const halfSize = size / 2;\n    const d = 1 - Math.abs((inOffset - halfSize) / halfSize);\n    const yOffset = steepness * d;\n    const y = _config__WEBPACK_IMPORTED_MODULE_0__.HH + yOffset;\n    const maxY = _config__WEBPACK_IMPORTED_MODULE_0__.HH + steepness;\n    const xCorrection = steerOffset * 0.15;\n    const bottomLeftCorrection = steerOffset * 0.1;\n    const cxCorrection = steerOffset * 0.2;\n    let fragments = [\n        // {\n        //   left: leftRoadCurve(\n        //     HW - 70,\n        //     y - 5,\n        //     HW - 60 + xCorrection,\n        //     y,\n        //     -180 - bottomLeftCorrection,\n        //   ),\n        //   right: rightRoadCurve(\n        //     HW + 70,\n        //     y - 5,\n        //     HW + 60 + xCorrection,\n        //     y,\n        //     560 - bottomLeftCorrection,\n        //   ),\n        //   end: 300,\n        // },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 120 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + cxCorrection, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 90 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + xCorrection, maxY, _curve__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_BOTTOM_LEFT_X - bottomLeftCorrection),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 120 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + cxCorrection, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 90 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + xCorrection, maxY, _curve__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_BOTTOM_RIGHT_X - bottomLeftCorrection),\n            end: 400 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 120 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + cxCorrection, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 90 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + xCorrection, maxY, _curve__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_BOTTOM_LEFT_X - bottomLeftCorrection),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 120 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + cxCorrection, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 90 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + xCorrection, maxY, _curve__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_BOTTOM_RIGHT_X - bottomLeftCorrection),\n            end: size - 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        Object.assign(Object.assign({}, straightFragment), { end: size }),\n    ];\n    fragments = steerFragments(fragments, steerOffset);\n    return fragments;\n}\nfunction createTurn({ size, direction, steerOffset, }) {\n    console.assert(size >= 600 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, 'turn too quick: %d', size);\n    let fragments = [\n        // {\n        //   left: [HW - 10, HH - 5, HW - 10, HH],\n        //   right: [HW + 190, HH + 50, HW + 10, HH],\n        //   end: 100,\n        // },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH - 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            end: 100 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 50 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH - 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 115 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 15 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 115 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            end: 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH - 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 80 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 15 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 115 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            end: size - 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH - 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 60 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 0 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 80 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            end: size - 100 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        Object.assign(Object.assign({}, straightFragment), { end: size }),\n    ];\n    if (direction === 'left') {\n        fragments = mirrorFragments(fragments);\n    }\n    fragments = steerFragments(fragments, steerOffset);\n    return fragments;\n}\nfunction mirrorFragments(fragments) {\n    return fragments.map((fragment) => {\n        const { left, right } = fragment;\n        return Object.assign(Object.assign({}, fragment), { left: Object.assign(Object.assign({}, left), { controlX: _config__WEBPACK_IMPORTED_MODULE_0__.HW + (_config__WEBPACK_IMPORTED_MODULE_0__.HW - right.controlX), controlY: right.controlY, topX: _config__WEBPACK_IMPORTED_MODULE_0__.HW + (_config__WEBPACK_IMPORTED_MODULE_0__.HW - right.topX), topY: right.topY }), right: Object.assign(Object.assign({}, right), { controlX: _config__WEBPACK_IMPORTED_MODULE_0__.HW + (_config__WEBPACK_IMPORTED_MODULE_0__.HW - left.controlX), controlY: left.controlY, topX: _config__WEBPACK_IMPORTED_MODULE_0__.HW + (_config__WEBPACK_IMPORTED_MODULE_0__.HW - left.topX), topY: left.topY }) });\n    });\n}\nfunction steerFragments(fragments, steerOffset) {\n    const topOffset = steerOffset * 0.01;\n    return fragments.map((fragment) => {\n        const { left, right } = fragment;\n        return Object.assign(Object.assign({}, fragment), { left: Object.assign(Object.assign({}, left), { controlX: left.controlX + topOffset, topX: left.topX + topOffset }), right: Object.assign(Object.assign({}, right), { controlX: right.controlX + topOffset, topX: right.topX + topOffset }) });\n    });\n}\nfunction lerpFragments({ fragments, inOffset, }) {\n    const activeIndex = fragments.findIndex((fragment) => {\n        return inOffset < fragment.end;\n    });\n    const prevIndex = activeIndex !== -1 ? activeIndex - 1 : -1;\n    const prevFragment = fragments[prevIndex] || straightFragment;\n    const activeFragment = fragments[activeIndex] || straightFragment;\n    let d = 0;\n    const fragmentSize = activeFragment.end - prevFragment.end;\n    const inFragmentOffset = inOffset - prevFragment.end;\n    if (fragmentSize !== 0) {\n        d = inFragmentOffset / fragmentSize;\n    }\n    const path = (0,_path__WEBPACK_IMPORTED_MODULE_2__.lerpPath)(prevFragment, activeFragment, d);\n    return path;\n}\n\n\n//# sourceURL=webpack:///./src/fragment.ts?");

/***/ }),

/***/ "./src/images.ts":
/*!***********************!*\
  !*** ./src/images.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"loadImages\": () => (/* binding */ loadImages)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction loadImages() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const images = [\n            ['car', 'data/graphics/car.png'],\n            // Backgrounds\n            ['bgDebug', 'data/graphics/bg-debug.png'],\n            ['bgGreen', 'data/graphics/bg-green.png'],\n            ['bgDesert', 'data/graphics/bg-desert.png'],\n            ['bgForest', 'data/graphics/bg-forest.png'],\n            ['bgBeach', 'data/graphics/bg-beach.png'],\n            // Decor - green\n            ['decorGreenBush', 'data/graphics/decor-green-bush.png'],\n            ['decorGreenTree', 'data/graphics/decor-green-tree.png'],\n            ['decorGreenRock', 'data/graphics/decor-green-rock.png'],\n            // Decor - desert\n            ['decorDesertCactus', 'data/graphics/decor-desert-cactus.png'],\n            ['decorDesertSand', 'data/graphics/decor-desert-sand.png'],\n            ['decorDesertBush', 'data/graphics/decor-desert-bush.png'],\n            // Decor - forest\n            ['decorForestTree', 'data/graphics/decor-forest-tree.png'],\n            ['decorForestSpruce', 'data/graphics/decor-forest-spruce.png'],\n            // Decor - beach\n            ['decorBeachBuoy', 'data/graphics/decor-beach-buoy.png'],\n            // Prop - green\n            ['propGreenBike', 'data/graphics/prop-green-bike.png'],\n            ['propGreenRoadwork', 'data/graphics/prop-green-roadwork.png'],\n            ['propGreenSheep', 'data/graphics/prop-green-sheep.png'],\n            ['propGreenCar', 'data/graphics/prop-green-car.png'],\n            ['propGreenTurtle', 'data/graphics/prop-green-turtle.png'],\n            // Prop - desert\n            ['propDesertTumbleweed', 'data/graphics/prop-desert-tumbleweed.png'],\n            ['propDesertBike', 'data/graphics/prop-desert-bike.png'],\n            // Prop - beach\n            ['propBeachBarrel', 'data/graphics/prop-beach-barrel.png'],\n            ['propBeachBarrelStand', 'data/graphics/prop-beach-barrel-stand.png'],\n            ['propBeachDolphin', 'data/graphics/prop-beach-dolphin.png'],\n            ['propBeachDolphinHead', 'data/graphics/prop-beach-dolphin-head.png'],\n            // Upgrades\n            ['upgrades', 'data/graphics/upgrades.png'],\n            ['upgradeParachute', 'data/graphics/upgrade-parachute.png'],\n            ['upgradeNitro', 'data/graphics/upgrade-nitro.png'],\n            // Poles\n            ['poleRed', 'data/graphics/pole-red.png'],\n            ['poleGreen', 'data/graphics/pole-green.png'],\n            ['poleEnergy', 'data/graphics/pole-energy.png'],\n            // Menu\n            ['menuBullet', 'data/graphics/menu-bullet.png'],\n            // Ending\n            ['ufoLight', 'data/graphics/ufo-light-Sheet.png'],\n            ['ufo', 'data/graphics/ufo.png'],\n        ];\n        const promises = images.map(([id, path]) => __awaiter(this, void 0, void 0, function* () {\n            return { id, image: yield loadImage(path) };\n        }));\n        const results = yield Promise.all(promises);\n        const map = {};\n        results.forEach(({ id, image }) => {\n            map[id] = image;\n        });\n        return map;\n    });\n}\nfunction loadImage(imagePath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve) => {\n            const image = new Image();\n            image.src = imagePath;\n            image.addEventListener('load', () => {\n                resolve(image);\n            });\n        });\n    });\n}\n\n\n//# sourceURL=webpack:///./src/images.ts?");

/***/ }),

/***/ "./src/loop.ts":
/*!*********************!*\
  !*** ./src/loop.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GameLoop\": () => (/* binding */ GameLoop)\n/* harmony export */ });\nconst DEFAULT_OPTIONS = {\n    deltaTimeLimit: 1,\n    // requestAnimationFrame is usually 60 fps; in seconds\n    fps: 60,\n};\nvar State;\n(function (State) {\n    State[State[\"Idle\"] = 0] = \"Idle\";\n    State[State[\"Working\"] = 1] = \"Working\";\n    State[State[\"StopRequested\"] = 2] = \"StopRequested\";\n})(State || (State = {}));\nclass GameLoop {\n    constructor(options = {}) {\n        this.lastTimestamp = null;\n        this.requestedStop = false;\n        this.state = State.Idle;\n        this.loop = (timestamp = null) => {\n            var _a, _b;\n            if (this.state === State.Idle) {\n                return;\n            }\n            if (this.state === State.StopRequested) {\n                this.state = State.Idle;\n                return;\n            }\n            const idealDeltaTime = this.getIdealDeltaTime();\n            // For the very first run loop() is called from the code and timestamp is\n            // not known. On the second call loop() is called by requestAnimationFrame,\n            // which also provides a timestamp.\n            // Use ideal fixed delta value for the first run.\n            let deltaTime = idealDeltaTime;\n            if (timestamp !== null) {\n                // Timestamp is originally in milliseconds, convert to seconds\n                deltaTime = (timestamp - this.lastTimestamp) / 1000;\n                // If delta is too large, we must have resumed from stop() or breakpoint.\n                // Use ideal default delta only for this frame.\n                if (deltaTime > this.options.deltaTimeLimit) {\n                    deltaTime = idealDeltaTime;\n                }\n            }\n            this.lastTimestamp = timestamp;\n            const lastTime = timestamp / 1000;\n            (_b = (_a = this.options).onTick) === null || _b === void 0 ? void 0 : _b.call(_a, { deltaTime, lastTime });\n            window.requestAnimationFrame(this.loop);\n        };\n        this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n    }\n    start() {\n        if (this.state !== State.Idle) {\n            return;\n        }\n        this.state = State.Working;\n        this.loop();\n    }\n    // WARNING: a couple of already queued callbacks might still fire after stop\n    stop() {\n        if (this.state !== State.Working) {\n            return;\n        }\n        this.state = State.StopRequested;\n    }\n    getIdealDeltaTime() {\n        return 1 / this.options.fps;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/loop.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _car__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./car */ \"./src/car.ts\");\n/* harmony import */ var _collision__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./collision */ \"./src/collision.ts\");\n/* harmony import */ var _controls__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./controls */ \"./src/controls.ts\");\n/* harmony import */ var _background__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./background */ \"./src/background.ts\");\n/* harmony import */ var _decor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./decor */ \"./src/decor.ts\");\n/* harmony import */ var _ending__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ending */ \"./src/ending.ts\");\n/* harmony import */ var _images__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./images */ \"./src/images.ts\");\n/* harmony import */ var _menu__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./menu */ \"./src/menu.ts\");\n/* harmony import */ var _loop__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./loop */ \"./src/loop.ts\");\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./map */ \"./src/map.ts\");\n/* harmony import */ var _pole__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./pole */ \"./src/pole.ts\");\n/* harmony import */ var _prop__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./prop */ \"./src/prop.ts\");\n/* harmony import */ var _road__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./road */ \"./src/road.ts\");\n/* harmony import */ var _section__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./section */ \"./src/section.ts\");\n/* harmony import */ var _sound__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./sound */ \"./src/sound.ts\");\n/* harmony import */ var _speed__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./speed */ \"./src/speed.ts\");\n/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./state */ \"./src/state.ts\");\n/* harmony import */ var _steer__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./steer */ \"./src/steer.ts\");\n/* harmony import */ var _stripes__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./stripes */ \"./src/stripes.ts\");\n/* harmony import */ var _zone__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./zone */ \"./src/zone.ts\");\n/* harmony import */ var _upgrade__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./upgrade */ \"./src/upgrade.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst loadingElement = document.querySelector('[data-loading]');\nconst crashElement = document.querySelector('[data-crash]');\nconst canvas = document.createElement('canvas');\nconst ctx = canvas.getContext('2d');\ncanvas.width = _config__WEBPACK_IMPORTED_MODULE_0__.IW;\ncanvas.height = _config__WEBPACK_IMPORTED_MODULE_0__.IH;\nconst offCanvas = new OffscreenCanvas(_config__WEBPACK_IMPORTED_MODULE_0__.IW, _config__WEBPACK_IMPORTED_MODULE_0__.IH);\nconst offCtx = offCanvas.getContext('2d');\nconst keyboardListener = new _controls__WEBPACK_IMPORTED_MODULE_3__.KeyboardListener(canvas);\nconst audioCtx = new AudioContext();\nconst speedAudio = new _speed__WEBPACK_IMPORTED_MODULE_16__.SpeedAudio(audioCtx);\nconst soundController = new _sound__WEBPACK_IMPORTED_MODULE_15__.SoundController(audioCtx);\nconst resources = {\n    map: (0,_map__WEBPACK_IMPORTED_MODULE_10__.generateMap)(),\n    images: undefined,\n    sounds: undefined,\n};\nconst state = (0,_state__WEBPACK_IMPORTED_MODULE_17__.createGlobalState)();\nconst resetGlobalState = (0,_state__WEBPACK_IMPORTED_MODULE_17__.createResetGlobalState)(state, () => {\n    resources.map = (0,_map__WEBPACK_IMPORTED_MODULE_10__.generateMap)();\n});\nconst loop = new _loop__WEBPACK_IMPORTED_MODULE_9__.GameLoop({\n    onTick: tick,\n});\nfunction draw({ deltaTime, lastTime, zone, nextZone, section, path, propBoxes, yOverride, }) {\n    ctx.clearRect(0, 0, _config__WEBPACK_IMPORTED_MODULE_0__.IW, _config__WEBPACK_IMPORTED_MODULE_0__.IH);\n    const { bgOffset, moveOffset, steerState: { steerOffset }, } = state;\n    // Draw the road stripes full width. Then cut it out and keep the area that is\n    // actually covered by the road (the ground area will become transparent\n    // again). Do it offscreen because we have to apply another mask and it's hard\n    // to do on a single canvas.\n    offCtx.globalCompositeOperation = 'source-over';\n    (0,_stripes__WEBPACK_IMPORTED_MODULE_19__.drawRoadStripes)(offCtx, { zone, nextZone, moveOffset, yOverride });\n    offCtx.globalCompositeOperation = 'destination-in';\n    (0,_road__WEBPACK_IMPORTED_MODULE_13__.drawRoadMask)(offCtx, path, { steerOffset });\n    ctx.drawImage(offCanvas, 0, 0);\n    // Ditto for the road. Except the curbs are drawn to the main canvas behind\n    // the already present road.\n    offCtx.globalCompositeOperation = 'source-over';\n    (0,_stripes__WEBPACK_IMPORTED_MODULE_19__.drawCurbStripes)(offCtx, { zone, nextZone, moveOffset, yOverride });\n    offCtx.globalCompositeOperation = 'destination-in';\n    (0,_road__WEBPACK_IMPORTED_MODULE_13__.drawCurbMask)(offCtx, path, { steerOffset });\n    ctx.globalCompositeOperation = 'destination-over';\n    ctx.drawImage(offCanvas, 0, 0);\n    // Then draw the ground stripes full widths but behind the road - it will keep\n    // the road+curbs that were drawn on the previous step and only fill in the\n    // ground stripes on the sides.\n    ctx.globalCompositeOperation = 'destination-over';\n    (0,_stripes__WEBPACK_IMPORTED_MODULE_19__.drawGroundStripes)(ctx, { zone, nextZone, moveOffset, yOverride });\n    // Then draw everything on top\n    ctx.globalCompositeOperation = 'source-over';\n    (0,_background__WEBPACK_IMPORTED_MODULE_4__.drawBackground)(ctx, {\n        images: resources.images,\n        zone,\n        nextZone,\n        moveOffset,\n        bgOffset,\n        yOverride,\n    });\n    (0,_decor__WEBPACK_IMPORTED_MODULE_5__.drawDecors)(ctx, {\n        decors: resources.map.decors,\n        images: resources.images,\n        path,\n        section,\n        moveOffset,\n        steerOffset,\n        yOverride,\n    });\n    if (!state.menuState.isOpen) {\n        (0,_prop__WEBPACK_IMPORTED_MODULE_12__.drawProps)(ctx, {\n            lastTime,\n            propBoxes,\n            images: resources.images,\n            moveOffset,\n            steerOffset,\n        });\n    }\n    (0,_pole__WEBPACK_IMPORTED_MODULE_11__.drawPoles)(ctx, {\n        images: resources.images,\n        poles: resources.map.poles,\n        deltaTime,\n        path,\n        zone,\n        nextZone,\n        moveOffset,\n        steerOffset,\n        yOverride,\n    });\n    if (!state.menuState.isOpen && !state.endingState.isCarGone) {\n        (0,_car__WEBPACK_IMPORTED_MODULE_1__.drawCar)(ctx, {\n            images: resources.images,\n            upgrades: state.upgradeState.upgrades,\n            steerOffset,\n            state: state.carState,\n        });\n    }\n    // drawDebug(ctx, {\n    //   section,\n    //   bgOffset,\n    //   moveOffset,\n    //   upgrades: state.upgradeState.upgrades,\n    //   ...state.speedState,\n    //   ...state.steerState,\n    // });\n    // drawHorizon(ctx);\n    if (!state.endingState.isInitiated) {\n        (0,_upgrade__WEBPACK_IMPORTED_MODULE_21__.drawActiveUpgrades)(ctx, {\n            lastTime,\n            images: resources.images,\n            state: state.upgradeState,\n        });\n    }\n    if (!state.menuState.isOpen && !state.endingState.isInitiated) {\n        (0,_speed__WEBPACK_IMPORTED_MODULE_16__.drawSpeedometer)(ctx, {\n            state: state.speedState,\n            upgrades: state.upgradeState.upgrades,\n        });\n    }\n    if (!state.menuState.isOpen) {\n        (0,_ending__WEBPACK_IMPORTED_MODULE_6__.drawEnding)(ctx, {\n            images: resources.images,\n            state: state.endingState,\n        });\n    }\n    (0,_upgrade__WEBPACK_IMPORTED_MODULE_21__.drawUpgradeDialog)(ctx, {\n        lastTime,\n        images: resources.images,\n        state: state.upgradeState,\n    });\n    (0,_menu__WEBPACK_IMPORTED_MODULE_8__.drawMenu)(ctx, {\n        lastTime,\n        state: state.menuState,\n        images: resources.images,\n    });\n    // drawCurve(ctx, path.left, {\n    //   moveOffset: state.moveOffset,\n    //   steerOffset: state.steerState.steerOffset,\n    // });\n}\nfunction getInput() {\n    const isUp = keyboardListener.isHold(_controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Up);\n    const isDown = keyboardListener.isHold(_controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Down);\n    const lastPressedThrottleControl = keyboardListener.getHoldLastOf([\n        _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Up,\n        _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Down,\n    ]);\n    const isThrottleActive = lastPressedThrottleControl === _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Up;\n    const isReverseActive = lastPressedThrottleControl === _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Down;\n    const lastPressedTurnControl = keyboardListener.getHoldLastOf([\n        _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Left,\n        _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Right,\n    ]);\n    const isLeftTurnActive = lastPressedTurnControl === _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Left;\n    const isRightTurnActive = lastPressedTurnControl === _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Right;\n    return {\n        isThrottleActive,\n        isReverseActive,\n        isRightTurnActive,\n        isLeftTurnActive,\n    };\n}\nfunction updateLevelState() {\n    // NOTE: don't destructure the state here because it is constantly updated\n    const { isThrottleActive, isReverseActive, isRightTurnActive, isLeftTurnActive, } = getInput();\n    const section = (0,_section__WEBPACK_IMPORTED_MODULE_14__.getActiveSection)({\n        sections: resources.map.sections,\n        moveOffset: state.moveOffset,\n    });\n    const nextPole = (0,_pole__WEBPACK_IMPORTED_MODULE_11__.getNextPole)({\n        poles: resources.map.poles,\n        moveOffset: state.moveOffset,\n    });\n    state.speedState = (0,_speed__WEBPACK_IMPORTED_MODULE_16__.updateMoveSpeedState)(Object.assign({ section,\n        nextPole, upgrades: state.upgradeState.upgrades, carState: state.carState, moveOffset: state.moveOffset, isThrottleActive,\n        isReverseActive }, state.speedState));\n    state.moveOffsetChange = state.speedState.moveSpeed;\n    state.moveOffset += state.moveOffsetChange;\n    state.steerState = (0,_steer__WEBPACK_IMPORTED_MODULE_18__.updateSteerState)(Object.assign({ section, upgrades: state.upgradeState.upgrades, nextPole, carState: state.carState, endingState: state.endingState, isLeftTurnActive,\n        isRightTurnActive, moveSpeed: state.speedState.moveSpeed, moveOffset: state.moveOffset }, state.steerState));\n    state.bgOffset = (0,_background__WEBPACK_IMPORTED_MODULE_4__.updateBackgroundOffset)({\n        section,\n        bgOffset: state.bgOffset,\n        moveOffset: state.moveOffset,\n        moveOffsetChange: state.moveOffsetChange,\n        moveSpeed: state.speedState.moveSpeed,\n    });\n}\nfunction updateCollisions({ path, section, nextSection, roadDepth, yOverride, }) {\n    const carBox = (0,_car__WEBPACK_IMPORTED_MODULE_1__.getCarBox)({\n        images: resources.images,\n        steerOffset: state.steerState.steerOffset,\n    });\n    const propBoxes = (0,_prop__WEBPACK_IMPORTED_MODULE_12__.getPropBoxes)({\n        soundController,\n        props: resources.map.props,\n        images: resources.images,\n        path,\n        section,\n        nextSection,\n        moveOffset: state.moveOffset,\n        steerOffset: state.steerState.steerOffset,\n        yOverride,\n    });\n    const collidedBoxes = [];\n    const uncollidedBoxes = [];\n    const targetIndexes = (0,_collision__WEBPACK_IMPORTED_MODULE_2__.findCollisions)(carBox, propBoxes);\n    if (targetIndexes.length > 0) {\n        // collidedBoxes.push(carBox);\n        collidedBoxes.push(...targetIndexes.map((index) => propBoxes[index]));\n    }\n    else {\n        uncollidedBoxes.push(carBox, ...propBoxes);\n    }\n    return {\n        collidedBoxes,\n        uncollidedBoxes,\n        carBox,\n        propBoxes,\n    };\n}\nfunction tick({ deltaTime, lastTime, }) {\n    keyboardListener.update();\n    state.menuState = (0,_menu__WEBPACK_IMPORTED_MODULE_8__.updateMenuState)({\n        keyboardListener,\n        soundController,\n        resetGlobalState,\n        state: state.menuState,\n        carState: state.carState,\n        speedState: state.speedState,\n        endingState: state.endingState,\n        deltaTime,\n    });\n    soundController.setGlobalMuted(!state.menuState.isSoundOn);\n    // Don't continue state updates if it was reset in the menu\n    if (state.gotReset) {\n        state.gotReset = false;\n        return;\n    }\n    // NOTE: Don't destructure until after all state updates\n    const nextPole = (0,_pole__WEBPACK_IMPORTED_MODULE_11__.getNextPole)({\n        poles: resources.map.poles,\n        moveOffset: state.moveOffset,\n    });\n    state.upgradeState = (0,_upgrade__WEBPACK_IMPORTED_MODULE_21__.updateUpgradeState)({\n        keyboardListener,\n        soundController,\n        deltaTime,\n        state: state.upgradeState,\n        nextPole,\n        moveOffset: state.moveOffset,\n    });\n    if (!state.menuState.isOpen && !state.upgradeState.isDialogOpen) {\n        updateLevelState();\n    }\n    else if (state.menuState.isWin) {\n        state.moveOffset += state.moveOffsetChange;\n    }\n    const section = (0,_section__WEBPACK_IMPORTED_MODULE_14__.getActiveSection)({\n        sections: resources.map.sections,\n        moveOffset: state.moveOffset,\n    });\n    const nextSection = (0,_section__WEBPACK_IMPORTED_MODULE_14__.getNextSection)({\n        sections: resources.map.sections,\n        moveOffset: state.moveOffset,\n    });\n    const zone = (0,_zone__WEBPACK_IMPORTED_MODULE_20__.getActiveZone)({\n        zones: resources.map.zones,\n        moveOffset: state.moveOffset,\n    });\n    const nextZone = (0,_zone__WEBPACK_IMPORTED_MODULE_20__.getNextZone)({\n        zones: resources.map.zones,\n        moveOffset: state.moveOffset,\n    });\n    state.endingState = (0,_ending__WEBPACK_IMPORTED_MODULE_6__.updateEndingState)({\n        keyboardListener,\n        soundController,\n        deltaTime,\n        zone,\n        state: state.endingState,\n    });\n    const { path, yOverride } = (0,_section__WEBPACK_IMPORTED_MODULE_14__.createSectionFragments)({\n        section,\n        moveOffset: state.moveOffset,\n        steerOffset: state.steerState.steerOffset,\n    });\n    let roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.IH - (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    const stripes = (0,_stripes__WEBPACK_IMPORTED_MODULE_19__.generateStripes)({ roadHeight });\n    const roadDepth = (0,_stripes__WEBPACK_IMPORTED_MODULE_19__.stripesUnscaledHeight)(stripes);\n    const { collidedBoxes, uncollidedBoxes, carBox, propBoxes } = updateCollisions({\n        section,\n        nextSection,\n        path,\n        roadDepth,\n        yOverride,\n    });\n    state.carState = (0,_car__WEBPACK_IMPORTED_MODULE_1__.updateCarState)({\n        soundController,\n        path,\n        state: state.carState,\n        stripes,\n        upgrades: state.upgradeState.upgrades,\n        carBox,\n        collidedBoxes,\n        deltaTime,\n        steerOffset: state.steerState.steerOffset,\n    });\n    draw({\n        deltaTime,\n        lastTime,\n        zone,\n        nextZone,\n        section,\n        path,\n        yOverride,\n        propBoxes,\n    });\n    // drawCollisionBoxes(ctx, collidedBoxes, uncollidedBoxes, {\n    //   stripes,\n    //   roadDepth,\n    // });\n    if (!state.menuState.isOpen) {\n        speedAudio.update(Object.assign({ menuState: state.menuState, upgrades: state.upgradeState.upgrades }, state.speedState));\n    }\n}\nfunction main() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            // TODO: parallelize\n            loadingElement.textContent = 'Loading images...';\n            resources.images = yield (0,_images__WEBPACK_IMPORTED_MODULE_7__.loadImages)();\n            loadingElement.textContent = 'Loading sounds...';\n            resources.sounds = yield (0,_sound__WEBPACK_IMPORTED_MODULE_15__.loadSounds)();\n            document.body.appendChild(canvas);\n            keyboardListener.listen();\n            soundController.sounds = resources.sounds;\n            loop.start();\n        }\n        catch (err) {\n            crash();\n            console.error(err);\n        }\n        finally {\n            loadingElement.style.display = 'none';\n        }\n    });\n}\nfunction crash() {\n    loop.stop();\n    try {\n        document.body.removeChild(canvas);\n    }\n    catch (err) { }\n    crashElement.style.display = 'flex';\n}\nmain();\n\n\n//# sourceURL=webpack:///./src/main.ts?");

/***/ }),

/***/ "./src/map.ts":
/*!********************!*\
  !*** ./src/map.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"coolMap\": () => (/* binding */ coolMap),\n/* harmony export */   \"generateMap\": () => (/* binding */ generateMap),\n/* harmony export */   \"longLeftTurnMap\": () => (/* binding */ longLeftTurnMap),\n/* harmony export */   \"longUphillMap\": () => (/* binding */ longUphillMap),\n/* harmony export */   \"straightMap\": () => (/* binding */ straightMap)\n/* harmony export */ });\n/* harmony import */ var _decor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decor */ \"./src/decor.ts\");\n/* harmony import */ var _pole__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pole */ \"./src/pole.ts\");\n/* harmony import */ var _prop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./prop */ \"./src/prop.ts\");\n\n\n\nconst zones = [\n    {\n        start: 0,\n        kind: 'green',\n        propCount: 0,\n        decorCount: 20,\n        skipPole: true,\n    },\n    {\n        start: 3000,\n        kind: 'green',\n        propCount: 20,\n        decorCount: 100,\n        skipPole: true,\n    },\n    {\n        start: 25000,\n        kind: 'desert',\n        propCount: 20,\n        decorCount: 100,\n    },\n    {\n        start: 62000,\n        kind: 'beach',\n        propCount: 20,\n        decorCount: 20,\n    },\n    {\n        start: 93000,\n        kind: 'forest',\n        propCount: 20,\n        decorCount: 2000,\n    },\n    {\n        start: 124000,\n        kind: 'forest',\n        propCount: 0,\n        decorCount: 1000,\n        skipPole: true,\n        isEnding: true,\n    },\n    {\n        start: 124000 + 18000,\n        kind: 'forest',\n        propCount: 0,\n        decorCount: 20,\n        skipPole: true,\n        isEnding: true,\n    },\n];\n// Test the ending\n// const zones: Zone[] = [\n//   {\n//     start: 0,\n//     kind: 'green',\n//     propCount: 0,\n//     decorCount: 20,\n//     skipPole: true,\n//   },\n//   {\n//     start: 2000,\n//     kind: 'forest',\n//     propCount: 0,\n//     decorCount: 1000,\n//     skipPole: true,\n//     isEnding: true,\n//   },\n//   {\n//     start: 18000,\n//     kind: 'forest',\n//     propCount: 0,\n//     decorCount: 20,\n//     skipPole: true,\n//     isEnding: true,\n//   },\n// ];\nconst decors = (0,_decor__WEBPACK_IMPORTED_MODULE_0__.generateDecorsForZones)({ zones });\nconst poles = (0,_pole__WEBPACK_IMPORTED_MODULE_1__.generatePolesForZones)({ zones });\nconst props = (0,_prop__WEBPACK_IMPORTED_MODULE_2__.generatePropsForZones)({ zones });\nconst straightMap = {\n    zones,\n    decors,\n    poles,\n    props,\n    sections: [],\n};\nconst coolMap = {\n    zones,\n    decors,\n    poles,\n    props,\n    sections: [\n        {\n            kind: 'uphill',\n            start: 1500,\n            size: 1200,\n            steepness: 30,\n        },\n        {\n            kind: 'turn-left',\n            start: 4000,\n            size: 1000,\n        },\n        {\n            kind: 'turn-right',\n            start: 6000,\n            size: 1500,\n        },\n        {\n            kind: 'downhill',\n            start: 8000,\n            size: 1500,\n            steepness: 50,\n        },\n    ],\n};\nfunction generateMap() {\n    const decors = (0,_decor__WEBPACK_IMPORTED_MODULE_0__.generateDecorsForZones)({ zones });\n    const poles = (0,_pole__WEBPACK_IMPORTED_MODULE_1__.generatePolesForZones)({ zones });\n    const props = (0,_prop__WEBPACK_IMPORTED_MODULE_2__.generatePropsForZones)({ zones });\n    const map = {\n        zones,\n        decors,\n        poles,\n        props,\n        sections: [],\n    };\n    return map;\n}\nconst longUphillMap = {\n    zones,\n    decors,\n    poles,\n    sections: [\n        {\n            kind: 'uphill',\n            start: 2000,\n            size: 15000,\n            steepness: 30,\n        },\n    ],\n    props: [],\n};\nconst longLeftTurnMap = {\n    zones,\n    decors,\n    poles,\n    props,\n    sections: [\n        {\n            kind: 'turn-right',\n            start: 0,\n            size: Infinity,\n        },\n    ],\n};\n\n\n//# sourceURL=webpack:///./src/map.ts?");

/***/ }),

/***/ "./src/menu.ts":
/*!*********************!*\
  !*** ./src/menu.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultMenuState\": () => (/* binding */ defaultMenuState),\n/* harmony export */   \"drawMenu\": () => (/* binding */ drawMenu),\n/* harmony export */   \"updateMenuState\": () => (/* binding */ updateMenuState)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _controls__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./controls */ \"./src/controls.ts\");\n\n\nconst SKIP_FOR_DEV = false;\nconst defaultMenuState = {\n    isOpen: SKIP_FOR_DEV ? false : true,\n    isAnyKey: SKIP_FOR_DEV ? false : true,\n    isSoundOn: true,\n    // isSoundOn: false,\n    isPlaying: false,\n    isGameOver: false,\n    isWin: false,\n    isCredits: false,\n    deathTimePassed: 0,\n    selectedIndex: 0,\n};\nconst MAIN_MENU_ITEMS = [\n    { id: 'play', label: 'PLAY' },\n    { id: 'sound', label: 'SOUND: ' },\n    { id: 'credits', label: 'CREDITS' },\n];\nconst GAME_OVER_ITEMS = [\n    { id: 'retry', label: 'TRY AGAIN' },\n    { id: 'main', label: 'MAIN MENU' },\n];\nconst WIN_ITEMS = [\n    { id: 'credits', label: 'CREDITS' },\n    { id: 'main', label: 'MAIN MENU' },\n];\nconst CREDITS_ITEMS = [\n    { id: 'github', label: 'GITHUB' },\n    { id: 'itch', label: 'ITCH.IO' },\n    { id: 'main', label: 'MAIN MENU' },\n];\nfunction drawMenu(ctx, { lastTime, state, images, }) {\n    if (!state.isOpen) {\n        return;\n    }\n    if (state.isCredits) {\n        drawCreditsMenu(ctx, { lastTime, state, images });\n        return;\n    }\n    if (state.isWin) {\n        drawWinMenu(ctx, { lastTime, state, images });\n        return;\n    }\n    if (state.isGameOver) {\n        drawGameOverMenu(ctx, {\n            lastTime,\n            state,\n            images,\n        });\n        return;\n    }\n    drawOverlay(ctx);\n    if (state.isAnyKey) {\n        const shouldShow = Math.round(lastTime / 0.5) % 2 === 1;\n        if (!shouldShow) {\n            return;\n        }\n        const x = (_config__WEBPACK_IMPORTED_MODULE_0__.IW - 260 * _config__WEBPACK_IMPORTED_MODULE_0__.RS) / 2;\n        const y = 110 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n        drawBigText(ctx, { text: 'PRESS ANY SPACEBAR', size: 20, x, y });\n        return;\n    }\n    const textX = (_config__WEBPACK_IMPORTED_MODULE_0__.IW - 270 * _config__WEBPACK_IMPORTED_MODULE_0__.RS) / 2;\n    const textY = 60 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    drawBigText(ctx, { text: 'GIMME A BRAKE', size: 30, x: textX, y: textY });\n    MAIN_MENU_ITEMS.forEach((item, index) => {\n        drawItem(ctx, {\n            lastTime,\n            images,\n            state,\n            item,\n            index,\n            isSelected: index === state.selectedIndex,\n        });\n    });\n}\nfunction drawBigText(ctx, { text, size, x, y, fillStyle = '#fff', }) {\n    ctx.lineWidth = 1;\n    ctx.font = `${size * _config__WEBPACK_IMPORTED_MODULE_0__.RS}px ${_config__WEBPACK_IMPORTED_MODULE_0__.FONT_PRIMARY}`;\n    ctx.fillStyle = fillStyle;\n    ctx.strokeStyle = '#000';\n    ctx.fillText(text, x, y);\n    ctx.lineWidth = 2;\n    ctx.strokeText(text, x, y);\n}\nfunction drawOverlay(ctx) {\n    const overlayWidth = 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const overlayHeight = 150 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    ctx.fillStyle = '#444';\n    ctx.globalAlpha = 0.7;\n    ctx.fillRect(0, 0, _config__WEBPACK_IMPORTED_MODULE_0__.IW, _config__WEBPACK_IMPORTED_MODULE_0__.IH);\n    ctx.globalAlpha = 1;\n}\nfunction drawItem(ctx, { lastTime, images, state, item, index, isSelected, offX = 90, startY = 100, }) {\n    const textX = (_config__WEBPACK_IMPORTED_MODULE_0__.IW - offX * _config__WEBPACK_IMPORTED_MODULE_0__.RS) / 2;\n    const textY = startY * _config__WEBPACK_IMPORTED_MODULE_0__.RS + 22 * _config__WEBPACK_IMPORTED_MODULE_0__.RS * index;\n    ctx.font = `${17 * _config__WEBPACK_IMPORTED_MODULE_0__.RS}px ${_config__WEBPACK_IMPORTED_MODULE_0__.FONT_PRIMARY}`;\n    ctx.fillStyle = isSelected ? '#e42424' : '#fff';\n    let text = item.label;\n    if (item.id === 'sound') {\n        text += '' + (state.isSoundOn ? 'ON' : 'OFF');\n    }\n    if (item.id === 'play' && state.isPlaying) {\n        text = 'CONTINUE';\n    }\n    ctx.fillText(text, textX, textY);\n    ctx.strokeStyle = '#000';\n    ctx.lineWidth = 1;\n    if (isSelected) {\n        const shouldShow = Math.round(lastTime / 0.5) % 2 === 1;\n        if (!shouldShow) {\n            return;\n        }\n        const image = images.menuBullet;\n        ctx.imageSmoothingEnabled = false;\n        ctx.drawImage(image, textX - 16 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, textY - 12 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, image.width * 2 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, image.height * 2 * _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n        ctx.imageSmoothingEnabled = true;\n    }\n}\nfunction drawGameOverMenu(ctx, { lastTime, state, images, }) {\n    drawOverlay(ctx);\n    const textX = 110 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const textY = 50 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    drawBigText(ctx, {\n        text: 'GAME OVER :(',\n        size: 25,\n        x: textX,\n        y: textY,\n        fillStyle: '#e42424',\n    });\n    GAME_OVER_ITEMS.forEach((item, index) => {\n        drawItem(ctx, {\n            lastTime,\n            images,\n            state,\n            item,\n            index,\n            isSelected: index === state.selectedIndex,\n        });\n    });\n}\nfunction drawWinMenu(ctx, { lastTime, state, images, }) {\n    drawOverlay(ctx);\n    const textX = 120 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const textY = 50 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    drawBigText(ctx, {\n        text: 'YOU WON?',\n        size: 25,\n        x: textX,\n        y: textY,\n        fillStyle: '#15aa25',\n    });\n    WIN_ITEMS.forEach((item, index) => {\n        drawItem(ctx, {\n            lastTime,\n            images,\n            state,\n            item,\n            index,\n            isSelected: index === state.selectedIndex,\n        });\n    });\n}\nfunction drawCreditsMenu(ctx, { lastTime, state, images, }) {\n    drawOverlay(ctx);\n    ctx.fillStyle = '#aaa';\n    ctx.font = `${8 * _config__WEBPACK_IMPORTED_MODULE_0__.RS}px ${_config__WEBPACK_IMPORTED_MODULE_0__.FONT_PRIMARY}`;\n    ctx.fillText('CODE + ART', 80 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, 40 * _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n    ctx.fillStyle = '#fff';\n    ctx.font = `${14 * _config__WEBPACK_IMPORTED_MODULE_0__.RS}px ${_config__WEBPACK_IMPORTED_MODULE_0__.FONT_PRIMARY}`;\n    ctx.fillText('@heck_x2', 65 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, 60 * _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n    ctx.fillStyle = '#aaa';\n    ctx.font = `${8 * _config__WEBPACK_IMPORTED_MODULE_0__.RS}px ${_config__WEBPACK_IMPORTED_MODULE_0__.FONT_PRIMARY}`;\n    ctx.fillText('MUSIC + SOUND', 240 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, 40 * _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n    ctx.fillStyle = '#fff';\n    ctx.font = `${14 * _config__WEBPACK_IMPORTED_MODULE_0__.RS}px ${_config__WEBPACK_IMPORTED_MODULE_0__.FONT_PRIMARY}`;\n    ctx.fillText('TBD', 240 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, 60 * _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n    CREDITS_ITEMS.forEach((item, index) => {\n        drawItem(ctx, {\n            lastTime,\n            images,\n            state,\n            item,\n            index,\n            isSelected: index === state.selectedIndex,\n            startY: 120,\n            // offX: 100,\n        });\n    });\n}\nfunction updateMenuState({ state, carState, speedState, endingState, deltaTime, keyboardListener, soundController, resetGlobalState, }) {\n    if (!state.isOpen) {\n        // Ending\n        if (!state.isWin && endingState.isDone) {\n            keyboardListener.listen();\n            soundController.play('win2');\n            return Object.assign(Object.assign({}, state), { isWin: true, isOpen: true });\n        }\n        // Observe speed state and car state for triggering death\n        if (carState.flipTimePassed > 0 && speedState.moveSpeed === 0) {\n            const deathTimePassed = state.deathTimePassed + deltaTime;\n            // Trigger game over menu a bit later\n            if (deathTimePassed > 1.5) {\n                soundController.stopAll();\n                soundController.play('lost1');\n                return Object.assign(Object.assign({}, state), { isOpen: true, isGameOver: true });\n            }\n            return Object.assign(Object.assign({}, state), { deathTimePassed });\n        }\n        // Pressing ESC when playing\n        const isBack = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Back);\n        if (isBack) {\n            // Ignore ESC when death animation started\n            if (carState.flipTimePassed > 0) {\n                return state;\n            }\n            soundController.pauseAll();\n            soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_MENU_SELECT_ID);\n            return Object.assign(Object.assign({}, state), { isOpen: true });\n        }\n        return state;\n    }\n    // Credits screen\n    if (state.isCredits) {\n        return updateCreditsState({\n            keyboardListener,\n            soundController,\n            state,\n            resetGlobalState,\n        });\n    }\n    // Win screen\n    if (state.isWin) {\n        return updateWinState({\n            keyboardListener,\n            soundController,\n            state,\n            resetGlobalState,\n        });\n    }\n    // Game over screen\n    if (state.isGameOver) {\n        return updateGameOverState({\n            keyboardListener,\n            soundController,\n            state,\n            resetGlobalState,\n        });\n    }\n    // Entry screen\n    if (state.isAnyKey) {\n        const isDown = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Select);\n        const isAnyKey = !isDown;\n        return Object.assign(Object.assign({}, state), { isAnyKey });\n    }\n    // Main menu\n    soundController.playLoopIfNotPlaying(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_MENU_THEME_ID);\n    let selectedIndex = state.selectedIndex;\n    const isUp = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Up);\n    const isDown = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Down);\n    const isSelect = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Select);\n    const isBack = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Back);\n    // Pressing ESC when the menu is open to close it\n    if (state.isPlaying && isBack) {\n        return returnToPlaying({ state, soundController });\n    }\n    if (isSelect) {\n        // Pressing PLAY\n        if (selectedIndex === 0) {\n            if (state.isPlaying) {\n                return returnToPlaying({ state, soundController });\n            }\n            return startPlaying({ state, soundController });\n        }\n        if (selectedIndex === 1) {\n            const isSoundOn = !state.isSoundOn;\n            soundController.setGlobalMuted(!isSoundOn);\n            soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_MENU_SELECT_ID);\n            return Object.assign(Object.assign({}, state), { isSoundOn });\n        }\n        if (selectedIndex === 2) {\n            soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_MENU_SELECT_ID);\n            return Object.assign(Object.assign({}, state), { selectedIndex: 2, isCredits: true });\n        }\n        return Object.assign({}, state);\n    }\n    if (isUp) {\n        selectedIndex = Math.max(0, selectedIndex - 1);\n    }\n    else if (isDown) {\n        selectedIndex = Math.min(MAIN_MENU_ITEMS.length - 1, selectedIndex + 1);\n    }\n    if (isUp || isDown) {\n        soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_MENU_FOCUS_ID);\n    }\n    return Object.assign(Object.assign({}, state), { selectedIndex });\n}\nfunction startPlaying({ state, soundController, }) {\n    soundController.stopAll();\n    soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_MENU_SELECT_ID);\n    soundController.play('car');\n    // Delay the sound cause it's better like that\n    setTimeout(() => {\n        if (!soundController.isPlaying(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_MENU_THEME_ID)) {\n            soundController.playLoop(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_GAME_THEME_ID);\n        }\n    }, 1500);\n    return Object.assign(Object.assign({}, state), { isOpen: false, isPlaying: true });\n}\nfunction returnToPlaying({ state, soundController, }) {\n    soundController.stop(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_MENU_THEME_ID);\n    soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_MENU_SELECT_ID);\n    soundController.play('car');\n    soundController.resumeAll();\n    if (!soundController.canResume(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_GAME_THEME_ID)) {\n        soundController.playLoopIfNotPlaying(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_GAME_THEME_ID);\n    }\n    return Object.assign(Object.assign({}, state), { isOpen: false, isPlaying: true });\n}\nfunction updateGameOverState({ keyboardListener, soundController, resetGlobalState, state, }) {\n    let selectedIndex = state.selectedIndex;\n    const isSelect = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Select);\n    const isUp = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Up);\n    const isDown = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Down);\n    if (isSelect) {\n        // Try again\n        if (selectedIndex === 0) {\n            soundController.stopAll();\n            soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_MENU_SELECT_ID);\n            const newMenuState = Object.assign(Object.assign({}, startPlaying({ state: defaultMenuState, soundController })), { isAnyKey: false });\n            resetGlobalState({\n                gotReset: true,\n                menuState: newMenuState,\n            });\n            return newMenuState;\n        }\n        // Main menu\n        if (selectedIndex === 1) {\n            const newMenuState = Object.assign(Object.assign({}, defaultMenuState), { isAnyKey: false });\n            soundController.stopAll();\n            soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_MENU_SELECT_ID);\n            resetGlobalState({\n                gotReset: true,\n                menuState: newMenuState,\n            });\n            return newMenuState;\n        }\n        return state;\n    }\n    if (isUp) {\n        selectedIndex = Math.max(0, selectedIndex - 1);\n    }\n    else if (isDown) {\n        selectedIndex = Math.min(GAME_OVER_ITEMS.length - 1, selectedIndex + 1);\n    }\n    if (isUp || isDown) {\n        soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_MENU_FOCUS_ID);\n    }\n    return Object.assign(Object.assign({}, state), { selectedIndex });\n}\nfunction updateWinState({ keyboardListener, soundController, resetGlobalState, state, }) {\n    let selectedIndex = state.selectedIndex;\n    const isSelect = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Select);\n    const isUp = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Up);\n    const isDown = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Down);\n    if (isSelect) {\n        // Credits\n        if (selectedIndex === 0) {\n            const newMenuState = Object.assign(Object.assign({}, defaultMenuState), { isAnyKey: false, isCredits: true, selectedIndex: 2 });\n            soundController.stopAll();\n            soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_MENU_SELECT_ID);\n            resetGlobalState({\n                gotReset: true,\n                menuState: newMenuState,\n            });\n            return newMenuState;\n        }\n        // Main menu\n        if (selectedIndex === 1) {\n            const newMenuState = Object.assign(Object.assign({}, defaultMenuState), { isAnyKey: false });\n            soundController.stopAll();\n            soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_MENU_SELECT_ID);\n            resetGlobalState({\n                gotReset: true,\n                menuState: newMenuState,\n            });\n            return newMenuState;\n        }\n        return state;\n    }\n    if (isUp) {\n        selectedIndex = Math.max(0, selectedIndex - 1);\n    }\n    else if (isDown) {\n        selectedIndex = Math.min(GAME_OVER_ITEMS.length - 1, selectedIndex + 1);\n    }\n    if (isUp || isDown) {\n        soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_MENU_FOCUS_ID);\n    }\n    return Object.assign(Object.assign({}, state), { selectedIndex });\n}\nfunction updateCreditsState({ keyboardListener, soundController, resetGlobalState, state, }) {\n    let selectedIndex = state.selectedIndex;\n    const isSelect = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Select);\n    const isUp = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Up);\n    const isDown = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Down);\n    if (isSelect) {\n        if (selectedIndex === 0) {\n            window.open(_config__WEBPACK_IMPORTED_MODULE_0__.GH_LINK);\n            return state;\n        }\n        if (selectedIndex === 1) {\n            window.open(_config__WEBPACK_IMPORTED_MODULE_0__.ITCH_LINK);\n            return state;\n        }\n        // Main menu\n        if (selectedIndex === 2) {\n            soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_MENU_SELECT_ID);\n            return Object.assign(Object.assign({}, state), { isCredits: false, selectedIndex: 0 });\n        }\n    }\n    if (isUp) {\n        selectedIndex = Math.max(0, selectedIndex - 1);\n    }\n    else if (isDown) {\n        selectedIndex = Math.min(CREDITS_ITEMS.length - 1, selectedIndex + 1);\n    }\n    if (isUp || isDown) {\n        soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_MENU_FOCUS_ID);\n    }\n    return Object.assign(Object.assign({}, state), { selectedIndex });\n}\n\n\n//# sourceURL=webpack:///./src/menu.ts?");

/***/ }),

/***/ "./src/path.ts":
/*!*********************!*\
  !*** ./src/path.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getCenterCurve\": () => (/* binding */ getCenterCurve),\n/* harmony export */   \"lerpPath\": () => (/* binding */ lerpPath),\n/* harmony export */   \"steerPath\": () => (/* binding */ steerPath),\n/* harmony export */   \"translatePath\": () => (/* binding */ translatePath)\n/* harmony export */ });\n/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve */ \"./src/curve.ts\");\n\nfunction getCenterCurve(path) {\n    return {\n        topX: path.left.topX + (path.right.topX - path.left.topX) / 2,\n        topY: path.left.topY,\n        controlX: path.left.controlX + (path.right.controlX - path.left.controlX) / 2,\n        controlY: path.left.controlY,\n        bottomX: path.left.bottomX + (path.right.bottomX - path.left.bottomX) / 2,\n        bottomY: path.left.bottomY,\n    };\n}\nfunction steerPath(path, { steerOffset }) {\n    return Object.assign(Object.assign({}, path), { left: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.steerCurve)(path.left, { steerOffset }), right: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.steerCurve)(path.right, { steerOffset }) });\n}\nfunction translatePath(path, { top, bottom, }) {\n    return Object.assign(Object.assign({}, path), { left: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.translateCurve)(path.left, { top: -top, bottom: -bottom }), right: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.translateCurve)(path.right, { top, bottom }) });\n}\nfunction lerpPath(p1, p2, d) {\n    return {\n        left: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.lerpCurve)(p1.left, p2.left, d),\n        right: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.lerpCurve)(p1.right, p2.right, d),\n    };\n}\n\n\n//# sourceURL=webpack:///./src/path.ts?");

/***/ }),

/***/ "./src/pole.ts":
/*!*********************!*\
  !*** ./src/pole.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawPoles\": () => (/* binding */ drawPoles),\n/* harmony export */   \"generatePolesForZones\": () => (/* binding */ generatePolesForZones),\n/* harmony export */   \"getNextPole\": () => (/* binding */ getNextPole)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve */ \"./src/curve.ts\");\n/* harmony import */ var _road__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./road */ \"./src/road.ts\");\n/* harmony import */ var _stripes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stripes */ \"./src/stripes.ts\");\n\n\n\n\nfunction getNextPole({ poles, moveOffset, }) {\n    return poles.find((pole) => {\n        return pole.start > moveOffset && !pole.granted;\n    });\n}\nfunction drawPoles(ctx, { poles, images, deltaTime, path, zone, nextZone, moveOffset, steerOffset, yOverride, }) {\n    let roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.IH - (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    const stripes = (0,_stripes__WEBPACK_IMPORTED_MODULE_3__.generateStripes)({ roadHeight });\n    const travelDistance = (0,_stripes__WEBPACK_IMPORTED_MODULE_3__.stripesUnscaledHeight)(stripes);\n    let preshowSize = 200;\n    let pole;\n    for (let i = poles.length - 1; i >= 0; i--) {\n        const appearStart = poles[i].start - travelDistance;\n        const preshowAppearStart = appearStart - preshowSize;\n        if (moveOffset >= preshowAppearStart) {\n            pole = poles[i];\n            break;\n        }\n    }\n    if (!pole) {\n        return;\n    }\n    const appearStart = pole.start - travelDistance;\n    const isPreshow = moveOffset < appearStart;\n    const curbPath = (0,_road__WEBPACK_IMPORTED_MODULE_2__.getCurbPath)(path, { steerOffset });\n    let inOffset = moveOffset - pole.start + travelDistance;\n    if (isPreshow) {\n        inOffset = 1;\n    }\n    const stripesY = (0,_stripes__WEBPACK_IMPORTED_MODULE_3__.stripesToY)(stripes, { inOffset });\n    if (stripesY === undefined) {\n        return;\n    }\n    const poleY = _config__WEBPACK_IMPORTED_MODULE_0__.IH - stripesY;\n    const poleRightX = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.curveXByY)((0,_curve__WEBPACK_IMPORTED_MODULE_1__.steerCurve)(curbPath.right, { steerOffset }), poleY);\n    const poleLeftX = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.curveXByY)((0,_curve__WEBPACK_IMPORTED_MODULE_1__.steerCurve)(curbPath.left, { steerOffset }), poleY);\n    let inHalfHeightT = stripesY / _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n    let imageScale = Math.max(0, 1 - (1 - 0.1 * _config__WEBPACK_IMPORTED_MODULE_0__.RS) * inHalfHeightT);\n    let imageOpacity = 1;\n    if (poleRightX) {\n        drawPole(ctx, {\n            side: 'right',\n            images,\n            pole,\n            poleX: poleRightX,\n            poleY,\n            imageScale,\n            imageOpacity,\n        });\n    }\n    if (poleLeftX) {\n        drawPole(ctx, {\n            side: 'left',\n            images,\n            pole,\n            poleX: poleLeftX,\n            poleY,\n            imageScale,\n            imageOpacity,\n        });\n    }\n}\nfunction drawPole(ctx, { side, images, pole, poleX, poleY, imageScale, imageOpacity, }) {\n    const image = pole.granted ? images.poleGreen : images.poleRed;\n    const sourceWidth = 64;\n    const sourceHeight = 256;\n    const sourceX = 0;\n    const sourceY = 0;\n    const imageWidth = sourceWidth * imageScale;\n    const imageHeight = sourceHeight * imageScale;\n    const imageX = poleX - imageWidth / 3;\n    const imageY = poleY - imageHeight;\n    ctx.globalAlpha = imageOpacity;\n    ctx.drawImage(image, sourceX, sourceY, sourceWidth, sourceHeight, imageX, imageY, imageWidth, imageHeight);\n    ctx.globalAlpha = 1;\n    const animationEnd = 1;\n    if (!pole.granted) {\n        if (pole.energyFrameTime == null) {\n            pole.energyFrameTime = 0;\n            pole.energyFrameIndex = 0;\n        }\n        else {\n            pole.energyFrameTime += 0.1;\n        }\n        if (pole.energyFrameTime >= animationEnd) {\n            pole.energyFrameTime = 0;\n            pole.energyFrameIndex = pole.energyFrameIndex === 0 ? 1 : 0;\n        }\n        const energyImage = images.poleEnergy;\n        const energyWidth = energyImage.width * imageScale * 1.5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n        const energyHeight = energyImage.height * imageScale;\n        const energyX = side === 'right' ? imageX - energyWidth : imageX + 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n        const energyY = imageY;\n        if (pole.energyFrameIndex === 1) {\n            ctx.globalAlpha = pole.energyFrameTime / animationEnd;\n        }\n        ctx.drawImage(energyImage, energyX, energyY, energyWidth, energyHeight);\n        ctx.globalAlpha = 1;\n    }\n}\nfunction generatePolesForZones({ zones }) {\n    const poles = [];\n    zones.forEach((zone) => {\n        if (!zone.skipPole) {\n            poles.push({\n                start: zone.start,\n            });\n        }\n    });\n    return poles;\n}\n\n\n//# sourceURL=webpack:///./src/pole.ts?");

/***/ }),

/***/ "./src/prop.ts":
/*!*********************!*\
  !*** ./src/prop.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawProps\": () => (/* binding */ drawProps),\n/* harmony export */   \"generateProps\": () => (/* binding */ generateProps),\n/* harmony export */   \"generatePropsForZones\": () => (/* binding */ generatePropsForZones),\n/* harmony export */   \"getPropBoxes\": () => (/* binding */ getPropBoxes)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve */ \"./src/curve.ts\");\n/* harmony import */ var _stripes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stripes */ \"./src/stripes.ts\");\n/* harmony import */ var _random__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./random */ \"./src/random.ts\");\n/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./path */ \"./src/path.ts\");\n\n\n\n\n\nconst DOLPHIN_IN_OFFSET = 5;\nfunction getPropBoxes({ soundController, props, images, path, section, nextSection, moveOffset, steerOffset, yOverride, }) {\n    var _a;\n    let roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.IH - (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    const stripes = (0,_stripes__WEBPACK_IMPORTED_MODULE_2__.generateStripes)({ roadHeight });\n    const roadDepth = (0,_stripes__WEBPACK_IMPORTED_MODULE_2__.stripesUnscaledHeight)(stripes);\n    const propBoxes = [];\n    let preshowSize = 700;\n    if (section.kind === 'uphill' || (nextSection === null || nextSection === void 0 ? void 0 : nextSection.kind) === 'uphill') {\n        preshowSize = 400;\n    }\n    else if (section.kind === 'downhill' || (nextSection === null || nextSection === void 0 ? void 0 : nextSection.kind) === 'downhill') {\n        preshowSize = 0;\n    }\n    for (const prop of props) {\n        const propMoveOffset = (_a = prop.moveOffset) !== null && _a !== void 0 ? _a : 0;\n        const appearStart = prop.start - propMoveOffset - roadDepth;\n        const appearEnd = prop.start - propMoveOffset;\n        const preshowAppearStart = appearStart - preshowSize;\n        if (moveOffset >= preshowAppearStart && moveOffset <= appearEnd) {\n            const isPreshow = moveOffset < appearStart;\n            const centerCurve = (0,_path__WEBPACK_IMPORTED_MODULE_4__.getCenterCurve)(path);\n            let curve = centerCurve;\n            if (prop.position > 0.5) {\n                curve = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.lerpCurve)(centerCurve, path.right, (prop.position - 0.5) * 2);\n            }\n            else if (prop.position < 0.5) {\n                curve = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.lerpCurve)(path.left, centerCurve, prop.position * 2);\n            }\n            const steeredCurve = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.steerCurve)(curve, { steerOffset });\n            let inOffset = moveOffset - prop.start + roadDepth + propMoveOffset;\n            if (isPreshow) {\n                inOffset = 1;\n            }\n            if (prop.moveSpeed > 0) {\n                prop.moveOffset = propMoveOffset - prop.moveSpeed;\n            }\n            if (['beach-dolphin'].includes(prop.kind)) {\n                if (prop.positionSpeed !== 0 && inOffset >= DOLPHIN_IN_OFFSET) {\n                    let minPosition = 0;\n                    let maxPosition = 1;\n                    prop.position += prop.positionSpeed;\n                    if (prop.position < minPosition) {\n                        prop.position = minPosition;\n                        prop.positionSpeed = 0;\n                    }\n                    else if (prop.position > maxPosition) {\n                        prop.position = maxPosition;\n                        prop.positionSpeed = 0;\n                    }\n                }\n            }\n            else {\n                if (prop.positionSpeed !== 0) {\n                    let minPosition = 0;\n                    let maxPosition = 1;\n                    if (['desert-bike'].includes(prop.kind)) {\n                        const drift = 0.2;\n                        minPosition = Math.max(0, prop.initialPosition - drift);\n                        maxPosition = Math.min(1, prop.initialPosition + drift);\n                    }\n                    prop.position += prop.positionSpeed;\n                    if (prop.position < minPosition) {\n                        prop.position = minPosition;\n                        prop.positionSpeed *= -1;\n                    }\n                    else if (prop.position > maxPosition) {\n                        prop.position = maxPosition;\n                        prop.positionSpeed *= -1;\n                    }\n                }\n            }\n            const stripesY = (0,_stripes__WEBPACK_IMPORTED_MODULE_2__.stripesToY)(stripes, { inOffset });\n            if (stripesY === undefined) {\n                continue;\n            }\n            const propY = _config__WEBPACK_IMPORTED_MODULE_0__.IH - stripesY;\n            const propX = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.curveXByY)(steeredCurve, propY);\n            if (propX === undefined) {\n                continue;\n            }\n            let inHalfHeightT = stripesY / _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n            let imageScale = Math.max(0, 1 - (1 - 0.1 * _config__WEBPACK_IMPORTED_MODULE_0__.RS) * inHalfHeightT);\n            let imageOpacity = 1;\n            if (roadHeight > _config__WEBPACK_IMPORTED_MODULE_0__.HH && propY < _config__WEBPACK_IMPORTED_MODULE_0__.HH) {\n                const inOverHeightT = Math.max(0, 1 - (_config__WEBPACK_IMPORTED_MODULE_0__.HH - propY) / (roadHeight - _config__WEBPACK_IMPORTED_MODULE_0__.HH));\n                imageScale = 0.1 * inOverHeightT;\n            }\n            else if (isPreshow) {\n                imageScale *= 1 - (appearStart - moveOffset) / preshowSize;\n                imageOpacity = 1 - (appearStart - moveOffset) / preshowSize;\n            }\n            const image = imageByKind(images, prop.kind);\n            let imageWidth = image.width * imageScale;\n            let imageHeight = image.height * imageScale;\n            let imageX = propX - imageWidth / 2;\n            let imageY = propY - imageHeight;\n            if (prop.kind === 'beach-dolphin-head') {\n                if (inOffset > DOLPHIN_IN_OFFSET) {\n                    continue;\n                }\n                soundController.playIfNotPlaying('dolphin1');\n                if (prop.position === 0) {\n                    imageX = propX - 2.5 * imageWidth;\n                }\n                else {\n                    imageX = propX + 2.5 * imageWidth;\n                }\n            }\n            if (prop.kind === 'beach-dolphin') {\n                if (prop.position >= 1 || prop.position <= 0) {\n                    continue;\n                }\n                if (inOffset < DOLPHIN_IN_OFFSET) {\n                    continue;\n                }\n                const d = prop.position <= 0.5 ? prop.position * 2 : (1 - prop.position) * 2;\n                imageX = propX - imageWidth * (1 - prop.position);\n                if (prop.initialPosition === 1) {\n                    imageX = propX + imageWidth / 2 - imageWidth * (1 - prop.position);\n                }\n                imageY = imageY - 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS * d;\n            }\n            propBoxes.push({\n                prop,\n                curve: steeredCurve,\n                x: imageX,\n                y: imageY,\n                z: roadDepth - inOffset,\n                width: imageWidth,\n                height: imageHeight,\n                depth: 20,\n                opacity: imageOpacity,\n            });\n        }\n    }\n    return propBoxes;\n}\nfunction drawProps(ctx, { lastTime, propBoxes, images, moveOffset, steerOffset, }) {\n    for (const propBox of propBoxes) {\n        const image = imageByKind(images, propBox.prop.kind);\n        let flipped = false;\n        if (['green-bike', 'desert-tumbleweed', 'beach-barrel'].includes(propBox.prop.kind)) {\n            const shouldFlip = Math.round(lastTime / 0.2) % 2 === 1;\n            if (shouldFlip) {\n                ctx.translate(propBox.x + propBox.width / 2, 0);\n                ctx.scale(-1, 1);\n                flipped = true;\n            }\n        }\n        if (['beach-dolphin-head', 'beach-dolphin'].includes(propBox.prop.kind)) {\n            const shouldFlip = propBox.prop.initialPosition === 1;\n            if (shouldFlip) {\n                ctx.translate(propBox.x + propBox.width / 2, 0);\n                ctx.scale(-1, 1);\n                flipped = true;\n            }\n        }\n        let jumped = false;\n        if (['desert-bike'].includes(propBox.prop.kind)) {\n            const shouldJump = Math.round(lastTime / 0.05) % 2 === 1;\n            if (shouldJump) {\n                ctx.translate(0, 1);\n                jumped = true;\n            }\n        }\n        ctx.globalAlpha = propBox.opacity;\n        ctx.drawImage(image, flipped ? 0 : propBox.x, propBox.y, propBox.width, propBox.height);\n        ctx.globalAlpha = 1;\n        if (flipped) {\n            ctx.scale(-1, 1);\n            ctx.translate(-(propBox.x + propBox.width / 2), 0);\n        }\n        if (jumped) {\n            ctx.translate(0, -1);\n        }\n    }\n}\nfunction imageByKind(images, kind) {\n    switch (kind) {\n        case 'green-bike':\n            return images.propGreenBike;\n        case 'green-roadwork':\n            return images.propGreenRoadwork;\n        case 'green-sheep':\n            return images.propGreenSheep;\n        case 'green-car':\n            return images.propGreenCar;\n        case 'green-turtle':\n            return images.propGreenTurtle;\n        case 'desert-tumbleweed':\n            return images.propDesertTumbleweed;\n        case 'desert-bike':\n            return images.propDesertBike;\n        case 'beach-barrel':\n            return images.propBeachBarrel;\n        case 'beach-barrel-stand':\n            return images.propBeachBarrelStand;\n        case 'beach-dolphin':\n            return images.propBeachDolphin;\n        case 'beach-dolphin-head':\n            return images.propBeachDolphinHead;\n        default:\n            throw new Error(`Unsupported decor kind: \"${kind}\"`);\n    }\n}\nconst KINDS_BY_ZONE = new Map();\nKINDS_BY_ZONE.set('green', {\n    kinds: ['green-bike', 'green-roadwork', 'green-turtle'],\n    distributions: [0.5, 0.7, 1],\n    moveSpeeds: [1, 0, 0],\n    positionSpeeds: [0, 0, 0],\n});\nKINDS_BY_ZONE.set('desert', {\n    kinds: ['desert-bike', 'desert-tumbleweed', 'green-sheep'],\n    distributions: [0.5, 0.75, 1],\n    moveSpeeds: [2, 0, 0],\n    positionSpeeds: [0.005, 0.005, 0],\n});\nKINDS_BY_ZONE.set('beach', {\n    kinds: ['beach-barrel', 'beach-barrel-stand', 'beach-dolphin'],\n    distributions: [0.3, 0.8, 1],\n    moveSpeeds: [0, 0, 0],\n    positionSpeeds: [-0.003, 0, 0.005],\n});\nKINDS_BY_ZONE.set('forest', {\n    kinds: [],\n    distributions: [],\n    moveSpeeds: [],\n    positionSpeeds: [],\n});\nfunction generateProps({ startOffset, size, count, zoneKind, }) {\n    const props = [];\n    const { kinds, distributions, moveSpeeds, positionSpeeds } = KINDS_BY_ZONE.get(zoneKind);\n    if (kinds.length === 0) {\n        return props;\n    }\n    console.assert(kinds.length === distributions.length && kinds.length === moveSpeeds.length, 'prop lengths dont match');\n    const areaSize = size / count;\n    // Go reverse to have the farthest props in the array first, which means the\n    // closest will be rendered last, which is better for zindex.\n    for (let i = count - 1; i >= 0; i--) {\n        const areaStart = i * areaSize;\n        const inAreaOffset = (0,_random__WEBPACK_IMPORTED_MODULE_3__.randomNumber)(0, areaSize);\n        const start = startOffset + areaStart + inAreaOffset;\n        const { item: kind, index: kindIndex } = (0,_random__WEBPACK_IMPORTED_MODULE_3__.randomElementDistributed)(kinds, distributions);\n        const moveSpeed = moveSpeeds[kindIndex];\n        let initialPosition = (0,_random__WEBPACK_IMPORTED_MODULE_3__.randomNumber)(10, 90) / 100;\n        let positionSpeed = positionSpeeds[kindIndex];\n        if (kind === 'beach-dolphin') {\n            initialPosition = (0,_random__WEBPACK_IMPORTED_MODULE_3__.randomElement)([0, 1]);\n            positionSpeed = initialPosition === 1 ? -positionSpeed : positionSpeed;\n        }\n        const prop = {\n            start,\n            kind,\n            initialPosition,\n            position: initialPosition,\n            positionSpeed,\n            moveSpeed,\n            moveOffset: 0,\n        };\n        props.push(prop);\n        if (['beach-barrel'].includes(kind)) {\n            props.push(Object.assign(Object.assign({}, prop), { position: 1 - prop.position, positionSpeed: -prop.positionSpeed }));\n        }\n        if (['beach-dolphin'].includes(kind)) {\n            props.push(Object.assign(Object.assign({}, prop), { kind: 'beach-dolphin-head', positionSpeed: 0 }));\n        }\n    }\n    return props;\n}\nfunction generatePropsForZones({ zones }) {\n    const props = [];\n    for (let i = 0; i < zones.length; i++) {\n        const zone = zones[i];\n        const nextZone = zones[i + 1];\n        const startOffset = zone.start + _config__WEBPACK_IMPORTED_MODULE_0__.POLE_START;\n        const size = nextZone ? nextZone.start - startOffset - _config__WEBPACK_IMPORTED_MODULE_0__.POLE_START : 0;\n        console.assert(size >= 0, 'zone size < 0');\n        const zoneProps = generateProps({\n            startOffset,\n            size,\n            count: zone.propCount,\n            zoneKind: zone.kind,\n        });\n        props.push(...zoneProps);\n    }\n    return props;\n}\n\n\n//# sourceURL=webpack:///./src/prop.ts?");

/***/ }),

/***/ "./src/random.ts":
/*!***********************!*\
  !*** ./src/random.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"randomElement\": () => (/* binding */ randomElement),\n/* harmony export */   \"randomElementDistributed\": () => (/* binding */ randomElementDistributed),\n/* harmony export */   \"randomElements\": () => (/* binding */ randomElements),\n/* harmony export */   \"randomNumber\": () => (/* binding */ randomNumber)\n/* harmony export */ });\nfunction randomElement(items) {\n    const index = Math.floor(Math.random() * items.length);\n    return items[index];\n}\nfunction randomElementDistributed(items, distributions) {\n    const number = Math.random();\n    const index = distributions.findIndex((d) => {\n        return d > number;\n    });\n    return { item: items[index], index };\n}\nfunction randomElements(items, count) {\n    const clonedItems = items.slice();\n    const pickedItems = [];\n    for (let i = 0; i < Math.min(items.length, count); i++) {\n        const index = Math.floor(Math.random() * clonedItems.length);\n        pickedItems.push(...clonedItems.splice(index, 1));\n    }\n    return pickedItems;\n}\nfunction randomNumber(from = 0, to = 1) {\n    return Math.floor(Math.random() * (to - from + 1) + from);\n}\n\n\n//# sourceURL=webpack:///./src/random.ts?");

/***/ }),

/***/ "./src/road.ts":
/*!*********************!*\
  !*** ./src/road.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawCurbMask\": () => (/* binding */ drawCurbMask),\n/* harmony export */   \"drawRoadLines\": () => (/* binding */ drawRoadLines),\n/* harmony export */   \"drawRoadMask\": () => (/* binding */ drawRoadMask),\n/* harmony export */   \"getCurbPath\": () => (/* binding */ getCurbPath)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path */ \"./src/path.ts\");\n\n\nfunction drawRoadMask(ctx, path, { steerOffset, color = 'black' }) {\n    const { left, right } = (0,_path__WEBPACK_IMPORTED_MODULE_1__.steerPath)(path, {\n        steerOffset,\n    });\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(left.bottomX, left.bottomY);\n    ctx.quadraticCurveTo(left.controlX, left.controlY, left.topX, left.topY);\n    ctx.lineTo(right.topX, right.topY);\n    ctx.quadraticCurveTo(right.controlX, right.controlY, right.bottomX, right.bottomY);\n    ctx.lineTo(left.bottomX, left.bottomY);\n    ctx.fill();\n}\nfunction getCurbPath(path, { steerOffset }) {\n    return (0,_path__WEBPACK_IMPORTED_MODULE_1__.translatePath)(path, {\n        // TODO: maybe make it wider for uphills\n        top: 1 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        bottom: 50 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n    });\n}\nfunction drawCurbMask(ctx, path, { steerOffset, color = 'black' }) {\n    const steeredPath = (0,_path__WEBPACK_IMPORTED_MODULE_1__.steerPath)(path, {\n        steerOffset,\n    });\n    const { left, right } = getCurbPath(steeredPath, { steerOffset });\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(left.bottomX, left.bottomY);\n    ctx.quadraticCurveTo(left.controlX, left.controlY, left.topX, left.topY);\n    ctx.lineTo(right.topX, right.topY);\n    ctx.quadraticCurveTo(right.controlX, right.controlY, right.bottomX, right.bottomY);\n    ctx.fill();\n}\nfunction drawRoadLines(ctx, path, { moveOffset, steerOffset, color = 'red' }) {\n    ctx.strokeStyle = color;\n    ctx.setLineDash([10]);\n    ctx.lineDashOffset = moveOffset;\n    const { left, right } = (0,_path__WEBPACK_IMPORTED_MODULE_1__.steerPath)(path, {\n        steerOffset,\n    });\n    ctx.beginPath();\n    ctx.moveTo(left.bottomX, left.bottomY);\n    ctx.quadraticCurveTo(left.controlX, left.controlY, left.topX, left.topY);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.moveTo(right.bottomX, right.bottomY);\n    ctx.quadraticCurveTo(right.controlX, right.controlY, right.topX, right.topY);\n    ctx.stroke();\n}\n\n\n//# sourceURL=webpack:///./src/road.ts?");

/***/ }),

/***/ "./src/section.ts":
/*!************************!*\
  !*** ./src/section.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createSectionFragments\": () => (/* binding */ createSectionFragments),\n/* harmony export */   \"getActiveSection\": () => (/* binding */ getActiveSection),\n/* harmony export */   \"getNextSection\": () => (/* binding */ getNextSection)\n/* harmony export */ });\n/* harmony import */ var _fragment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fragment */ \"./src/fragment.ts\");\n\nfunction createSectionFragments({ section, moveOffset, steerOffset, }) {\n    const inSectionOffset = moveOffset - section.start;\n    if (section.kind === 'straight') {\n        return { path: _fragment__WEBPACK_IMPORTED_MODULE_0__.straightFragment };\n    }\n    if (section.kind === 'turn-right' || section.kind === 'turn-left') {\n        const fragments = (0,_fragment__WEBPACK_IMPORTED_MODULE_0__.createTurn)({\n            size: section.size,\n            direction: section.kind === 'turn-right' ? 'right' : 'left',\n            steerOffset,\n        });\n        const path = (0,_fragment__WEBPACK_IMPORTED_MODULE_0__.lerpFragments)({\n            fragments,\n            inOffset: inSectionOffset,\n        });\n        return { path };\n    }\n    if (section.kind === 'downhill') {\n        const fragments = (0,_fragment__WEBPACK_IMPORTED_MODULE_0__.createDownhill)({\n            size: section.size,\n            inOffset: inSectionOffset,\n            steepness: section.steepness,\n            steerOffset,\n        });\n        const path = (0,_fragment__WEBPACK_IMPORTED_MODULE_0__.lerpFragments)({\n            fragments,\n            inOffset: inSectionOffset,\n        });\n        const yOverride = path.left.topY;\n        return { path, yOverride };\n    }\n    if (section.kind === 'uphill') {\n        const fragments = (0,_fragment__WEBPACK_IMPORTED_MODULE_0__.createUphill)({\n            size: section.size,\n            inOffset: inSectionOffset,\n            steepness: section.steepness,\n            steerOffset,\n        });\n        const path = (0,_fragment__WEBPACK_IMPORTED_MODULE_0__.lerpFragments)({\n            fragments,\n            inOffset: inSectionOffset,\n        });\n        const yOverride = path.left.topY;\n        return { path, yOverride };\n    }\n    throw new Error(`Unknown section: \"${section.kind}\"`);\n}\nfunction getActiveSection({ sections, moveOffset, }) {\n    let activeSection = sections.find((s) => {\n        return moveOffset >= s.start && moveOffset <= s.start + s.size;\n    });\n    if (!activeSection || hasSectionEnded(activeSection, moveOffset)) {\n        activeSection = { start: moveOffset, kind: 'straight', size: 0 };\n    }\n    return activeSection;\n}\nfunction getNextSection({ sections, moveOffset, }) {\n    const activeSectionIndex = sections.findIndex((s) => {\n        return moveOffset >= s.start && moveOffset <= s.start + s.size;\n    });\n    if (activeSectionIndex !== -1) {\n        const nextSectionIndex = activeSectionIndex + 1;\n        return sections[nextSectionIndex];\n    }\n    return sections.find((s) => {\n        return s.start > moveOffset;\n    });\n}\nfunction hasSectionEnded(section, moveOffset) {\n    return section.start + section.size < moveOffset;\n}\n\n\n//# sourceURL=webpack:///./src/section.ts?");

/***/ }),

/***/ "./src/sound.ts":
/*!**********************!*\
  !*** ./src/sound.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Sound\": () => (/* binding */ Sound),\n/* harmony export */   \"SoundController\": () => (/* binding */ SoundController),\n/* harmony export */   \"loadSounds\": () => (/* binding */ loadSounds)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction loadSounds() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const sounds = [\n            ['menu1', 'data/audio/menu1.mp3'],\n            ['menu2', 'data/audio/menu2.mp3'],\n            ['menu3', 'data/audio/menu3.mp3'],\n            ['menuSelect1', 'data/audio/menu-select1.mp3', 0.4],\n            ['menuFocus1', 'data/audio/menu-focus1.mp3', 0.4],\n            ['menuFocus2', 'data/audio/menu-focus2.mp3', 0.4],\n            ['theme1', 'data/audio/theme1.mp3'],\n            ['lost1', 'data/audio/lost1.mp3'],\n            ['upgradePicked1', 'data/audio/upgrade-picked1.mp3'],\n            ['curb1', 'data/audio/curb1.mp3'],\n            ['curb2', 'data/audio/curb2.mp3', 0.5],\n            ['curb3', 'data/audio/curb3.mp3'],\n            ['curb4', 'data/audio/curb4.mp3'],\n            ['hit1', 'data/audio/hit1.mp3'],\n            ['hit2', 'data/audio/hit2.mp3'],\n            ['death1', 'data/audio/death1.mp3'],\n            ['dolphin1', 'data/audio/dolphin1.mp3'],\n            ['life1', 'data/audio/life1.mp3'],\n            ['brake1', 'data/audio/brake1.mp3'],\n            ['brake2', 'data/audio/brake2.mp3'],\n            ['brake3', 'data/audio/brake3.mp3'],\n            ['bumper1', 'data/audio/bumper1.mp3'],\n            ['ufo1', 'data/audio/ufo1.mp3'],\n            ['ufo2', 'data/audio/ufo2.mp3', 0.5],\n            ['ufo3', 'data/audio/ufo3.mp3'],\n            ['ufo4', 'data/audio/ufo4.mp3', 0.6],\n            ['win1', 'data/audio/win1.mp3'],\n            ['win2', 'data/audio/win2.mp3'],\n        ];\n        const promises = sounds.map(([id, path, baseVolume]) => __awaiter(this, void 0, void 0, function* () {\n            return { id, sound: yield loadSound(path, baseVolume) };\n        }));\n        const results = yield Promise.all(promises);\n        const map = {};\n        results.forEach(({ id, sound }) => {\n            map[id] = sound;\n        });\n        return map;\n    });\n}\nfunction loadSound(audioPath, baseVolume = 1) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve) => {\n            const audioElement = new Audio();\n            const sound = new Sound(audioElement, baseVolume);\n            audioElement.src = audioPath;\n            audioElement.addEventListener('loadeddata', () => {\n                resolve(sound);\n            });\n        });\n    });\n}\nclass SoundController {\n    constructor(audioCtx) {\n        this.audioCtx = audioCtx;\n        this.sounds = {};\n        this.globalMuted = false;\n    }\n    play(name) {\n        if (name === 'car') {\n            this.audioCtx.resume();\n            return;\n        }\n        this.sounds[name].play();\n    }\n    playLoop(name) {\n        this.sounds[name].playLoop();\n    }\n    playIfNotPlaying(name) {\n        this.sounds[name].playIfNotPlaying();\n    }\n    playLoopIfNotPlaying(name) {\n        this.sounds[name].playLoopIfNotPlaying();\n    }\n    isPlaying(name) {\n        return this.sounds[name].isPlaying();\n    }\n    canResume(name) {\n        return this.sounds[name].canResume();\n    }\n    resumeAll() {\n        Object.keys(this.sounds).forEach((name) => {\n            const sound = this.sounds[name];\n            if (sound.canResume()) {\n                sound.resume();\n            }\n        });\n        this.audioCtx.resume();\n    }\n    pauseAll() {\n        Object.keys(this.sounds).forEach((name) => {\n            this.sounds[name].pause();\n        });\n        this.audioCtx.suspend();\n    }\n    stop(name) {\n        if (name === 'car') {\n            this.audioCtx.suspend();\n            return;\n        }\n        this.sounds[name].stop();\n    }\n    stopAll() {\n        Object.keys(this.sounds).forEach((name) => {\n            this.sounds[name].stop();\n        });\n        this.audioCtx.suspend();\n    }\n    setGlobalMuted(isGlobalMuted) {\n        this.globalMuted = isGlobalMuted;\n        Object.keys(this.sounds).forEach((name) => {\n            this.sounds[name].setGlobalMuted(isGlobalMuted);\n        });\n    }\n}\nclass Sound {\n    constructor(audioElement, baseVolume = 1) {\n        this.audioElement = audioElement;\n        this.baseVolume = baseVolume;\n        this.localMuted = false;\n        this.globalMuted = false;\n        this.audioElement.volume = baseVolume;\n    }\n    isLoaded() {\n        return this.audioElement.readyState === 4;\n    }\n    play() {\n        this.stop();\n        this.audioElement.loop = false;\n        this.audioElement.play();\n    }\n    playIfNotPlaying() {\n        if (this.isPlaying())\n            return;\n        this.play();\n    }\n    playLoopIfNotPlaying() {\n        if (this.isPlaying())\n            return;\n        this.playLoop();\n    }\n    isPlaying() {\n        return !this.audioElement.paused;\n    }\n    playLoop() {\n        this.stop();\n        this.audioElement.loop = true;\n        this.audioElement.play();\n    }\n    resume() {\n        this.audioElement.play();\n    }\n    pause() {\n        this.audioElement.pause();\n    }\n    stop() {\n        this.audioElement.pause();\n        this.audioElement.currentTime = 0;\n    }\n    canResume() {\n        // TODO: what if 0?\n        return (this.audioElement.paused &&\n            !this.audioElement.ended &&\n            this.audioElement.currentTime > 0);\n    }\n    setMuted(isMuted) {\n        this.localMuted = isMuted;\n        this.updateElementMuted();\n    }\n    isMuted() {\n        return this.localMuted;\n    }\n    setGlobalMuted(isGlobalMuted) {\n        this.globalMuted = isGlobalMuted;\n        this.updateElementMuted();\n    }\n    isGlobalMuted() {\n        return this.globalMuted;\n    }\n    updateElementMuted() {\n        this.audioElement.muted = this.globalMuted || this.localMuted;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/sound.ts?");

/***/ }),

/***/ "./src/speed.ts":
/*!**********************!*\
  !*** ./src/speed.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SpeedAudio\": () => (/* binding */ SpeedAudio),\n/* harmony export */   \"defaultMoveSpeedState\": () => (/* binding */ defaultMoveSpeedState),\n/* harmony export */   \"drawSpeedometer\": () => (/* binding */ drawSpeedometer),\n/* harmony export */   \"updateMoveSpeedState\": () => (/* binding */ updateMoveSpeedState)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\nconst defaultMoveSpeedState = {\n    moveGear: getGearMin(),\n    moveSpeedChange: 0,\n    moveSpeed: 0,\n};\nfunction getMoveGears({ upgrades }) {\n    const hasUpgrade = upgrades.some((u) => u.kind === 'lower-max-speed');\n    const speedMax = hasUpgrade ? _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_SPEED_MAX_UPGRADE : _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_SPEED_MAX;\n    return {\n        1: { delim: 4, startAt: 0, endAt: 1.1 },\n        2: { delim: 5, startAt: 1, endAt: 2.6 },\n        3: { delim: 6, startAt: 2.5, endAt: 4.1 },\n        4: { delim: 7, startAt: 4, endAt: 6.1 },\n        5: { delim: 8, startAt: 6, endAt: speedMax },\n    };\n}\nfunction getGearMin() {\n    return 1;\n}\nfunction getGearMax() {\n    return 5;\n}\nfunction updateMoveSpeedState({ section, nextPole, carState, endingState, upgrades, moveOffset, isThrottleActive, isReverseActive, moveGear: currentMoveGear, moveSpeedChange: currentMoveSpeedChange, moveSpeed: currentMoveSpeed, }) {\n    // Story mode - forced acceleration, no brakes\n    // const isThrottle = isThrottleActive;\n    // const isReverse = isReverseActive;\n    const isThrottle = true;\n    const isReverse = false;\n    let gear = currentMoveGear;\n    let speedChange = currentMoveSpeedChange;\n    let speed = currentMoveSpeed;\n    const gearDesc = getMoveGears({ upgrades })[gear];\n    if (carState.flipTimePassed > 0) {\n        speedChange = (speedChange - _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_DECELERATION_REVERSE) / gearDesc.delim;\n        speed = Math.max(0, speed + speedChange);\n        return {\n            moveGear: gear,\n            moveSpeedChange: speedChange,\n            moveSpeed: speed,\n        };\n    }\n    if (nextPole) {\n        const toPole = nextPole.start - moveOffset;\n        if (toPole < _config__WEBPACK_IMPORTED_MODULE_0__.POLE_START) {\n            speedChange = (speedChange - _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_DECELERATION_FREE) / gearDesc.delim;\n            speed = Math.max(3, speed + speedChange);\n            if (toPole < _config__WEBPACK_IMPORTED_MODULE_0__.POLE_DRIVE) {\n                speedChange = 0;\n                speed = 1.5;\n            }\n            if (toPole < _config__WEBPACK_IMPORTED_MODULE_0__.POLE_FULL_STOP) {\n                speedChange = -100;\n                speed = Math.max(0, speed + speedChange);\n                setTimeout(() => {\n                    nextPole.arrived = true;\n                }, 100);\n            }\n            return {\n                moveGear: gear,\n                moveSpeedChange: speedChange,\n                moveSpeed: speed,\n            };\n        }\n    }\n    if (isThrottle) {\n        if (speedChange < 0) {\n            speedChange = 0;\n        }\n        const parachuteUpgrade = upgrades.find((u) => u.kind === 'parachute');\n        const bumperUpgrade = upgrades.find((u) => u.kind === 'bumper');\n        const nitroUpgrade = upgrades.find((u) => u.kind === 'anti-nitro');\n        const uphillSlowUpgrade = upgrades.find((u) => u.kind === 'turn-uphill-slow');\n        const hasUphillOrTurnSection = [\n            'turn-left',\n            'turn-right',\n            'uphill',\n        ].includes(section.kind);\n        if (bumperUpgrade && bumperUpgrade.usagePassed != null) {\n            speedChange =\n                (speedChange - _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_DECELERATION_BUMPER_UPGRADE) / gearDesc.delim;\n            speed = Math.max(2, speed + speedChange);\n        }\n        else if (parachuteUpgrade && parachuteUpgrade.usagePassed != null) {\n            speedChange =\n                (speedChange - _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_DECELERATION_PARACHUTE_UPGRADE) / gearDesc.delim;\n            speed = Math.max(0, speed + speedChange);\n        }\n        else if (nitroUpgrade && nitroUpgrade.usagePassed != null) {\n            speedChange =\n                (speedChange - _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_DECELERATION_NITRO_UPGRADE) / gearDesc.delim;\n            speed = Math.max(0, speed + speedChange);\n        }\n        else if (uphillSlowUpgrade && hasUphillOrTurnSection) {\n            // Slows down and drops to certain speed with an upgrade\n            speedChange =\n                (speedChange - _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_DECELERATION_UPHILL_UPGRADE) / gearDesc.delim;\n            speed = Math.max(3, speed + speedChange);\n        }\n        else {\n            // Default acceleration\n            speedChange = (speedChange + _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_ACCELERATION) / gearDesc.delim;\n            speed = Math.max(0, speed + speedChange);\n        }\n    }\n    else {\n        if (speed > 0) {\n            if (isReverse) {\n                speedChange =\n                    (speedChange - _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_DECELERATION_REVERSE) / gearDesc.delim;\n                speed = Math.max(0, speed + speedChange);\n            }\n            else {\n                speedChange = (speedChange - _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_DECELERATION_FREE) / gearDesc.delim;\n                speed = Math.max(0, speed + speedChange);\n            }\n        }\n    }\n    if (speed > gearDesc.endAt) {\n        gear = Math.min(gear + 1, getGearMax());\n    }\n    else if (speed < gearDesc.startAt) {\n        gear = Math.max(gear - 1, getGearMin());\n    }\n    speed = Math.min(speed, gearDesc.endAt);\n    return {\n        moveGear: gear,\n        moveSpeedChange: speedChange,\n        moveSpeed: speed,\n    };\n}\nfunction drawSpeedometer(ctx, { state: { moveSpeed, moveGear }, upgrades, }) {\n    const overlayWidth = 100 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const overlayHeight = 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const displaySpeed = Math.floor(moveSpeed * 20)\n        .toString()\n        .padStart(3);\n    const textX = _config__WEBPACK_IMPORTED_MODULE_0__.IW - 75 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const textY = 25 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    ctx.lineWidth = 1;\n    ctx.font = `${20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS}px ${_config__WEBPACK_IMPORTED_MODULE_0__.FONT_PRIMARY}`;\n    ctx.fillStyle = '#444';\n    ctx.strokeStyle = '#000';\n    ctx.fillText(displaySpeed, textX, textY, 55);\n    ctx.lineWidth = 1;\n    ctx.strokeText(displaySpeed, textX, textY, 55);\n    ctx.lineWidth = 1;\n    ctx.font = `${10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS}px ${_config__WEBPACK_IMPORTED_MODULE_0__.FONT_PRIMARY}`;\n    ctx.fillStyle = '#333';\n    ctx.fillText('mph', textX + 40 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, textY - 4 * _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n    const gear = getMoveGears({ upgrades })[moveGear];\n    const gearT = (moveSpeed - gear.startAt) / (gear.endAt - gear.startAt);\n    const barsCount = 16;\n    const barWidth = 5;\n    const barsFilled = Math.round(barsCount * gearT);\n    for (let i = 0; i < barsCount; i++) {\n        const baseX = _config__WEBPACK_IMPORTED_MODULE_0__.IW - 74 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n        const x = baseX + i * 4 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n        const y = 32 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n        const width = 2 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n        const height = 6 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n        ctx.fillStyle = '#444';\n        ctx.strokeStyle = '#333';\n        if (i < barsFilled) {\n            ctx.fillRect(x, y, width, height);\n        }\n        ctx.strokeRect(x, y, width, height);\n    }\n}\nclass SpeedAudio {\n    constructor(audioCtx) {\n        this.isMuted = true;\n        this.osc = audioCtx.createOscillator();\n        this.osc.type = 'triangle';\n        // const biquadFilter = audioCtx.createBiquadFilter();\n        this.gain = audioCtx.createGain();\n        this.gain.gain.value = 0.3;\n        this.osc.start();\n        this.osc\n            // .connect(biquadFilter)\n            .connect(this.gain)\n            .connect(audioCtx.destination);\n    }\n    update({ menuState, upgrades, moveSpeed, moveSpeedChange, moveGear, }) {\n        this.gain.gain.value = menuState.isSoundOn ? 0.3 : 0;\n        const gear = getMoveGears({ upgrades })[moveGear];\n        const gearT = (moveSpeed - gear.startAt) / (gear.endAt - gear.startAt);\n        let soundStart = 30 + moveGear * 10;\n        let soundEnd = soundStart + moveGear * 15;\n        if (moveSpeedChange < 0) {\n            soundEnd = soundStart + moveGear * 8;\n        }\n        const soundValue = soundStart + (soundEnd - soundStart) * gearT;\n        // this.osc.detune.value = 50;\n        this.osc.frequency.value = soundValue;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/speed.ts?");

/***/ }),

/***/ "./src/state.ts":
/*!**********************!*\
  !*** ./src/state.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createGlobalState\": () => (/* binding */ createGlobalState),\n/* harmony export */   \"createResetGlobalState\": () => (/* binding */ createResetGlobalState)\n/* harmony export */ });\n/* harmony import */ var _car__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./car */ \"./src/car.ts\");\n/* harmony import */ var _ending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ending */ \"./src/ending.ts\");\n/* harmony import */ var _menu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./menu */ \"./src/menu.ts\");\n/* harmony import */ var _speed__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./speed */ \"./src/speed.ts\");\n/* harmony import */ var _steer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./steer */ \"./src/steer.ts\");\n/* harmony import */ var _upgrade__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./upgrade */ \"./src/upgrade.ts\");\n\n\n\n\n\n\nconst defaultGlobalState = {\n    gotReset: false,\n    speedState: _speed__WEBPACK_IMPORTED_MODULE_3__.defaultMoveSpeedState,\n    steerState: _steer__WEBPACK_IMPORTED_MODULE_4__.defaultSteerState,\n    upgradeState: _upgrade__WEBPACK_IMPORTED_MODULE_5__.defaultUpgradeState,\n    carState: _car__WEBPACK_IMPORTED_MODULE_0__.defaultCarState,\n    menuState: _menu__WEBPACK_IMPORTED_MODULE_2__.defaultMenuState,\n    endingState: _ending__WEBPACK_IMPORTED_MODULE_1__.defaultEndingState,\n    moveOffset: 0,\n    moveOffsetChange: 0,\n    bgOffset: 0,\n};\nfunction createGlobalState() {\n    return JSON.parse(JSON.stringify(defaultGlobalState));\n}\nfunction createResetGlobalState(state, onReset) {\n    return (override = {}) => {\n        Object.assign(state, Object.assign(Object.assign({}, createGlobalState()), override));\n        onReset();\n    };\n}\n\n\n//# sourceURL=webpack:///./src/state.ts?");

/***/ }),

/***/ "./src/steer.ts":
/*!**********************!*\
  !*** ./src/steer.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultSteerState\": () => (/* binding */ defaultSteerState),\n/* harmony export */   \"updateSteerState\": () => (/* binding */ updateSteerState)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\nconst defaultSteerState = {\n    steerOffset: 0,\n    steerSpeed: 0,\n};\nconst STEER_REDUCE_TILL_SPEED = 3;\nfunction updateSteerState({ steerOffset: currentSteerOffset, steerSpeed: currentSteerSpeed, section, upgrades, nextPole, carState, endingState, isLeftTurnActive, isRightTurnActive, moveSpeed, moveOffset, }) {\n    let steerOffset = currentSteerOffset;\n    let steerSpeed = currentSteerSpeed;\n    if (carState.flipTimePassed > 0) {\n        return {\n            steerSpeed,\n            steerOffset,\n        };\n    }\n    if (endingState.isInitiated) {\n        let speed = 2;\n        if (steerOffset > 0) {\n            steerSpeed = -speed;\n            steerOffset = Math.max(0, steerOffset + steerSpeed);\n        }\n        if (steerOffset < 0) {\n            steerSpeed = speed;\n            steerOffset = Math.min(0, steerOffset + speed);\n        }\n        if (steerOffset === 0) {\n            endingState.isSteerDone = true;\n        }\n        return {\n            steerSpeed,\n            steerOffset,\n        };\n    }\n    if (nextPole) {\n        const toPole = nextPole.start - moveOffset;\n        if (toPole < _config__WEBPACK_IMPORTED_MODULE_0__.POLE_START) {\n            let speed = 2;\n            if (toPole < _config__WEBPACK_IMPORTED_MODULE_0__.POLE_DRIVE) {\n                speed = 5;\n            }\n            if (toPole < _config__WEBPACK_IMPORTED_MODULE_0__.POLE_FULL_STOP) {\n                speed = 100;\n            }\n            if (steerOffset > 0) {\n                steerSpeed = -speed;\n                steerOffset = Math.max(0, steerOffset + steerSpeed);\n            }\n            if (steerOffset < 0) {\n                steerSpeed = speed;\n                steerOffset = Math.min(0, steerOffset + speed);\n            }\n            return {\n                steerSpeed,\n                steerOffset,\n            };\n        }\n    }\n    if (moveSpeed >= 0) {\n        let t = 1;\n        if (moveSpeed < STEER_REDUCE_TILL_SPEED) {\n            t = moveSpeed / STEER_REDUCE_TILL_SPEED;\n        }\n        let baseSteerSpeed = _config__WEBPACK_IMPORTED_MODULE_0__.STEER_SPEED;\n        if (upgrades.some((u) => u.kind === 'improved-steering')) {\n            baseSteerSpeed = _config__WEBPACK_IMPORTED_MODULE_0__.STEER_SPEED_IMPROVED;\n        }\n        const steerSpeed = baseSteerSpeed * t;\n        if (isLeftTurnActive) {\n            steerOffset = Math.min(_config__WEBPACK_IMPORTED_MODULE_0__.STEER_LIMIT, steerOffset + steerSpeed);\n        }\n        else if (isRightTurnActive) {\n            steerOffset = Math.max(-_config__WEBPACK_IMPORTED_MODULE_0__.STEER_LIMIT, steerOffset - steerSpeed);\n        }\n    }\n    else {\n        steerSpeed = 0;\n    }\n    // The faster the car is going - turn will generate more counter-force\n    const turnCounterForce = _config__WEBPACK_IMPORTED_MODULE_0__.STEER_TURN_COUNTER_FORCE * (moveSpeed / _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_SPEED_MAX);\n    if (section.kind === 'turn-left') {\n        steerOffset -= turnCounterForce;\n    }\n    else if (section.kind === 'turn-right') {\n        steerOffset += turnCounterForce;\n    }\n    return {\n        steerSpeed,\n        steerOffset,\n    };\n}\n\n\n//# sourceURL=webpack:///./src/steer.ts?");

/***/ }),

/***/ "./src/stripes.ts":
/*!************************!*\
  !*** ./src/stripes.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawCurbStripes\": () => (/* binding */ drawCurbStripes),\n/* harmony export */   \"drawGroundStripes\": () => (/* binding */ drawGroundStripes),\n/* harmony export */   \"drawRoadStripes\": () => (/* binding */ drawRoadStripes),\n/* harmony export */   \"generateStripes\": () => (/* binding */ generateStripes),\n/* harmony export */   \"stripesToY\": () => (/* binding */ stripesToY),\n/* harmony export */   \"stripesUnscaledHeight\": () => (/* binding */ stripesUnscaledHeight)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\nconst NEAR_TEXTURE_HEIGHT = 32 * _config__WEBPACK_IMPORTED_MODULE_0__.RENDER_SCALE;\nconst GROUND_COLORS = new Map();\nGROUND_COLORS.set('green', ['#889827', '#9aa545']);\nGROUND_COLORS.set('desert', ['#b7b467', '#c9c67c']);\nGROUND_COLORS.set('forest', ['#0c405e', '#1e4f6b']);\nGROUND_COLORS.set('beach', ['#579eb7', '#579eb7']);\nfunction drawGroundStripes(ctx, opts) {\n    const colors = GROUND_COLORS.get(opts.zone.kind);\n    drawStripes(ctx, Object.assign(Object.assign({}, opts), { colorMap: GROUND_COLORS }));\n}\nconst ROAD_COLORS = new Map();\nROAD_COLORS.set('green', ['#69696a', '#444446']);\nROAD_COLORS.set('desert', ['#9d7634', '#8b6b36']);\nROAD_COLORS.set('forest', ['#497d7a', '#2f706c']);\nROAD_COLORS.set('beach', ['#36291a', '#4c3821']);\nfunction drawRoadStripes(ctx, opts) {\n    const colors = ROAD_COLORS.get(opts.zone.kind);\n    drawStripes(ctx, Object.assign(Object.assign({}, opts), { colorMap: ROAD_COLORS }));\n}\nconst CURB_COLORS = new Map();\nCURB_COLORS.set('green', ['#c5bfbf', '#dc3961']);\nCURB_COLORS.set('desert', ['#c57f4c', '#a15541']);\nCURB_COLORS.set('forest', ['#867794', '#64497d']);\nCURB_COLORS.set('beach', ['#626262', '#626262']);\n// TODO: make them appear more often?? but keep stripes match with bigger ones\nfunction drawCurbStripes(ctx, opts) {\n    drawStripes(ctx, Object.assign(Object.assign({}, opts), { colorMap: CURB_COLORS }));\n}\nfunction drawStripes(ctx, { colorMap, zone, nextZone, moveOffset, yOverride, }) {\n    const colors = colorMap.get(zone.kind);\n    const nextColors = colorMap.get(nextZone.kind);\n    const roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.IH - (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    // const roadHeight = HH;\n    const nextZoneIn = nextZone.start - moveOffset;\n    const stripes = generateStripes({ roadHeight });\n    const texturedStripes = textureSplitStripes(stripes, { moveOffset });\n    const roadDepth = stripesUnscaledHeight(stripes);\n    if (nextZoneIn > 0 && nextZoneIn < roadDepth) {\n        const inOffset = roadDepth - nextZoneIn;\n        const divideY = stripesToY(stripes, { inOffset });\n        const closestStripe = texturedStripes.find((stripe, i) => {\n            var _a;\n            return (stripe.y2 >= divideY &&\n                stripe.textureIndex === 0 &&\n                ((_a = texturedStripes[i + 1]) === null || _a === void 0 ? void 0 : _a.textureIndex) !== 0);\n        });\n        for (let i = 0; i < texturedStripes.length; i++) {\n            const stripe = texturedStripes[i];\n            const nextStripe = texturedStripes[i + 1];\n            let usedColors = colors;\n            if (stripe.stripeIndex >= (closestStripe === null || closestStripe === void 0 ? void 0 : closestStripe.stripeIndex)) {\n                usedColors = nextColors;\n            }\n            if (stripe.stripeIndex + 1 === (closestStripe === null || closestStripe === void 0 ? void 0 : closestStripe.stripeIndex) &&\n                stripe.textureIndex === (nextStripe === null || nextStripe === void 0 ? void 0 : nextStripe.textureIndex) &&\n                stripe.textureIndex === 0) {\n                usedColors = nextColors;\n            }\n            ctx.fillStyle = usedColors[stripe.textureIndex];\n            ctx.fillRect(0, _config__WEBPACK_IMPORTED_MODULE_0__.IH - stripe.y2, _config__WEBPACK_IMPORTED_MODULE_0__.IW, stripe.height);\n        }\n    }\n    else {\n        for (const stripe of texturedStripes) {\n            ctx.fillStyle = colors[stripe.textureIndex];\n            ctx.fillRect(0, _config__WEBPACK_IMPORTED_MODULE_0__.IH - stripe.y2, _config__WEBPACK_IMPORTED_MODULE_0__.IW, stripe.height);\n        }\n    }\n}\nfunction stripesUnscaledHeight(stripes) {\n    const nearTextureHeight = stripes[0].height;\n    return stripes.length * nearTextureHeight;\n}\nfunction stripesToY(stripes, { inOffset }) {\n    // First stripe travels 1 to 1 with the move offset -> 32 to 32.\n    // Let's say second stripe is smaller in size by 2 (32 / 2 = 16), which means\n    // that if inOffset travels +32, then this stripe will travel +16,\n    // or if inOffset travels +16, then this stripe will travel +8.\n    // Find a stripe we are in first using inOffset. Then figure out how much\n    // into a stripe we have travelled and return it as an y position.\n    const nearTextureHeight = stripes[0].height;\n    const roadHeight = stripes[stripes.length - 1].y2;\n    let unscaledOffset = 0;\n    let scaledY = 0;\n    const unscaledHeight = stripes.length * nearTextureHeight;\n    const unscaledIn = unscaledHeight - inOffset;\n    const unscaledT = unscaledIn / nearTextureHeight;\n    const stripeIndex = Math.floor(unscaledT);\n    const inStripeT = unscaledT % 1;\n    if (stripeIndex < 0) {\n        const firstStripe = stripes[0];\n        return undefined;\n        // return firstStripe.y2;\n    }\n    if (stripeIndex > stripes.length - 1) {\n        const lastStripe = stripes[stripes.length - 1];\n        return undefined;\n        // return lastStripe.y2;\n    }\n    const stripe = stripes[stripeIndex];\n    if (stripe == null) {\n        return undefined;\n    }\n    const y = stripe.y + stripe.height * inStripeT;\n    return y;\n}\nfunction generateStripes({ roadHeight, nearTextureHeight = NEAR_TEXTURE_HEIGHT, }) {\n    const stripes = [];\n    // Will be used in a function to calculate how much the next road stripe will\n    // be downscaled compared to the previous one because next stripe is further\n    // into the road.\n    let downscaleIndex = 1;\n    let stripeIndex = 0;\n    let currentY = 0;\n    let roadLeftToParse = roadHeight;\n    while (roadLeftToParse >= 0) {\n        const y = currentY;\n        if (y >= roadHeight) {\n            break;\n        }\n        const downscaleMultiplier = 1 / downscaleIndex;\n        const stripeHeight = Math.ceil(downscaleMultiplier * nearTextureHeight);\n        let y2 = y + stripeHeight;\n        let height = stripeHeight;\n        if (y2 > roadHeight) {\n            y2 = roadHeight;\n            height = Math.round(y2 - y);\n        }\n        if (height > 0) {\n            stripes.push({\n                y,\n                y2,\n                height,\n                stripeIndex,\n            });\n        }\n        roadLeftToParse -= stripeHeight;\n        currentY += stripeHeight;\n        downscaleIndex++;\n        stripeIndex++;\n    }\n    return stripes;\n}\n// TODO: allow custom texture count, not just two, to split the curb\nfunction textureSplitStripes(stripes, { moveOffset, }) {\n    const splitStripes = [];\n    if (stripes.length === 0) {\n        return splitStripes;\n    }\n    const isNegativeMoveOffset = moveOffset < 0;\n    const nearTextureHeight = stripes[0].height;\n    // Based on the nearest stripe and global offset calculate how much this\n    // nearest stripe is offset from zero position. We are going to offset\n    // all of the following stripes based on the same percentages.\n    let restFillPercent = Math.abs(moveOffset % nearTextureHeight) / nearTextureHeight;\n    let primFillPercent = 1 - restFillPercent;\n    // If we are going below zero swap the percentages because the other texture\n    // will be rendered first\n    if (isNegativeMoveOffset) {\n        primFillPercent = 1 - primFillPercent;\n        restFillPercent = 1 - restFillPercent;\n    }\n    // Figure out which texture is rendered first in the current loop based on the\n    // global offset\n    let primTextureIndex = Math.floor(Math.abs(moveOffset) / nearTextureHeight) % 2;\n    // If we are going negative choose the other texture\n    if (isNegativeMoveOffset) {\n        primTextureIndex = 1 - primTextureIndex;\n    }\n    let stripeIndex = 0;\n    for (const stripe of stripes) {\n        // Stripe is split into two sub-stripes based on the global offset.\n        // Each stripe has it's own texture.\n        const primTextureHeight = Math.round(stripe.height * primFillPercent);\n        const restTextureHeight = stripe.height - primTextureHeight;\n        // Add both sub-stripes as separate entries of their own height with\n        // corresponding texture indexes\n        if (primTextureHeight !== 0) {\n            splitStripes.push(Object.assign(Object.assign({}, stripe), { height: primTextureHeight, y2: stripe.y + primTextureHeight, textureIndex: primTextureIndex, stripeIndex }));\n        }\n        if (restTextureHeight !== 0) {\n            splitStripes.push(Object.assign(Object.assign({}, stripe), { height: restTextureHeight, y: stripe.y2 - restTextureHeight, textureIndex: 1 - primTextureIndex, stripeIndex }));\n        }\n        // Alernate to the other texture and make it primary\n        primTextureIndex = 1 - primTextureIndex;\n        stripeIndex++;\n    }\n    return splitStripes;\n}\n\n\n//# sourceURL=webpack:///./src/stripes.ts?");

/***/ }),

/***/ "./src/upgrade.ts":
/*!************************!*\
  !*** ./src/upgrade.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ALL_UPGRADES\": () => (/* binding */ ALL_UPGRADES),\n/* harmony export */   \"defaultUpgradeState\": () => (/* binding */ defaultUpgradeState),\n/* harmony export */   \"drawActiveUpgrades\": () => (/* binding */ drawActiveUpgrades),\n/* harmony export */   \"drawUpgradeDialog\": () => (/* binding */ drawUpgradeDialog),\n/* harmony export */   \"updateUpgradeState\": () => (/* binding */ updateUpgradeState)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _controls__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./controls */ \"./src/controls.ts\");\n/* harmony import */ var _random__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./random */ \"./src/random.ts\");\n\n\n\nconst ALL_UPGRADES = [\n    {\n        kind: 'improved-steering',\n        description: 'Improved handling',\n        active: false,\n    },\n    {\n        kind: 'lower-max-speed',\n        description: 'Reduces max speed',\n        active: false,\n    },\n    {\n        kind: 'bumper',\n        description: 'Slows by bumping into obstacles',\n        description2: 'Cooldown: 15 sec',\n        active: false,\n        cooldown: 15,\n        cooldownPassed: null,\n        usageDuration: 2,\n        usagePassed: null,\n    },\n    {\n        kind: 'lives',\n        description: 'Protects from an obstacle hit ',\n        description2: 'Lives: 3',\n        active: false,\n        count: 3,\n    },\n    {\n        kind: 'parachute',\n        description: 'Decelerates on use',\n        description2: 'Cooldown: 20 sec',\n        active: true,\n        cooldown: 20,\n        cooldownPassed: null,\n        usageDuration: 2,\n        usagePassed: null,\n    },\n    {\n        kind: 'anti-nitro',\n        description: 'Backwards nitro',\n        description2: 'Cooldown: 8 sec',\n        active: true,\n        cooldown: 8,\n        cooldownPassed: null,\n        usageDuration: 1,\n        usagePassed: null,\n    },\n    {\n        kind: 'turn-uphill-slow',\n        description: 'Slows down on turns and uphills',\n        active: false,\n    },\n    {\n        kind: 'curb-duration',\n        description: 'Increases time you can stay on the curb',\n        description2: 'Cooldown: 16',\n        cooldown: 20,\n        cooldownPassed: null,\n        usageDuration: 4,\n        usagePassed: null,\n        active: false,\n    },\n    // other ideas\n    // - rocket launcer\n    // - time stop\n    // - curb reduces speed\n    // - reduce amount of obstacles\n];\nconst defaultUpgradeState = {\n    isDialogOpen: false,\n    dialogSelectedIndex: 0,\n    dialogUpgrades: [],\n    upgrades: [],\n};\nfunction updateUpgradeState({ keyboardListener, soundController, deltaTime, state, nextPole, moveOffset, }) {\n    const shouldOpenUpgrade = nextPole && nextPole.arrived && !nextPole.granted && !state.isDialogOpen;\n    if (shouldOpenUpgrade) {\n        const hasActive = state.upgrades.some((u) => u.active);\n        const availableUpgrades = ALL_UPGRADES.filter((allUpgrade) => {\n            const hasIt = state.upgrades.some((u) => u.kind === allUpgrade.kind);\n            if (hasIt) {\n                return false;\n            }\n            if (allUpgrade.active && hasActive) {\n                return false;\n            }\n            return true;\n        });\n        const dialogUpgrades = (0,_random__WEBPACK_IMPORTED_MODULE_2__.randomElements)(availableUpgrades, 3);\n        const copyUpgrades = JSON.parse(JSON.stringify(dialogUpgrades));\n        return Object.assign(Object.assign({}, state), { isDialogOpen: true, dialogSelectedIndex: 0, dialogUpgrades: copyUpgrades });\n    }\n    if (!state.isDialogOpen) {\n        const isActivated = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Select);\n        if (isActivated) {\n            const activeIndex = state.upgrades.findIndex((upgrade) => {\n                return upgrade.active === true;\n            });\n            if (activeIndex !== -1) {\n                const activeUpgrade = state.upgrades[activeIndex];\n                if (activeUpgrade.cooldownPassed == null) {\n                    activeUpgrade.cooldownPassed = 0;\n                    if (activeUpgrade.usageDuration != null) {\n                        activeUpgrade.usagePassed = 0;\n                        if (activeUpgrade.kind === 'parachute') {\n                            soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_BRAKE_ID);\n                        }\n                        else if (activeUpgrade.kind === 'anti-nitro') {\n                            soundController.play(_config__WEBPACK_IMPORTED_MODULE_0__.SOUND_NITRO_ID);\n                        }\n                    }\n                }\n            }\n        }\n        // Mutates upgrades - updates cooldowns\n        state.upgrades.forEach((upgrade) => {\n            if (upgrade.usageDuration != null && upgrade.usagePassed != null) {\n                upgrade.usagePassed += deltaTime;\n                if (upgrade.usagePassed > upgrade.usageDuration) {\n                    upgrade.usagePassed = null;\n                }\n            }\n            if (upgrade.cooldown != null && upgrade.cooldownPassed != null) {\n                upgrade.cooldownPassed += deltaTime;\n                if (upgrade.cooldownPassed > upgrade.cooldown) {\n                    upgrade.cooldownPassed = null;\n                }\n            }\n        });\n        return state;\n    }\n    const isSelected = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Select);\n    if (isSelected) {\n        const newUpgrade = state.dialogUpgrades[state.dialogSelectedIndex];\n        const upgrades = [...state.upgrades, newUpgrade];\n        nextPole.granted = true;\n        soundController.play('upgradePicked1');\n        return Object.assign(Object.assign({}, state), { upgrades, isDialogOpen: false, dialogUpgrades: [], dialogSelectedIndex: 0 });\n    }\n    const isLeft = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Left);\n    const isRight = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Right);\n    let dialogSelectedIndex = state.dialogSelectedIndex;\n    if (isLeft) {\n        dialogSelectedIndex = Math.max(0, dialogSelectedIndex - 1);\n    }\n    else if (isRight) {\n        dialogSelectedIndex = Math.min(state.dialogUpgrades.length - 1, dialogSelectedIndex + 1);\n    }\n    if (isLeft || isRight) {\n        soundController.play('menuFocus2');\n    }\n    return Object.assign(Object.assign({}, state), { dialogSelectedIndex });\n}\nconst SPRITE_MAP = new Map();\nSPRITE_MAP.set('improved-steering', { x: 0, y: 0 });\nSPRITE_MAP.set('lives', { x: 32, y: 0 });\nSPRITE_MAP.set('bumper', { x: 64, y: 0 });\nSPRITE_MAP.set('curb-stop', { x: 96, y: 0 });\nSPRITE_MAP.set('curb-duration', { x: 32, y: 32 });\nSPRITE_MAP.set('turn-uphill-slow', { x: 128, y: 0 });\nSPRITE_MAP.set('anti-nitro', { x: 160, y: 0 });\nSPRITE_MAP.set('parachute', { x: 192, y: 0 });\nSPRITE_MAP.set('lower-max-speed', { x: 224, y: 0 });\nfunction drawUpgradeDialog(ctx, { lastTime, images, state, }) {\n    if (!state.isDialogOpen) {\n        return;\n    }\n    const width = 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const height = 130 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const x = (_config__WEBPACK_IMPORTED_MODULE_0__.IW - width) / 2;\n    const y = (_config__WEBPACK_IMPORTED_MODULE_0__.IH - height) / 2;\n    ctx.globalAlpha = 0.5;\n    ctx.fillStyle = 'black';\n    ctx.fillRect(0, 0, _config__WEBPACK_IMPORTED_MODULE_0__.IW, _config__WEBPACK_IMPORTED_MODULE_0__.IH);\n    ctx.globalAlpha = 1;\n    ctx.fillStyle = '#409398';\n    ctx.fillRect(x, y, width, height);\n    ctx.strokeStyle = '#2b7d82';\n    ctx.lineWidth = 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    ctx.strokeRect(x, y, width, height);\n    ctx.fillStyle = '#222';\n    ctx.font = `${12 * _config__WEBPACK_IMPORTED_MODULE_0__.RS}px ${_config__WEBPACK_IMPORTED_MODULE_0__.FONT_PRIMARY}`;\n    ctx.fillText('Pick an upgrade', x + 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, y + 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n    state.dialogUpgrades.forEach((upgrade, index) => {\n        drawUpgradeDialogItem(ctx, {\n            lastTime,\n            images,\n            upgrade,\n            index,\n            isSelected: state.dialogSelectedIndex === index,\n        });\n    });\n}\nfunction drawUpgradeDialogItem(ctx, { lastTime, images, upgrade, isSelected, index, }) {\n    const x = 130 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + 45 * _config__WEBPACK_IMPORTED_MODULE_0__.RS * index;\n    const y = 70 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const size = 32 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    drawUpgradeImage(ctx, { lastTime, upgrade, images, x, y, size });\n    if (isSelected) {\n        ctx.strokeStyle = '#e42424';\n        ctx.lineWidth = 2 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n        ctx.strokeRect(x, y, size, size);\n        ctx.drawImage(images.menuBullet, x + 12 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, y - 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, 12, 12);\n        const startY = 124;\n        const gapY = 12;\n        ctx.fillSttyle = '#222';\n        ctx.font = `${8 * _config__WEBPACK_IMPORTED_MODULE_0__.RS}px ${_config__WEBPACK_IMPORTED_MODULE_0__.FONT_PRIMARY}`;\n        ctx.fillText(upgrade.active ? 'Active' : 'Passive', 100 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, startY * _config__WEBPACK_IMPORTED_MODULE_0__.RS, 180 * _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n        ctx.fillText(upgrade.description, 100 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, (startY + gapY) * _config__WEBPACK_IMPORTED_MODULE_0__.RS, 180 * _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n        if (upgrade.description2) {\n            ctx.fillText(upgrade.description2, 100 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, (startY + gapY * 2) * _config__WEBPACK_IMPORTED_MODULE_0__.RS, 140 * _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n        }\n    }\n}\nfunction drawUpgradeImage(ctx, { lastTime, upgrade, images, x, y, size = 32, }) {\n    const image = images.upgrades;\n    const { x: sourceX, y: sourceY } = SPRITE_MAP.get(upgrade.kind);\n    const sourceWidth = 32;\n    const sourceHeight = 32;\n    ctx.drawImage(image, sourceX, sourceY, sourceWidth, sourceHeight, x, y, size, size);\n    if (upgrade.active) {\n        ctx.drawImage(image, 0, 32, sourceWidth, sourceHeight, x, y, size, size);\n        if (size === 24 * _config__WEBPACK_IMPORTED_MODULE_0__.RS) {\n            let color = '#444';\n            if (Math.round(lastTime / 0.3) % 2 === 0) {\n                color = '#e4d884';\n            }\n            if (upgrade.cooldown != null && upgrade.cooldownPassed == null) {\n                ctx.fillStyle = color;\n                ctx.font = `${6 * _config__WEBPACK_IMPORTED_MODULE_0__.RS}px ${_config__WEBPACK_IMPORTED_MODULE_0__.FONT_PRIMARY}`;\n                ctx.fillStyle = ctx.fillText('SPACEBAR', x, y + 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, 24 * _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n            }\n        }\n    }\n    if (upgrade.kind === 'lives') {\n        ctx.fillStyle = '#fff';\n        if (size === 24 * _config__WEBPACK_IMPORTED_MODULE_0__.RS) {\n            ctx.font = `${9 * _config__WEBPACK_IMPORTED_MODULE_0__.RS}px ${_config__WEBPACK_IMPORTED_MODULE_0__.FONT_PRIMARY}`;\n            ctx.fillText(upgrade.count, x + 9.5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, y + 15 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n        }\n        else {\n            ctx.font = `${12 * _config__WEBPACK_IMPORTED_MODULE_0__.RS}px ${_config__WEBPACK_IMPORTED_MODULE_0__.FONT_PRIMARY}`;\n            ctx.fillText(upgrade.count, x + 11 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, y + 21 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n        }\n    }\n    if (upgrade.cooldown != null && upgrade.cooldownPassed != null) {\n        const niceTime = Math.floor(upgrade.cooldown - upgrade.cooldownPassed);\n        ctx.globalAlpha = 0.6;\n        ctx.fillStyle = '#333';\n        ctx.fillRect(x + 1, y + 1, size - 2, size - 2);\n        ctx.globalAlpha = 1;\n        ctx.lineWidth = 1;\n        ctx.font = `${12 * _config__WEBPACK_IMPORTED_MODULE_0__.RS}px ${_config__WEBPACK_IMPORTED_MODULE_0__.FONT_PRIMARY}`;\n        ctx.fillStyle = '#fff';\n        ctx.fillText(niceTime, x + 7 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, y + 16 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n    }\n    if (upgrade.kind === 'lives' && upgrade.count === 0) {\n        ctx.globalAlpha = 0.6;\n        ctx.fillStyle = '#333';\n        ctx.fillRect(x + 1, y + 1, size - 2, size - 2);\n        ctx.globalAlpha = 1;\n    }\n}\nfunction drawActiveUpgrades(ctx, { lastTime, state, images, }) {\n    state.upgrades.forEach((upgrade, index) => {\n        drawActiveUpgradeItem(ctx, { lastTime, upgrade, images, index });\n    });\n}\nfunction drawActiveUpgradeItem(ctx, { lastTime, upgrade, images, index, }) {\n    const x = 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + 28 * _config__WEBPACK_IMPORTED_MODULE_0__.RS * index;\n    const y = 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const size = 24 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    drawUpgradeImage(ctx, { lastTime, upgrade, images, x, y, size });\n}\n\n\n//# sourceURL=webpack:///./src/upgrade.ts?");

/***/ }),

/***/ "./src/zone.ts":
/*!*********************!*\
  !*** ./src/zone.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getActiveZone\": () => (/* binding */ getActiveZone),\n/* harmony export */   \"getNextZone\": () => (/* binding */ getNextZone)\n/* harmony export */ });\nconst defaultZone = {\n    start: 0,\n    propCount: 0,\n    kind: 'green',\n};\nfunction getActiveZone({ zones, moveOffset, }) {\n    for (let i = zones.length - 1; i >= 0; i--) {\n        const zone = zones[i];\n        if (moveOffset >= zone.start) {\n            return zone;\n        }\n    }\n    return defaultZone;\n}\nfunction getNextZone({ zones, moveOffset, }) {\n    var _a;\n    let activeIndex = -1;\n    for (let i = zones.length - 1; i >= 0; i--) {\n        const zone = zones[i];\n        if (moveOffset >= zone.start) {\n            activeIndex = i;\n            break;\n        }\n    }\n    if (activeIndex !== -1) {\n        const nextIndex = activeIndex + 1;\n        return (_a = zones[nextIndex]) !== null && _a !== void 0 ? _a : defaultZone;\n    }\n    return defaultZone;\n}\n\n\n//# sourceURL=webpack:///./src/zone.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;