/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/background.ts":
/*!***************************!*\
  !*** ./src/background.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawBackground\": () => (/* binding */ drawBackground)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\nfunction drawBackground(ctx, { bgImage, bgOffset, yOverride, }) {\n    const offsetX = bgOffset % bgImage.width;\n    const offsetY = 0;\n    const horizonOffsetY = (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH) - _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n    // TODO: make it depend on the steepness of the hill\n    let parallaxMult = 1;\n    if (horizonOffsetY > 0) {\n        // looking up\n        parallaxMult = 0.4;\n    }\n    else if (horizonOffsetY < 0) {\n        // looking down\n        parallaxMult = 0.7;\n    }\n    const sourceOffsetY = 25;\n    const parallaxY = horizonOffsetY * parallaxMult;\n    const sourceX = offsetX;\n    const sourceY = sourceOffsetY - parallaxY;\n    const sourceWidth = _config__WEBPACK_IMPORTED_MODULE_0__.IW;\n    const sourceHeight = yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n    const destX = 0;\n    const destY = 0;\n    const destWidth = _config__WEBPACK_IMPORTED_MODULE_0__.IW;\n    const destHeight = yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n    ctx.globalAlpha = 0.7;\n    ctx.drawImage(bgImage, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);\n    if (sourceX < 0) {\n        const overflow = Math.abs(sourceX);\n        const newSourceX = bgImage.width - overflow;\n        const newSourceWidth = overflow;\n        const newDestWidth = overflow;\n        ctx.drawImage(bgImage, newSourceX, sourceY, newSourceWidth, sourceHeight, destX, destY, newDestWidth, destHeight);\n    }\n    if (sourceX > bgImage.width - _config__WEBPACK_IMPORTED_MODULE_0__.IW) {\n        const overflow = sourceX - (bgImage.width - _config__WEBPACK_IMPORTED_MODULE_0__.IW);\n        const newSourceX = 0;\n        const newSourceWidth = overflow;\n        const newDestX = _config__WEBPACK_IMPORTED_MODULE_0__.IW - overflow;\n        const newDestWidth = overflow;\n        ctx.drawImage(bgImage, newSourceX, sourceY, newSourceWidth, sourceHeight, newDestX, destY, newDestWidth, destHeight);\n    }\n    ctx.globalAlpha = 1;\n}\n\n\n//# sourceURL=webpack:///./src/background.ts?");

/***/ }),

/***/ "./src/car.ts":
/*!********************!*\
  !*** ./src/car.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawCar\": () => (/* binding */ drawCar),\n/* harmony export */   \"updateMoveSpeed\": () => (/* binding */ updateMoveSpeed)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\nfunction drawCar(ctx, { images, steerOffset, }) {\n    const image = images.car;\n    const scale = 0.6 * _config__WEBPACK_IMPORTED_MODULE_0__.RENDER_SCALE;\n    const centerX = (_config__WEBPACK_IMPORTED_MODULE_0__.IW - image.width * scale) / 2;\n    const carSteerOffset = -1 * steerOffset * 0.02;\n    const x = centerX + carSteerOffset;\n    const y = _config__WEBPACK_IMPORTED_MODULE_0__.IH - 70 * _config__WEBPACK_IMPORTED_MODULE_0__.RENDER_SCALE;\n    ctx.drawImage(image, x, y, image.width * scale, image.height * scale);\n}\nfunction updateMoveSpeed({ isAccelerating, gear: currentGear, speedChange: currentSpeedChange, speed: currentSpeed, }) {\n    let gear = currentGear;\n    let speedChange = currentSpeedChange;\n    let speed = currentSpeed;\n    const gearDesc = _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_GEARS[gear];\n    if (isAccelerating) {\n        if (speedChange < 0) {\n            speedChange = 0;\n        }\n        speedChange = (speedChange + _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_ACCELERATION) / gearDesc.delim;\n        speed += speedChange;\n    }\n    else {\n        if (speed > 0) {\n            speedChange = (speedChange - _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_DECELERATION) / gearDesc.delim;\n            speed = Math.max(0, speed + speedChange);\n        }\n    }\n    if (speed > gearDesc.endAt) {\n        gear = Math.min(gear + 1, 5);\n    }\n    else if (speed < gearDesc.startAt) {\n        gear = Math.max(gear - 1, 1);\n    }\n    speed = Math.min(speed, gearDesc.endAt);\n    return {\n        gear,\n        speedChange,\n        speed,\n    };\n}\n\n\n//# sourceURL=webpack:///./src/car.ts?");

/***/ }),

/***/ "./src/config.ts":
/*!***********************!*\
  !*** ./src/config.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BG_SPEED\": () => (/* binding */ BG_SPEED),\n/* harmony export */   \"BH\": () => (/* binding */ BH),\n/* harmony export */   \"BW\": () => (/* binding */ BW),\n/* harmony export */   \"HH\": () => (/* binding */ HH),\n/* harmony export */   \"HW\": () => (/* binding */ HW),\n/* harmony export */   \"IH\": () => (/* binding */ IH),\n/* harmony export */   \"IW\": () => (/* binding */ IW),\n/* harmony export */   \"MOVE_ACCELERATION\": () => (/* binding */ MOVE_ACCELERATION),\n/* harmony export */   \"MOVE_DECELERATION\": () => (/* binding */ MOVE_DECELERATION),\n/* harmony export */   \"MOVE_GEARS\": () => (/* binding */ MOVE_GEARS),\n/* harmony export */   \"MOVE_SPEED\": () => (/* binding */ MOVE_SPEED),\n/* harmony export */   \"RENDER_SCALE\": () => (/* binding */ RENDER_SCALE),\n/* harmony export */   \"RS\": () => (/* binding */ RS),\n/* harmony export */   \"STEER_LIMIT\": () => (/* binding */ STEER_LIMIT),\n/* harmony export */   \"STEER_SPEED\": () => (/* binding */ STEER_SPEED),\n/* harmony export */   \"STEER_TURN_COUNTER_FORCE\": () => (/* binding */ STEER_TURN_COUNTER_FORCE)\n/* harmony export */ });\nconst RENDER_SCALE = 1;\nconst RS = RENDER_SCALE;\nconst BW = 380 * RENDER_SCALE;\nconst BH = 200 * RENDER_SCALE;\nconst IW = BW;\nconst IH = BH;\nconst HW = IW / 2; // half = 190\nconst HH = IH / 2; // half = 100\nconst STEER_LIMIT = Infinity;\nconst STEER_TURN_COUNTER_FORCE = 3 * RS;\nconst MOVE_SPEED = 4 * RS;\nconst STEER_SPEED = 5 * RS;\nconst BG_SPEED = 2 * RS;\nconst MOVE_ACCELERATION = 0.03;\nconst MOVE_DECELERATION = 0.05;\nconst MOVE_GEARS = {\n    1: { delim: 3, startAt: 0, endAt: 1.1 },\n    2: { delim: 4, startAt: 1, endAt: 2.6 },\n    3: { delim: 5, startAt: 2.5, endAt: 4.1 },\n    4: { delim: 6, startAt: 4, endAt: 6.1 },\n    5: { delim: 7, startAt: 6, endAt: 8 },\n};\n\n\n//# sourceURL=webpack:///./src/config.ts?");

/***/ }),

/***/ "./src/controls.ts":
/*!*************************!*\
  !*** ./src/controls.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InputControl\": () => (/* binding */ InputControl),\n/* harmony export */   \"listenKeyboard\": () => (/* binding */ listenKeyboard)\n/* harmony export */ });\nvar KeyboardButtonCode;\n(function (KeyboardButtonCode) {\n    KeyboardButtonCode[KeyboardButtonCode[\"Left\"] = 37] = \"Left\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Up\"] = 38] = \"Up\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Right\"] = 39] = \"Right\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Down\"] = 40] = \"Down\";\n    KeyboardButtonCode[KeyboardButtonCode[\"W\"] = 87] = \"W\";\n    KeyboardButtonCode[KeyboardButtonCode[\"A\"] = 65] = \"A\";\n    KeyboardButtonCode[KeyboardButtonCode[\"D\"] = 68] = \"D\";\n    KeyboardButtonCode[KeyboardButtonCode[\"S\"] = 83] = \"S\";\n})(KeyboardButtonCode || (KeyboardButtonCode = {}));\nvar InputControl;\n(function (InputControl) {\n    InputControl[InputControl[\"Up\"] = 0] = \"Up\";\n    InputControl[InputControl[\"Down\"] = 1] = \"Down\";\n    InputControl[InputControl[\"Left\"] = 2] = \"Left\";\n    InputControl[InputControl[\"Right\"] = 3] = \"Right\";\n})(InputControl || (InputControl = {}));\nconst binding = {\n    [InputControl.Up]: [KeyboardButtonCode.Up, KeyboardButtonCode.W],\n    [InputControl.Down]: [KeyboardButtonCode.Down, KeyboardButtonCode.S],\n    [InputControl.Left]: [KeyboardButtonCode.Left, KeyboardButtonCode.A],\n    [InputControl.Right]: [KeyboardButtonCode.Right, KeyboardButtonCode.D],\n};\nlet internalCodes = [];\nfunction listenKeyboard() {\n    document.addEventListener('keydown', (ev) => {\n        if (!internalCodes.includes(ev.keyCode)) {\n            internalCodes.push(ev.keyCode);\n        }\n    });\n    document.addEventListener('keyup', (ev) => {\n        internalCodes = internalCodes.filter((k) => k !== ev.keyCode);\n    });\n    return {\n        isDown(control) {\n            const codes = binding[control];\n            return codes.some((code) => internalCodes.includes(code));\n        },\n    };\n}\n\n\n//# sourceURL=webpack:///./src/controls.ts?");

/***/ }),

/***/ "./src/curve.ts":
/*!**********************!*\
  !*** ./src/curve.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DEFAULT_BOTTOM_DELTA\": () => (/* binding */ DEFAULT_BOTTOM_DELTA),\n/* harmony export */   \"DEFAULT_BOTTOM_LEFT_X\": () => (/* binding */ DEFAULT_BOTTOM_LEFT_X),\n/* harmony export */   \"DEFAULT_BOTTOM_RIGHT_X\": () => (/* binding */ DEFAULT_BOTTOM_RIGHT_X),\n/* harmony export */   \"curveXByY\": () => (/* binding */ curveXByY),\n/* harmony export */   \"drawCurve\": () => (/* binding */ drawCurve),\n/* harmony export */   \"leftRoadCurve\": () => (/* binding */ leftRoadCurve),\n/* harmony export */   \"lerpCurve\": () => (/* binding */ lerpCurve),\n/* harmony export */   \"pointOnCurve\": () => (/* binding */ pointOnCurve),\n/* harmony export */   \"rightRoadCurve\": () => (/* binding */ rightRoadCurve),\n/* harmony export */   \"steerCurve\": () => (/* binding */ steerCurve),\n/* harmony export */   \"translateCurve\": () => (/* binding */ translateCurve),\n/* harmony export */   \"translateCurveUniform\": () => (/* binding */ translateCurveUniform)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\n// Line equation:\n// left: 5x + 18y = 2700\n// right: 18 y - 5 x = 800\nconst DEFAULT_BOTTOM_DELTA = 180 * _config__WEBPACK_IMPORTED_MODULE_0__.RENDER_SCALE;\nconst DEFAULT_BOTTOM_LEFT_X = -DEFAULT_BOTTOM_DELTA;\nconst DEFAULT_BOTTOM_RIGHT_X = _config__WEBPACK_IMPORTED_MODULE_0__.IW + DEFAULT_BOTTOM_DELTA;\nfunction leftRoadCurve(controlX, controlY, topX, topY, bottomX = DEFAULT_BOTTOM_LEFT_X, bottomY = _config__WEBPACK_IMPORTED_MODULE_0__.IH) {\n    return { controlX, controlY, topX, topY, bottomX, bottomY };\n}\nfunction rightRoadCurve(controlX, controlY, topX, topY, bottomX = DEFAULT_BOTTOM_RIGHT_X, bottomY = _config__WEBPACK_IMPORTED_MODULE_0__.IH) {\n    return { controlX, controlY, topX, topY, bottomX, bottomY };\n}\nfunction translateCurveUniform(c, offset) {\n    return translateCurve(c, { control: offset, top: offset, bottom: offset });\n}\nfunction translateCurve(c, { control = 0, top = 0, bottom = 0, }) {\n    return Object.assign(Object.assign({}, c), { controlX: c.controlX + control, topX: c.topX + top, bottomX: c.bottomX + bottom });\n}\nfunction steerCurve(curve, { steerOffset }) {\n    const adjustedSteerOffset = steerOffset * 1;\n    return Object.assign(Object.assign({}, curve), { bottomX: curve.bottomX + adjustedSteerOffset });\n}\nfunction lerpCurve(c1, c2, t) {\n    console.assert(t >= 0 && t <= 1, 'd must be normalized: %d', t);\n    const controlX = c1.controlX + (c2.controlX - c1.controlX) * t;\n    const controlY = c1.controlY + (c2.controlY - c1.controlY) * t;\n    const topX = c1.topX + (c2.topX - c1.topX) * t;\n    const topY = c1.topY + (c2.topY - c1.topY) * t;\n    const bottomX = c1.bottomX + (c2.bottomX - c1.bottomX) * t;\n    const bottomY = c1.bottomY + (c2.bottomY - c1.bottomY) * t;\n    return {\n        controlX,\n        controlY,\n        topX,\n        topY,\n        bottomX,\n        bottomY,\n    };\n}\n// https://stackoverflow.com/a/5634528/1573638\nfunction pointOnCurve(curve, t) {\n    console.assert(t >= 0 && t <= 1, 't must be normalized: %d', t);\n    const x = (1 - t) * (1 - t) * curve.bottomX +\n        2 * (1 - t) * t * curve.controlX +\n        t * t * curve.topX;\n    const y = (1 - t) * (1 - t) * curve.bottomY +\n        2 * (1 - t) * t * curve.controlY +\n        t * t * curve.topY;\n    return { x, y };\n}\nfunction curveXByY(curve, y) {\n    // TODO: optimize: binary search? lut?\n    for (let t = 0; t <= 1; t += 0.01) {\n        const p = pointOnCurve(curve, t);\n        if (Math.abs(p.y - y) <= 1) {\n            return p.x;\n        }\n    }\n    return undefined;\n}\nfunction drawCurve(ctx, originalCurve, { moveOffset, steerOffset, color = 'orange', dashPattern, }) {\n    ctx.strokeStyle = color;\n    if (dashPattern) {\n        ctx.setLineDash(dashPattern);\n    }\n    ctx.lineDashOffset = moveOffset;\n    const curve = steerCurve(originalCurve, {\n        steerOffset,\n    });\n    ctx.beginPath();\n    ctx.moveTo(curve.bottomX, curve.bottomY);\n    ctx.quadraticCurveTo(curve.controlX, curve.controlY, curve.topX, curve.topY);\n    ctx.stroke();\n}\n\n\n//# sourceURL=webpack:///./src/curve.ts?");

/***/ }),

/***/ "./src/decor.ts":
/*!**********************!*\
  !*** ./src/decor.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawDecors\": () => (/* binding */ drawDecors),\n/* harmony export */   \"generateDecor\": () => (/* binding */ generateDecor)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve */ \"./src/curve.ts\");\n/* harmony import */ var _road__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./road */ \"./src/road.ts\");\n/* harmony import */ var _stripes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stripes */ \"./src/stripes.ts\");\n/* harmony import */ var _random__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./random */ \"./src/random.ts\");\n\n\n\n\n\n// TODO: they disappear when the bottom of the image hits the bottom of the screen\n//   -> better top of the image hits the bottom of the screen\n// TODO: variation in sizes\n// TODO: z-index with the car?\nfunction drawDecors(ctx, { decors, images, path, section, moveOffset, steerOffset, yOverride, }) {\n    var _a;\n    let roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.IH - (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    // Not using yOverride because it will re-create the stripes when the road\n    // is transitioning from straight to uphill/downhill.\n    if (section.kind === 'uphill') {\n        roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n    }\n    else if (section.kind === 'downhill') {\n        roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.HH + section.steepness;\n    }\n    const stripes = (0,_stripes__WEBPACK_IMPORTED_MODULE_3__.generateStripes)({ roadHeight });\n    const travelDistance = (0,_stripes__WEBPACK_IMPORTED_MODULE_3__.stripesUnscaledHeight)(stripes);\n    for (const decor of decors) {\n        // Offset appearance so that decor positioned at 0 in the map is actually\n        // rendered visually at 0 right from the start.\n        const appearStart = decor.start - travelDistance;\n        const appearEnd = decor.start;\n        if (moveOffset >= appearStart && moveOffset <= appearEnd) {\n            const curbPath = (0,_road__WEBPACK_IMPORTED_MODULE_2__.getCurbPath)(path, { steerOffset });\n            const sourceCurve = decor.placement === 'right' ? curbPath.right : curbPath.left;\n            const placementSign = decor.placement === 'right' ? 1 : -1;\n            const decorCurve = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.translateCurve)(sourceCurve, {\n                top: 5 * placementSign,\n                control: 10 * placementSign,\n                bottom: 20 * placementSign,\n            });\n            const driftedCurve = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.translateCurveUniform)(decorCurve, ((_a = decor.driftOffset) !== null && _a !== void 0 ? _a : 0) * placementSign);\n            const inOffset = moveOffset - decor.start + travelDistance;\n            const stripesY = (0,_stripes__WEBPACK_IMPORTED_MODULE_3__.stripesToY)(stripes, { inOffset });\n            if (stripesY === undefined) {\n                continue;\n            }\n            const decorY = _config__WEBPACK_IMPORTED_MODULE_0__.IH - stripesY;\n            const decorX = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.curveXByY)((0,_curve__WEBPACK_IMPORTED_MODULE_1__.steerCurve)(driftedCurve, { steerOffset }), decorY);\n            if (decorX === undefined) {\n                continue;\n            }\n            const hhDecorT = stripesY / _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n            const image = imageByKind(images, decor.kind);\n            let imageScale = Math.max(0, 1 - (1 - 0.1 * _config__WEBPACK_IMPORTED_MODULE_0__.RENDER_SCALE) * hhDecorT);\n            if (roadHeight > _config__WEBPACK_IMPORTED_MODULE_0__.HH && decorY < _config__WEBPACK_IMPORTED_MODULE_0__.HH) {\n                imageScale = 0.05;\n            }\n            const imageWidth = image.width * imageScale;\n            const imageHeight = image.height * imageScale;\n            const imageX = decor.placement === 'right' ? decorX : decorX - imageWidth;\n            const imageY = decorY - imageHeight;\n            ctx.drawImage(image, imageX, imageY, imageWidth, imageHeight);\n        }\n    }\n}\nfunction imageByKind(images, kind) {\n    switch (kind) {\n        case 'bush':\n            return images.bush;\n        case 'tree':\n            return images.tree;\n        case 'rock':\n            return images.rock;\n        default:\n            throw new Error(`Unsupported decor kind: \"${kind}\"`);\n    }\n}\nfunction generateDecor({ startOffset, \n// inBetweenOffset,\nsize, amount, }) {\n    const decors = [];\n    const areaSize = size / amount;\n    // Go reverse to have the farthest decors in the array first, which means the\n    // closest will be rendered last, which is better for zindex.\n    for (let i = amount - 1; i >= 0; i--) {\n        const areaStart = i * areaSize;\n        const inAreaOffset = (0,_random__WEBPACK_IMPORTED_MODULE_4__.randomNumber)(0, areaSize);\n        const start = startOffset + areaStart + inAreaOffset;\n        const kind = (0,_random__WEBPACK_IMPORTED_MODULE_4__.randomElement)(['bush', 'tree', 'rock']);\n        const driftOffset = (0,_random__WEBPACK_IMPORTED_MODULE_4__.randomNumber)(0, 50);\n        const flipX = (0,_random__WEBPACK_IMPORTED_MODULE_4__.randomElement)([true, false]);\n        const placement = (0,_random__WEBPACK_IMPORTED_MODULE_4__.randomElement)(['left', 'right']);\n        decors.push({\n            start,\n            kind,\n            placement,\n            driftOffset,\n        });\n    }\n    return decors;\n}\n\n\n//# sourceURL=webpack:///./src/decor.ts?");

/***/ }),

/***/ "./src/fragment.ts":
/*!*************************!*\
  !*** ./src/fragment.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createDownhill\": () => (/* binding */ createDownhill),\n/* harmony export */   \"createTurn\": () => (/* binding */ createTurn),\n/* harmony export */   \"createUphill\": () => (/* binding */ createUphill),\n/* harmony export */   \"lerpFragments\": () => (/* binding */ lerpFragments),\n/* harmony export */   \"straightFragment\": () => (/* binding */ straightFragment)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve */ \"./src/curve.ts\");\n/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path */ \"./src/path.ts\");\n\n\n\nconst straightFragment = {\n    left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n    right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n    end: 0,\n};\nfunction createDownhill({ size, steepness, inOffset, steerOffset, }) {\n    const halfSize = size / 2;\n    const d = 1 - Math.abs((inOffset - halfSize) / halfSize);\n    const yOffset = -steepness * d;\n    const y = _config__WEBPACK_IMPORTED_MODULE_0__.HH + yOffset;\n    const minY = _config__WEBPACK_IMPORTED_MODULE_0__.HH - steepness;\n    let fragments = [\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 10, y),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 10, y),\n            end: 100 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 25, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 25, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 10, minY),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 25, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 25, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 10, minY),\n            end: 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 25, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 15, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 10, minY),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 25, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 15, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 10, minY),\n            end: size - 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        Object.assign(Object.assign({}, straightFragment), { end: size }),\n    ];\n    fragments = steerFragments(fragments, steerOffset);\n    return fragments;\n}\nfunction createUphill({ size, steepness, inOffset, steerOffset, }) {\n    const halfSize = size / 2;\n    const d = 1 - Math.abs((inOffset - halfSize) / halfSize);\n    const yOffset = steepness * d;\n    const y = _config__WEBPACK_IMPORTED_MODULE_0__.HH + yOffset;\n    const maxY = _config__WEBPACK_IMPORTED_MODULE_0__.HH + steepness;\n    const xCorrection = steerOffset * 0.15;\n    const bottomLeftCorrection = steerOffset * 0.1;\n    const cxCorrection = steerOffset * 0.2;\n    let fragments = [\n        // {\n        //   left: leftRoadCurve(\n        //     HW - 70,\n        //     y - 5,\n        //     HW - 60 + xCorrection,\n        //     y,\n        //     -180 - bottomLeftCorrection,\n        //   ),\n        //   right: rightRoadCurve(\n        //     HW + 70,\n        //     y - 5,\n        //     HW + 60 + xCorrection,\n        //     y,\n        //     560 - bottomLeftCorrection,\n        //   ),\n        //   end: 300,\n        // },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 120 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + cxCorrection, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 90 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + xCorrection, maxY, _curve__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_BOTTOM_LEFT_X - bottomLeftCorrection),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 120 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + cxCorrection, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 90 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + xCorrection, maxY, _curve__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_BOTTOM_RIGHT_X - bottomLeftCorrection),\n            end: 400 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 120 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + cxCorrection, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 90 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + xCorrection, maxY, _curve__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_BOTTOM_LEFT_X - bottomLeftCorrection),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 120 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + cxCorrection, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 90 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + xCorrection, maxY, _curve__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_BOTTOM_RIGHT_X - bottomLeftCorrection),\n            end: size - 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        Object.assign(Object.assign({}, straightFragment), { end: size }),\n    ];\n    fragments = steerFragments(fragments, steerOffset);\n    return fragments;\n}\nfunction createTurn({ size, direction, steerOffset, }) {\n    console.assert(size >= 600 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, 'turn too quick: %d', size);\n    let fragments = [\n        // {\n        //   left: [HW - 10, HH - 5, HW - 10, HH],\n        //   right: [HW + 190, HH + 50, HW + 10, HH],\n        //   end: 100,\n        // },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH - 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            end: 100 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 50 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH - 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 115 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 15 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 115 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            end: 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH - 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 80 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 15 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 115 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            end: size - 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH - 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 60 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 0 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 80 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            end: size - 100 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        Object.assign(Object.assign({}, straightFragment), { end: size }),\n    ];\n    if (direction === 'left') {\n        fragments = mirrorFragments(fragments);\n    }\n    fragments = steerFragments(fragments, steerOffset);\n    return fragments;\n}\nfunction mirrorFragments(fragments) {\n    return fragments.map((fragment) => {\n        const { left, right } = fragment;\n        return Object.assign(Object.assign({}, fragment), { left: Object.assign(Object.assign({}, left), { controlX: _config__WEBPACK_IMPORTED_MODULE_0__.HW + (_config__WEBPACK_IMPORTED_MODULE_0__.HW - right.controlX), controlY: right.controlY, topX: _config__WEBPACK_IMPORTED_MODULE_0__.HW + (_config__WEBPACK_IMPORTED_MODULE_0__.HW - right.topX), topY: right.topY }), right: Object.assign(Object.assign({}, right), { controlX: _config__WEBPACK_IMPORTED_MODULE_0__.HW + (_config__WEBPACK_IMPORTED_MODULE_0__.HW - left.controlX), controlY: left.controlY, topX: _config__WEBPACK_IMPORTED_MODULE_0__.HW + (_config__WEBPACK_IMPORTED_MODULE_0__.HW - left.topX), topY: left.topY }) });\n    });\n}\nfunction steerFragments(fragments, steerOffset) {\n    const topOffset = steerOffset * 0.01;\n    return fragments.map((fragment) => {\n        const { left, right } = fragment;\n        return Object.assign(Object.assign({}, fragment), { left: Object.assign(Object.assign({}, left), { controlX: left.controlX + topOffset, topX: left.topX + topOffset }), right: Object.assign(Object.assign({}, right), { controlX: right.controlX + topOffset, topX: right.topX + topOffset }) });\n    });\n}\nfunction lerpFragments({ fragments, inOffset, }) {\n    const activeIndex = fragments.findIndex((fragment) => {\n        return inOffset < fragment.end;\n    });\n    const prevIndex = activeIndex !== -1 ? activeIndex - 1 : -1;\n    const prevFragment = fragments[prevIndex] || straightFragment;\n    const activeFragment = fragments[activeIndex] || straightFragment;\n    let d = 0;\n    const fragmentSize = activeFragment.end - prevFragment.end;\n    const inFragmentOffset = inOffset - prevFragment.end;\n    if (fragmentSize !== 0) {\n        d = inFragmentOffset / fragmentSize;\n    }\n    const path = (0,_path__WEBPACK_IMPORTED_MODULE_2__.lerpPath)(prevFragment, activeFragment, d);\n    return path;\n}\n\n\n//# sourceURL=webpack:///./src/fragment.ts?");

/***/ }),

/***/ "./src/images.ts":
/*!***********************!*\
  !*** ./src/images.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"loadImages\": () => (/* binding */ loadImages)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction loadImages() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return {\n            car: yield loadImage('data/graphics/car.png'),\n            bg1: yield loadImage('data/graphics/bg1.png'),\n            bg2: yield loadImage('data/graphics/bg2.png'),\n            bush: yield loadImage('data/graphics/bush.png'),\n            tree: yield loadImage('data/graphics/tree.png'),\n            rock: yield loadImage('data/graphics/rock.png'),\n        };\n    });\n}\nfunction loadImage(imagePath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve) => {\n            const image = new Image();\n            image.src = imagePath;\n            image.addEventListener('load', () => {\n                resolve(image);\n            });\n        });\n    });\n}\n\n\n//# sourceURL=webpack:///./src/images.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _car__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./car */ \"./src/car.ts\");\n/* harmony import */ var _controls__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./controls */ \"./src/controls.ts\");\n/* harmony import */ var _background__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./background */ \"./src/background.ts\");\n/* harmony import */ var _decor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./decor */ \"./src/decor.ts\");\n/* harmony import */ var _fragment__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fragment */ \"./src/fragment.ts\");\n/* harmony import */ var _images__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./images */ \"./src/images.ts\");\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./map */ \"./src/map.ts\");\n/* harmony import */ var _road__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./road */ \"./src/road.ts\");\n/* harmony import */ var _stripes__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./stripes */ \"./src/stripes.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\nconst canvas = document.querySelector('canvas');\nconst ctx = canvas.getContext('2d');\ncanvas.width = _config__WEBPACK_IMPORTED_MODULE_0__.IW;\ncanvas.height = _config__WEBPACK_IMPORTED_MODULE_0__.IH;\nconst offCanvas = new OffscreenCanvas(_config__WEBPACK_IMPORTED_MODULE_0__.IW, _config__WEBPACK_IMPORTED_MODULE_0__.IH);\nconst offCtx = offCanvas.getContext('2d');\ncanvas.addEventListener('click', (ev) => {\n    console.log(ev.clientX / 2, ev.clientY / 2);\n});\nconst keyboardListener = (0,_controls__WEBPACK_IMPORTED_MODULE_2__.listenKeyboard)();\nconst resources = {\n    map: _map__WEBPACK_IMPORTED_MODULE_7__.coolMap,\n    images: undefined,\n};\nconst state = {\n    moveSpeed: {\n        gear: 1,\n        speedChange: 0,\n        speed: 0,\n    },\n    moveOffset: 0,\n    steerSpeed: 0,\n    steerOffset: 0,\n    bgOffset: 0,\n};\nconst images = {\n    car: undefined,\n    bg1: undefined,\n    bg2: undefined,\n    bush: undefined,\n};\nfunction draw() {\n    ctx.clearRect(0, 0, _config__WEBPACK_IMPORTED_MODULE_0__.IW, _config__WEBPACK_IMPORTED_MODULE_0__.IH);\n    const section = getActiveSection();\n    const inSectionOffset = state.moveOffset - section.start;\n    if (section.kind === 'straight') {\n        drawObjects({ path: _fragment__WEBPACK_IMPORTED_MODULE_5__.straightFragment, section });\n        return;\n    }\n    if (section.kind === 'turn-right' || section.kind === 'turn-left') {\n        if (state.moveSpeed.speed > 0) {\n            if (section.kind === 'turn-left') {\n                state.steerOffset -= _config__WEBPACK_IMPORTED_MODULE_0__.STEER_TURN_COUNTER_FORCE;\n                if (inSectionOffset > 200) {\n                    state.bgOffset -= _config__WEBPACK_IMPORTED_MODULE_0__.BG_SPEED;\n                }\n            }\n            else if (section.kind === 'turn-right') {\n                state.steerOffset += _config__WEBPACK_IMPORTED_MODULE_0__.STEER_TURN_COUNTER_FORCE;\n                if (inSectionOffset > 200) {\n                    state.bgOffset += _config__WEBPACK_IMPORTED_MODULE_0__.BG_SPEED;\n                }\n            }\n        }\n        const fragments = (0,_fragment__WEBPACK_IMPORTED_MODULE_5__.createTurn)({\n            size: section.size,\n            direction: section.kind === 'turn-right' ? 'right' : 'left',\n            steerOffset: state.steerOffset,\n        });\n        const path = (0,_fragment__WEBPACK_IMPORTED_MODULE_5__.lerpFragments)({\n            fragments,\n            inOffset: inSectionOffset,\n        });\n        drawObjects({ path, section });\n        return;\n    }\n    if (section.kind === 'downhill') {\n        const fragments = (0,_fragment__WEBPACK_IMPORTED_MODULE_5__.createDownhill)({\n            size: section.size,\n            inOffset: inSectionOffset,\n            steepness: section.steepness,\n            steerOffset: state.steerOffset,\n        });\n        const path = (0,_fragment__WEBPACK_IMPORTED_MODULE_5__.lerpFragments)({\n            fragments,\n            inOffset: inSectionOffset,\n        });\n        const yOverride = path.left.topY;\n        drawObjects({ path, section, yOverride });\n        return;\n    }\n    if (section.kind === 'uphill') {\n        const fragments = (0,_fragment__WEBPACK_IMPORTED_MODULE_5__.createUphill)({\n            size: section.size,\n            inOffset: inSectionOffset,\n            steepness: section.steepness,\n            steerOffset: state.steerOffset,\n        });\n        const path = (0,_fragment__WEBPACK_IMPORTED_MODULE_5__.lerpFragments)({\n            fragments,\n            inOffset: inSectionOffset,\n        });\n        const yOverride = path.left.topY;\n        drawObjects({ path, section, yOverride });\n        return;\n    }\n}\nfunction getActiveSection() {\n    let activeSection = resources.map.sections.find((s) => {\n        return state.moveOffset >= s.start && state.moveOffset <= s.start + s.size;\n    });\n    if (!activeSection || hasSectionEnded(activeSection)) {\n        activeSection = { start: state.moveOffset, kind: 'straight', size: 0 };\n    }\n    return activeSection;\n}\nfunction drawObjects({ path, section, yOverride, }) {\n    const { bgOffset, moveOffset, steerOffset } = state;\n    // Draw the road stripes full width. Then cut it out and keep the area that is\n    // actually covered by the road (the ground area will become transparent\n    // again). Do it offscreen because we have to apply another mask and it's hard\n    // to do on a single canvas.\n    offCtx.globalCompositeOperation = 'source-over';\n    (0,_stripes__WEBPACK_IMPORTED_MODULE_9__.drawRoadStripes)(offCtx, { moveOffset, yOverride });\n    offCtx.globalCompositeOperation = 'destination-in';\n    (0,_road__WEBPACK_IMPORTED_MODULE_8__.drawRoadMask)(offCtx, path, { steerOffset });\n    ctx.drawImage(offCanvas, 0, 0);\n    // Ditto for the road. Except the curbs are drawn to the main canvas behind\n    // the already present road.\n    offCtx.globalCompositeOperation = 'source-over';\n    (0,_stripes__WEBPACK_IMPORTED_MODULE_9__.drawCurbStripes)(offCtx, { moveOffset, yOverride });\n    offCtx.globalCompositeOperation = 'destination-in';\n    (0,_road__WEBPACK_IMPORTED_MODULE_8__.drawCurbMask)(offCtx, path, { steerOffset });\n    ctx.globalCompositeOperation = 'destination-over';\n    ctx.drawImage(offCanvas, 0, 0);\n    // Then draw the ground stripes full widths but behind the road - it will keep\n    // the road+curbs that were drawn on the previous step and only fill in the\n    // ground stripes on the sides.\n    ctx.globalCompositeOperation = 'destination-over';\n    (0,_stripes__WEBPACK_IMPORTED_MODULE_9__.drawGroundStripes)(ctx, { moveOffset, yOverride });\n    // Then draw everything on top\n    ctx.globalCompositeOperation = 'source-over';\n    (0,_background__WEBPACK_IMPORTED_MODULE_3__.drawBackground)(ctx, {\n        bgImage: resources.images.bg2,\n        bgOffset,\n        yOverride,\n    });\n    // drawHorizon({ yOverride });\n    // drawGrid();\n    (0,_decor__WEBPACK_IMPORTED_MODULE_4__.drawDecors)(ctx, {\n        decors: resources.map.decors,\n        images: resources.images,\n        path,\n        section,\n        moveOffset,\n        steerOffset,\n        yOverride,\n    });\n    (0,_car__WEBPACK_IMPORTED_MODULE_1__.drawCar)(ctx, { images: resources.images, steerOffset });\n    drawDebug();\n}\nfunction hasSectionEnded(section) {\n    return section.start + section.size < state.moveOffset;\n}\nfunction drawHorizon({ yOverride } = {}) {\n    ctx.strokeStyle = 'green';\n    ctx.lineWidth = 1;\n    ctx.setLineDash([]);\n    ctx.beginPath();\n    ctx.moveTo(0, yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    ctx.lineTo(_config__WEBPACK_IMPORTED_MODULE_0__.IW, yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    ctx.stroke();\n}\nfunction drawGrid() {\n    ctx.setLineDash([]);\n    ctx.strokeStyle = '#cccccc77';\n    ctx.moveTo(_config__WEBPACK_IMPORTED_MODULE_0__.HW, 0);\n    ctx.lineTo(_config__WEBPACK_IMPORTED_MODULE_0__.HW, _config__WEBPACK_IMPORTED_MODULE_0__.IH);\n    ctx.stroke();\n}\nfunction drawDebug({ section } = {}) {\n    ctx.setLineDash([]);\n    ctx.strokeStyle = '#000';\n    ctx.font = '8px serif';\n    const activeSection = getActiveSection();\n    ctx.strokeText(`section kind: ${activeSection.kind}`, 5, 10);\n    ctx.strokeText(`bg: ${state.bgOffset}`, 5, 20);\n    ctx.strokeText(`steer: ${state.steerOffset}`, 5, 30);\n    ctx.strokeText(`move offset: ${state.moveOffset}`, 5, 40);\n    ctx.strokeText(`move speed: ${state.moveSpeed.speed.toFixed(5)}`, 5, 50);\n    ctx.strokeText(`move speed change: ${state.moveSpeed.speedChange.toFixed(5)}`, 5, 60);\n    ctx.strokeText(`move gear: ${state.moveSpeed.gear}`, 5, 70);\n}\nfunction main() {\n    return __awaiter(this, void 0, void 0, function* () {\n        resources.images = yield (0,_images__WEBPACK_IMPORTED_MODULE_6__.loadImages)();\n        loop();\n    });\n}\nfunction loop() {\n    state.moveSpeed = (0,_car__WEBPACK_IMPORTED_MODULE_1__.updateMoveSpeed)(Object.assign({ isAccelerating: keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_2__.InputControl.Up) }, state.moveSpeed));\n    state.moveOffset += state.moveSpeed.speed;\n    // TODO: Make steer speed depend on move speed\n    if (keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_2__.InputControl.Left)) {\n        state.steerSpeed = _config__WEBPACK_IMPORTED_MODULE_0__.STEER_SPEED;\n        const nextOffset = state.steerOffset + state.steerSpeed;\n        state.steerOffset = Math.min(_config__WEBPACK_IMPORTED_MODULE_0__.STEER_LIMIT, nextOffset);\n    }\n    else if (keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_2__.InputControl.Right)) {\n        state.steerSpeed = _config__WEBPACK_IMPORTED_MODULE_0__.STEER_SPEED;\n        const nextOffset = state.steerOffset - state.steerSpeed;\n        state.steerOffset = Math.max(-_config__WEBPACK_IMPORTED_MODULE_0__.STEER_LIMIT, nextOffset);\n    }\n    else {\n        state.steerSpeed = 0;\n    }\n    draw();\n    requestAnimationFrame(loop);\n}\nmain();\n\n\n//# sourceURL=webpack:///./src/main.ts?");

/***/ }),

/***/ "./src/map.ts":
/*!********************!*\
  !*** ./src/map.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"coolMap\": () => (/* binding */ coolMap),\n/* harmony export */   \"longLeftTurnMap\": () => (/* binding */ longLeftTurnMap),\n/* harmony export */   \"longUphillMap\": () => (/* binding */ longUphillMap),\n/* harmony export */   \"straightMap\": () => (/* binding */ straightMap)\n/* harmony export */ });\n/* harmony import */ var _decor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decor */ \"./src/decor.ts\");\n\nconst straightMap = {\n    sections: [],\n    decors: [\n        ...(0,_decor__WEBPACK_IMPORTED_MODULE_0__.generateDecor)({\n            startOffset: 100,\n            amount: 1,\n            size: 5000,\n            // inBetweenOffset: 200,\n        }),\n    ],\n};\nconst longUphillMap = {\n    sections: [\n        {\n            kind: 'downhill',\n            start: 100,\n            size: 1000,\n            steepness: 30,\n        },\n    ],\n    decors: [\n    // ...generateDecor({\n    //   startOffset: 0,\n    //   inBetweenOffset: 200,\n    //   size: 2000,\n    // }),\n    ],\n};\nconst longLeftTurnMap = {\n    sections: [\n        {\n            kind: 'turn-left',\n            start: 0,\n            size: Infinity,\n        },\n    ],\n    decors: [],\n};\nconst coolMap = {\n    sections: [\n        {\n            kind: 'uphill',\n            start: 100,\n            size: 700,\n            steepness: 30,\n        },\n        {\n            kind: 'turn-left',\n            start: 1000,\n            size: 600,\n        },\n        {\n            kind: 'turn-right',\n            start: 1500,\n            size: 1000,\n        },\n        {\n            kind: 'downhill',\n            start: 2600,\n            size: 1000,\n            steepness: 50,\n        },\n    ],\n    decors: [\n        ...(0,_decor__WEBPACK_IMPORTED_MODULE_0__.generateDecor)({\n            startOffset: 300,\n            size: 15000,\n            amount: 100,\n        }),\n    ],\n};\n\n\n//# sourceURL=webpack:///./src/map.ts?");

/***/ }),

/***/ "./src/path.ts":
/*!*********************!*\
  !*** ./src/path.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"lerpPath\": () => (/* binding */ lerpPath),\n/* harmony export */   \"steerPath\": () => (/* binding */ steerPath),\n/* harmony export */   \"translatePath\": () => (/* binding */ translatePath)\n/* harmony export */ });\n/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve */ \"./src/curve.ts\");\n\nfunction steerPath(path, { steerOffset }) {\n    return Object.assign(Object.assign({}, path), { left: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.steerCurve)(path.left, { steerOffset }), right: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.steerCurve)(path.right, { steerOffset }) });\n}\nfunction translatePath(path, { top, bottom, }) {\n    return Object.assign(Object.assign({}, path), { left: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.translateCurve)(path.left, { top: -top, bottom: -bottom }), right: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.translateCurve)(path.right, { top, bottom }) });\n}\nfunction lerpPath(p1, p2, d) {\n    return {\n        left: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.lerpCurve)(p1.left, p2.left, d),\n        right: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.lerpCurve)(p1.right, p2.right, d),\n    };\n}\n\n\n//# sourceURL=webpack:///./src/path.ts?");

/***/ }),

/***/ "./src/random.ts":
/*!***********************!*\
  !*** ./src/random.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"randomElement\": () => (/* binding */ randomElement),\n/* harmony export */   \"randomNumber\": () => (/* binding */ randomNumber)\n/* harmony export */ });\nfunction randomElement(items) {\n    const index = Math.floor(Math.random() * items.length);\n    return items[index];\n}\nfunction randomNumber(from = 0, to = 1) {\n    return Math.floor(Math.random() * (to - from + 1) + from);\n}\n\n\n//# sourceURL=webpack:///./src/random.ts?");

/***/ }),

/***/ "./src/road.ts":
/*!*********************!*\
  !*** ./src/road.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawCurbMask\": () => (/* binding */ drawCurbMask),\n/* harmony export */   \"drawRoadLines\": () => (/* binding */ drawRoadLines),\n/* harmony export */   \"drawRoadMask\": () => (/* binding */ drawRoadMask),\n/* harmony export */   \"getCurbPath\": () => (/* binding */ getCurbPath)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path */ \"./src/path.ts\");\n\n\nfunction drawRoadMask(ctx, path, { steerOffset, color = 'black' }) {\n    const { left, right } = (0,_path__WEBPACK_IMPORTED_MODULE_1__.steerPath)(path, {\n        steerOffset,\n    });\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(left.bottomX, left.bottomY);\n    ctx.quadraticCurveTo(left.controlX, left.controlY, left.topX, left.topY);\n    ctx.lineTo(right.topX, right.topY);\n    ctx.quadraticCurveTo(right.controlX, right.controlY, right.bottomX, right.bottomY);\n    ctx.lineTo(left.bottomX, left.bottomY);\n    ctx.fill();\n}\nfunction getCurbPath(path, { steerOffset }) {\n    return (0,_path__WEBPACK_IMPORTED_MODULE_1__.translatePath)(path, {\n        // TODO: maybe make it wider for uphills\n        top: 1 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        bottom: 50 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n    });\n}\nfunction drawCurbMask(ctx, path, { steerOffset, color = 'black' }) {\n    const steeredPath = (0,_path__WEBPACK_IMPORTED_MODULE_1__.steerPath)(path, {\n        steerOffset,\n    });\n    const { left, right } = getCurbPath(steeredPath, { steerOffset });\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(left.bottomX, left.bottomY);\n    ctx.quadraticCurveTo(left.controlX, left.controlY, left.topX, left.topY);\n    ctx.lineTo(right.topX, right.topY);\n    ctx.quadraticCurveTo(right.controlX, right.controlY, right.bottomX, right.bottomY);\n    ctx.fill();\n}\nfunction drawRoadLines(ctx, path, { moveOffset, steerOffset, color = 'red' }) {\n    ctx.strokeStyle = color;\n    ctx.setLineDash([10]);\n    ctx.lineDashOffset = moveOffset;\n    const { left, right } = (0,_path__WEBPACK_IMPORTED_MODULE_1__.steerPath)(path, {\n        steerOffset,\n    });\n    ctx.beginPath();\n    ctx.moveTo(left.bottomX, left.bottomY);\n    ctx.quadraticCurveTo(left.controlX, left.controlY, left.topX, left.topY);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.moveTo(right.bottomX, right.bottomY);\n    ctx.quadraticCurveTo(right.controlX, right.controlY, right.topX, right.topY);\n    ctx.stroke();\n}\n\n\n//# sourceURL=webpack:///./src/road.ts?");

/***/ }),

/***/ "./src/stripes.ts":
/*!************************!*\
  !*** ./src/stripes.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawCurbStripes\": () => (/* binding */ drawCurbStripes),\n/* harmony export */   \"drawGroundStripes\": () => (/* binding */ drawGroundStripes),\n/* harmony export */   \"drawRoadStripes\": () => (/* binding */ drawRoadStripes),\n/* harmony export */   \"generateStripes\": () => (/* binding */ generateStripes),\n/* harmony export */   \"stripesToY\": () => (/* binding */ stripesToY),\n/* harmony export */   \"stripesUnscaledHeight\": () => (/* binding */ stripesUnscaledHeight)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\n// It messes with the offsets but fixes weird transitions for uphill/downhill\n// when the stripes are not moving.\n// TODO: figure out another way to move stripes\nconst SPEED_EFFECT_MULTIPLIER = 1;\nconst NEAR_TEXTURE_HEIGHT = 32 * _config__WEBPACK_IMPORTED_MODULE_0__.RENDER_SCALE;\nfunction drawGroundStripes(ctx, opts) {\n    const colors = ['#889827', '#9aa545'];\n    drawStripes(ctx, Object.assign(Object.assign({}, opts), { colors }));\n}\nfunction drawRoadStripes(ctx, opts) {\n    const colors = ['#69696a', '#444446'];\n    drawStripes(ctx, Object.assign(Object.assign({}, opts), { colors }));\n}\n// TODO: make them appear more often?? but keep stripes match with bigger ones\nfunction drawCurbStripes(ctx, opts) {\n    const colors = ['#c5bfbf', '#dc3961'];\n    drawStripes(ctx, Object.assign(Object.assign({}, opts), { colors }));\n}\nfunction drawStripes(ctx, { colors, moveOffset, yOverride, }) {\n    const roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.IH - (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    // const roadHeight = HH;\n    const spedUpMoveOffset = moveOffset * SPEED_EFFECT_MULTIPLIER;\n    const stripes = generateStripes({ roadHeight });\n    const texturedStripes = textureSplitStripes(stripes, {\n        moveOffset: spedUpMoveOffset,\n    });\n    for (const stripe of texturedStripes) {\n        ctx.fillStyle = colors[stripe.textureIndex];\n        ctx.fillRect(0, _config__WEBPACK_IMPORTED_MODULE_0__.IH - stripe.y2, _config__WEBPACK_IMPORTED_MODULE_0__.IW, stripe.height);\n    }\n}\nfunction stripesUnscaledHeight(stripes) {\n    const nearTextureHeight = stripes[0].height;\n    return stripes.length * nearTextureHeight;\n}\nfunction stripesToY(stripes, { inOffset }) {\n    // First stripe travels 1 to 1 with the move offset -> 32 to 32.\n    // Let's say second stripe is smaller in size by 2 (32 / 2 = 16), which means\n    // that if inOffset travels +32, then this stripe will travel +16,\n    // or if inOffset travels +16, then this stripe will travel +8.\n    // Find a stripe we are in first using inOffset. Then figure out how much\n    // into a stripe we have travelled and return it as an y position.\n    const nearTextureHeight = stripes[0].height;\n    const roadHeight = stripes[stripes.length - 1].y2;\n    let unscaledOffset = 0;\n    let scaledY = 0;\n    const unscaledHeight = stripes.length * nearTextureHeight;\n    const unscaledIn = unscaledHeight - inOffset * SPEED_EFFECT_MULTIPLIER;\n    const unscaledT = unscaledIn / nearTextureHeight;\n    const stripeIndex = Math.floor(unscaledT);\n    const inStripeT = unscaledT % 1;\n    if (stripeIndex < 0) {\n        const firstStripe = stripes[0];\n        return undefined;\n        // return firstStripe.y2;\n    }\n    if (stripeIndex > stripes.length - 1) {\n        const lastStripe = stripes[stripes.length - 1];\n        return undefined;\n        // return lastStripe.y2;\n    }\n    const stripe = stripes[stripeIndex];\n    const y = stripe.y + stripe.height * inStripeT;\n    return y;\n}\nfunction generateStripes({ roadHeight, nearTextureHeight = NEAR_TEXTURE_HEIGHT, }) {\n    const stripes = [];\n    // Will be used in a function to calculate how much the next road stripe will\n    // be downscaled compared to the previous one because next stripe is further\n    // into the road.\n    let downscaleIndex = 1;\n    let currentY = 0;\n    let roadLeftToParse = roadHeight;\n    while (roadLeftToParse >= 0) {\n        const y = currentY;\n        if (y >= roadHeight) {\n            break;\n        }\n        const downscaleMultiplier = 1 / downscaleIndex;\n        const stripeHeight = Math.ceil(downscaleMultiplier * nearTextureHeight);\n        let y2 = y + stripeHeight;\n        let height = stripeHeight;\n        if (y2 > roadHeight) {\n            y2 = roadHeight;\n            height = Math.round(y2 - y);\n        }\n        if (height > 0) {\n            stripes.push({\n                y,\n                y2,\n                height,\n            });\n        }\n        roadLeftToParse -= stripeHeight;\n        currentY += stripeHeight;\n        downscaleIndex++;\n    }\n    return stripes;\n}\n// TODO: allow custom texture count, not just two, to split the curb\nfunction textureSplitStripes(stripes, { moveOffset, }) {\n    const splitStripes = [];\n    if (stripes.length === 0) {\n        return splitStripes;\n    }\n    const isNegativeMoveOffset = moveOffset < 0;\n    const nearTextureHeight = stripes[0].height;\n    // Based on the nearest stripe and global offset calculate how much this\n    // nearest stripe is offset from zero position. We are going to offset\n    // all of the following stripes based on the same percentages.\n    let restFillPercent = Math.abs(moveOffset % nearTextureHeight) / nearTextureHeight;\n    let primFillPercent = 1 - restFillPercent;\n    // If we are going below zero swap the percentages because the other texture\n    // will be rendered first\n    if (isNegativeMoveOffset) {\n        primFillPercent = 1 - primFillPercent;\n        restFillPercent = 1 - restFillPercent;\n    }\n    // Figure out which texture is rendered first in the current loop based on the\n    // global offset\n    let primTextureIndex = Math.floor(Math.abs(moveOffset) / nearTextureHeight) % 2;\n    // If we are going negative choose the other texture\n    if (isNegativeMoveOffset) {\n        primTextureIndex = 1 - primTextureIndex;\n    }\n    for (const stripe of stripes) {\n        // Stripe is split into two sub-stripes based on the global offset.\n        // Each stripe has it's own texture.\n        const primTextureHeight = Math.round(stripe.height * primFillPercent);\n        const restTextureHeight = stripe.height - primTextureHeight;\n        // Add both sub-stripes as separate entries of their own height with\n        // corresponding texture indexes\n        if (primTextureHeight !== 0) {\n            splitStripes.push(Object.assign(Object.assign({}, stripe), { height: primTextureHeight, y2: stripe.y + primTextureHeight, textureIndex: primTextureIndex }));\n        }\n        if (restTextureHeight !== 0) {\n            splitStripes.push(Object.assign(Object.assign({}, stripe), { height: restTextureHeight, y: stripe.y2 - restTextureHeight, textureIndex: 1 - primTextureIndex }));\n        }\n        // Alernate to the other texture and make it primary\n        primTextureIndex = 1 - primTextureIndex;\n    }\n    return splitStripes;\n}\n\n\n//# sourceURL=webpack:///./src/stripes.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;