/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/background.ts":
/*!***************************!*\
  !*** ./src/background.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawBackground\": () => (/* binding */ drawBackground),\n/* harmony export */   \"updateBackgroundOffset\": () => (/* binding */ updateBackgroundOffset)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _stripes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stripes */ \"./src/stripes.ts\");\n\n\nfunction drawBackground(ctx, { images, zone, nextZone, bgOffset, moveOffset, yOverride, }) {\n    const nextZoneIn = nextZone.start - moveOffset;\n    const roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.IH - (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    const stripes = (0,_stripes__WEBPACK_IMPORTED_MODULE_1__.generateStripes)({ roadHeight });\n    const roadDepth = (0,_stripes__WEBPACK_IMPORTED_MODULE_1__.stripesUnscaledHeight)(stripes);\n    const activeImage = imageByZoneKind(images, zone.kind);\n    let activeOpacity = 1;\n    if (nextZoneIn > 0 && nextZoneIn < roadDepth) {\n        const inOffset = roadDepth - nextZoneIn;\n        activeOpacity = 1 - inOffset / roadDepth;\n    }\n    drawBackgroundImage(ctx, {\n        image: activeImage,\n        opacity: activeOpacity,\n        bgOffset,\n        yOverride,\n    });\n    if (activeOpacity !== 1) {\n        const nextImage = imageByZoneKind(images, nextZone.kind);\n        const nextOpacity = 1 - activeOpacity;\n        const secondaryImage = drawBackgroundImage(ctx, {\n            image: nextImage,\n            opacity: nextOpacity,\n            bgOffset,\n            yOverride,\n        });\n    }\n}\nfunction drawBackgroundImage(ctx, { image, opacity, bgOffset, yOverride, }) {\n    const offsetX = bgOffset % image.width;\n    const offsetY = 0;\n    const horizonOffsetY = (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH) - _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n    // TODO: make it depend on the steepness of the hill\n    let parallaxMult = 1;\n    if (horizonOffsetY > 0) {\n        // looking up\n        parallaxMult = 0.4;\n    }\n    else if (horizonOffsetY < 0) {\n        // looking down\n        parallaxMult = 0.7;\n    }\n    const sourceOffsetY = 25;\n    const parallaxY = horizonOffsetY * parallaxMult;\n    const sourceX = offsetX;\n    const sourceY = sourceOffsetY - parallaxY;\n    const sourceWidth = _config__WEBPACK_IMPORTED_MODULE_0__.IW;\n    const sourceHeight = yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n    const destX = 0;\n    const destY = 0;\n    const destWidth = _config__WEBPACK_IMPORTED_MODULE_0__.IW;\n    const destHeight = yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n    ctx.globalAlpha = opacity;\n    ctx.drawImage(image, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);\n    if (sourceX < 0) {\n        const overflow = Math.abs(sourceX);\n        const newSourceX = image.width - overflow;\n        const newSourceWidth = overflow;\n        const newDestWidth = overflow;\n        ctx.drawImage(image, newSourceX, sourceY, newSourceWidth, sourceHeight, destX, destY, newDestWidth, destHeight);\n    }\n    if (sourceX > image.width - _config__WEBPACK_IMPORTED_MODULE_0__.IW) {\n        const overflow = sourceX - (image.width - _config__WEBPACK_IMPORTED_MODULE_0__.IW);\n        const newSourceX = 0;\n        const newSourceWidth = overflow;\n        const newDestX = _config__WEBPACK_IMPORTED_MODULE_0__.IW - overflow;\n        const newDestWidth = overflow;\n        ctx.drawImage(image, newSourceX, sourceY, newSourceWidth, sourceHeight, newDestX, destY, newDestWidth, destHeight);\n    }\n    ctx.globalAlpha = 1;\n}\nfunction imageByZoneKind(images, kind) {\n    switch (kind) {\n        case 'green':\n            return images.bgGreen;\n        case 'desert':\n            return images.bgDesert;\n        case 'forest':\n            return images.bgForest;\n        case 'beach':\n            return images.bgBeach;\n        default:\n            throw new Error(`Unsupported bg zone kind: \"${kind}\"`);\n    }\n}\nfunction updateBackgroundOffset({ section, bgOffset, moveOffset, moveOffsetChange, moveSpeed, }) {\n    const entryGap = 200;\n    if (moveSpeed > 0) {\n        const inSectionOffset = moveOffset - section.start;\n        const bgOffsetChange = moveOffsetChange * _config__WEBPACK_IMPORTED_MODULE_0__.BG_SPEED_PER_MOVE_OFFSET;\n        if (section.kind === 'turn-left' && inSectionOffset > entryGap) {\n            return bgOffset - bgOffsetChange;\n        }\n        if (section.kind === 'turn-right' && inSectionOffset > entryGap) {\n            return bgOffset + bgOffsetChange;\n        }\n    }\n    return bgOffset;\n}\n\n\n//# sourceURL=webpack:///./src/background.ts?");

/***/ }),

/***/ "./src/car.ts":
/*!********************!*\
  !*** ./src/car.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MoveAudio\": () => (/* binding */ MoveAudio),\n/* harmony export */   \"defaultMoveSpeedState\": () => (/* binding */ defaultMoveSpeedState),\n/* harmony export */   \"defaultSteerState\": () => (/* binding */ defaultSteerState),\n/* harmony export */   \"drawCar\": () => (/* binding */ drawCar),\n/* harmony export */   \"getCarBox\": () => (/* binding */ getCarBox),\n/* harmony export */   \"updateMoveSpeedState\": () => (/* binding */ updateMoveSpeedState),\n/* harmony export */   \"updateSteerState\": () => (/* binding */ updateSteerState)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\nfunction drawCar(ctx, { images, steerOffset, }) {\n    const image = images.car;\n    const scale = 0.6 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const centerX = (_config__WEBPACK_IMPORTED_MODULE_0__.IW - image.width * scale) / 2;\n    const carSteerOffset = -1 * steerOffset * 0.02;\n    const x = centerX + carSteerOffset;\n    const y = _config__WEBPACK_IMPORTED_MODULE_0__.IH - 70 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    ctx.drawImage(image, x, y, image.width * scale, image.height * scale);\n}\nfunction getCarBox({ images, roadDepth, moveOffset, steerOffset, }) {\n    const image = images.car;\n    const scale = 0.6 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const centerX = (_config__WEBPACK_IMPORTED_MODULE_0__.IW - image.width * scale) / 2;\n    const carSteerOffset = -1 * steerOffset * 0.02;\n    const width = image.width * scale;\n    const height = image.height * scale;\n    const depth = 32;\n    const x = centerX + carSteerOffset;\n    const y = _config__WEBPACK_IMPORTED_MODULE_0__.IH - 70 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const z = 16;\n    return {\n        x,\n        y,\n        z,\n        width,\n        height,\n        depth,\n    };\n}\nconst defaultMoveSpeedState = {\n    moveGear: _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_GEAR_MIN,\n    moveSpeedChange: 0,\n    moveSpeed: 0,\n};\nconst POLE_START = 1000;\nconst POLE_DRIVE = 500;\nconst POLE_FULL_STOP = 100;\nfunction updateMoveSpeedState({ nextPole, moveOffset, isThrottleActive, isReverseActive, moveGear: currentMoveGear, moveSpeedChange: currentMoveSpeedChange, moveSpeed: currentMoveSpeed, }) {\n    let gear = currentMoveGear;\n    let speedChange = currentMoveSpeedChange;\n    let speed = currentMoveSpeed;\n    const gearDesc = _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_GEARS[gear];\n    const toPole = nextPole.start - moveOffset;\n    if (toPole < POLE_START) {\n        speedChange = (speedChange - _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_DECELERATION_FREE) / gearDesc.delim;\n        speed = Math.max(3, speed + speedChange);\n        if (toPole < POLE_DRIVE) {\n            speedChange = 0;\n            speed = 1.5;\n        }\n        if (toPole < POLE_FULL_STOP) {\n            speedChange = -100;\n            speed = Math.max(0, speed + speedChange);\n            setTimeout(() => {\n                nextPole.arrived = true;\n            }, 100);\n        }\n        return {\n            moveGear: gear,\n            moveSpeedChange: speedChange,\n            moveSpeed: speed,\n        };\n    }\n    if (isThrottleActive) {\n        if (speedChange < 0) {\n            speedChange = 0;\n        }\n        speedChange = (speedChange + _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_ACCELERATION) / gearDesc.delim;\n        speed += speedChange;\n    }\n    else {\n        if (speed > 0) {\n            if (isReverseActive) {\n                speedChange =\n                    (speedChange - _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_DECELERATION_REVERSE) / gearDesc.delim;\n                speed = Math.max(0, speed + speedChange);\n            }\n            else {\n                speedChange = (speedChange - _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_DECELERATION_FREE) / gearDesc.delim;\n                speed = Math.max(0, speed + speedChange);\n            }\n        }\n    }\n    if (speed > gearDesc.endAt) {\n        gear = Math.min(gear + 1, _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_GEAR_MAX);\n    }\n    else if (speed < gearDesc.startAt) {\n        gear = Math.max(gear - 1, _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_GEAR_MIN);\n    }\n    speed = Math.min(speed, gearDesc.endAt);\n    return {\n        moveGear: gear,\n        moveSpeedChange: speedChange,\n        moveSpeed: speed,\n    };\n}\nconst defaultSteerState = {\n    steerOffset: 0,\n    steerSpeed: 0,\n};\nconst STEER_REDUCE_TILL_SPEED = 3;\nfunction updateSteerState({ steerOffset: currentSteerOffset, steerSpeed: currentSteerSpeed, section, upgrades, nextPole, isLeftTurnActive, isRightTurnActive, moveSpeed, moveOffset, }) {\n    let steerOffset = currentSteerOffset;\n    let steerSpeed = currentSteerSpeed;\n    const toPole = nextPole.start - moveOffset;\n    if (toPole < POLE_START) {\n        let speed = 2;\n        if (toPole < POLE_DRIVE) {\n            speed = 5;\n        }\n        if (toPole < POLE_FULL_STOP) {\n            speed = 100;\n        }\n        if (steerOffset > 0) {\n            steerSpeed = -speed;\n            steerOffset = Math.max(0, steerOffset + steerSpeed);\n        }\n        if (steerOffset < 0) {\n            steerSpeed = speed;\n            steerOffset = Math.min(0, steerOffset + speed);\n        }\n        return {\n            steerSpeed,\n            steerOffset,\n        };\n    }\n    if (moveSpeed >= 0) {\n        let t = 1;\n        if (moveSpeed < STEER_REDUCE_TILL_SPEED) {\n            t = moveSpeed / STEER_REDUCE_TILL_SPEED;\n        }\n        let baseSteerSpeed = _config__WEBPACK_IMPORTED_MODULE_0__.STEER_SPEED;\n        if (upgrades.some((u) => u.kind === 'improved-steering')) {\n            baseSteerSpeed = _config__WEBPACK_IMPORTED_MODULE_0__.STEER_SPEED_IMPROVED;\n        }\n        const steerSpeed = baseSteerSpeed * t;\n        if (isLeftTurnActive) {\n            steerOffset = Math.min(_config__WEBPACK_IMPORTED_MODULE_0__.STEER_LIMIT, steerOffset + steerSpeed);\n        }\n        else if (isRightTurnActive) {\n            steerOffset = Math.max(-_config__WEBPACK_IMPORTED_MODULE_0__.STEER_LIMIT, steerOffset - steerSpeed);\n        }\n    }\n    else {\n        steerSpeed = 0;\n    }\n    // The faster the car is going - turn will generate more counter-force\n    const turnCounterForce = _config__WEBPACK_IMPORTED_MODULE_0__.STEER_TURN_COUNTER_FORCE * (moveSpeed / _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_SPEED_MAX);\n    if (section.kind === 'turn-left') {\n        steerOffset -= turnCounterForce;\n    }\n    else if (section.kind === 'turn-right') {\n        steerOffset += turnCounterForce;\n    }\n    return {\n        steerSpeed,\n        steerOffset,\n    };\n}\nclass MoveAudio {\n    constructor(audioCtx) {\n        this.isMuted = true;\n        this.osc = audioCtx.createOscillator();\n        this.osc.type = 'sawtooth';\n        const biquadFilter = audioCtx.createBiquadFilter();\n        this.osc.connect(biquadFilter);\n        this.osc.start();\n        biquadFilter.connect(audioCtx.destination);\n    }\n    update({ isMuted, moveSpeed, moveSpeedChange, moveGear, }) {\n        const gear = _config__WEBPACK_IMPORTED_MODULE_0__.MOVE_GEARS[moveGear];\n        const gearT = (moveSpeed - gear.startAt) / (gear.endAt - gear.startAt);\n        let soundStart = 30 + moveGear * 10;\n        let soundEnd = soundStart + moveGear * 15;\n        if (moveSpeedChange < 0) {\n            soundEnd = soundStart + moveGear * 8;\n        }\n        const soundValue = soundStart + (soundEnd - soundStart) * gearT;\n        this.osc.frequency.value = soundValue;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/car.ts?");

/***/ }),

/***/ "./src/collision.ts":
/*!**************************!*\
  !*** ./src/collision.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawCollisionBoxes\": () => (/* binding */ drawCollisionBoxes),\n/* harmony export */   \"findCollisions\": () => (/* binding */ findCollisions)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _stripes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stripes */ \"./src/stripes.ts\");\n\n\nfunction findCollisions(sourceBox, targetBoxes) {\n    const targetIndexes = [];\n    for (let i = 0; i < targetBoxes.length; i++) {\n        const targetBox = targetBoxes[i];\n        const intersects = sourceBox.x < targetBox.x + targetBox.width &&\n            sourceBox.x + sourceBox.width > targetBox.x &&\n            sourceBox.y < targetBox.y + targetBox.height &&\n            sourceBox.y + sourceBox.height > targetBox.y &&\n            sourceBox.z < targetBox.z + targetBox.depth &&\n            sourceBox.z + sourceBox.depth > targetBox.z;\n        if (intersects) {\n            targetIndexes.push(i);\n        }\n    }\n    return targetIndexes;\n}\nfunction drawCollisionBoxes(ctx, collidedBoxes, uncollidedBoxes, { stripes, roadDepth }) {\n    drawBoxes(ctx, uncollidedBoxes, {\n        boxColor: 'lightgreen',\n        depthColor: 'green',\n        stripes,\n        roadDepth,\n    });\n    drawBoxes(ctx, collidedBoxes, {\n        boxColor: 'orange',\n        depthColor: 'red',\n        stripes,\n        roadDepth,\n    });\n}\nfunction drawBoxes(ctx, boxes, { boxColor, depthColor, stripes, roadDepth, }) {\n    for (const box of boxes) {\n        ctx.strokeStyle = boxColor;\n        ctx.strokeRect(box.x, box.y, box.width, box.height);\n        ctx.strokeStyle = depthColor;\n        const zy = (0,_stripes__WEBPACK_IMPORTED_MODULE_1__.stripesToY)(stripes, { inOffset: roadDepth - box.z });\n        if (!zy) {\n            // console.log('zy not found: ', box.z);\n            continue;\n        }\n        const zy2 = (0,_stripes__WEBPACK_IMPORTED_MODULE_1__.stripesToY)(stripes, {\n            inOffset: roadDepth - box.z - box.depth,\n        });\n        if (!zy2) {\n            // console.log('zy2 not found', box.z, box.depth);\n            continue;\n        }\n        const bottomZ = _config__WEBPACK_IMPORTED_MODULE_0__.IH - zy;\n        const topZ = _config__WEBPACK_IMPORTED_MODULE_0__.IH - zy2;\n        const zHeight = bottomZ - topZ;\n        ctx.strokeRect(box.x, topZ, box.width, zHeight);\n    }\n}\n\n\n//# sourceURL=webpack:///./src/collision.ts?");

/***/ }),

/***/ "./src/config.ts":
/*!***********************!*\
  !*** ./src/config.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BG_SPEED_PER_MOVE_OFFSET\": () => (/* binding */ BG_SPEED_PER_MOVE_OFFSET),\n/* harmony export */   \"BH\": () => (/* binding */ BH),\n/* harmony export */   \"BW\": () => (/* binding */ BW),\n/* harmony export */   \"HH\": () => (/* binding */ HH),\n/* harmony export */   \"HW\": () => (/* binding */ HW),\n/* harmony export */   \"IH\": () => (/* binding */ IH),\n/* harmony export */   \"IW\": () => (/* binding */ IW),\n/* harmony export */   \"MOVE_ACCELERATION\": () => (/* binding */ MOVE_ACCELERATION),\n/* harmony export */   \"MOVE_DECELERATION_FREE\": () => (/* binding */ MOVE_DECELERATION_FREE),\n/* harmony export */   \"MOVE_DECELERATION_REVERSE\": () => (/* binding */ MOVE_DECELERATION_REVERSE),\n/* harmony export */   \"MOVE_GEARS\": () => (/* binding */ MOVE_GEARS),\n/* harmony export */   \"MOVE_GEAR_MAX\": () => (/* binding */ MOVE_GEAR_MAX),\n/* harmony export */   \"MOVE_GEAR_MIN\": () => (/* binding */ MOVE_GEAR_MIN),\n/* harmony export */   \"MOVE_SPEED\": () => (/* binding */ MOVE_SPEED),\n/* harmony export */   \"MOVE_SPEED_MAX\": () => (/* binding */ MOVE_SPEED_MAX),\n/* harmony export */   \"RENDER_SCALE\": () => (/* binding */ RENDER_SCALE),\n/* harmony export */   \"RS\": () => (/* binding */ RS),\n/* harmony export */   \"STEER_LIMIT\": () => (/* binding */ STEER_LIMIT),\n/* harmony export */   \"STEER_SPEED\": () => (/* binding */ STEER_SPEED),\n/* harmony export */   \"STEER_SPEED_IMPROVED\": () => (/* binding */ STEER_SPEED_IMPROVED),\n/* harmony export */   \"STEER_TURN_COUNTER_FORCE\": () => (/* binding */ STEER_TURN_COUNTER_FORCE)\n/* harmony export */ });\nconst RENDER_SCALE = 1;\nconst RS = RENDER_SCALE;\nconst BW = 380 * RENDER_SCALE;\nconst BH = 200 * RENDER_SCALE;\nconst IW = BW;\nconst IH = BH;\nconst HW = IW / 2; // half = 190\nconst HH = IH / 2; // half = 100\nconst STEER_LIMIT = Infinity;\nconst STEER_TURN_COUNTER_FORCE = 4 * RS;\nconst MOVE_SPEED = 4 * RS;\nconst STEER_SPEED = 5 * RS;\nconst STEER_SPEED_IMPROVED = 8 * RS;\nconst BG_SPEED_PER_MOVE_OFFSET = 0.4;\nconst MOVE_ACCELERATION = 0.03;\nconst MOVE_DECELERATION_FREE = 0.05;\nconst MOVE_DECELERATION_REVERSE = 0.1;\nconst MOVE_SPEED_MAX = 8;\nconst MOVE_GEARS = {\n    1: { delim: 4, startAt: 0, endAt: 1.1 },\n    2: { delim: 5, startAt: 1, endAt: 2.6 },\n    3: { delim: 6, startAt: 2.5, endAt: 4.1 },\n    4: { delim: 7, startAt: 4, endAt: 6.1 },\n    5: { delim: 8, startAt: 6, endAt: MOVE_SPEED_MAX },\n};\n// export\nconst MOVE_GEAR_MIN = Number(Object.keys(MOVE_GEARS).shift());\nconst MOVE_GEAR_MAX = Number(Object.keys(MOVE_GEARS).pop());\n\n\n//# sourceURL=webpack:///./src/config.ts?");

/***/ }),

/***/ "./src/controls.ts":
/*!*************************!*\
  !*** ./src/controls.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InputControl\": () => (/* binding */ InputControl),\n/* harmony export */   \"KeyboardListener\": () => (/* binding */ KeyboardListener),\n/* harmony export */   \"listenKeyboard\": () => (/* binding */ listenKeyboard)\n/* harmony export */ });\nvar KeyboardButtonCode;\n(function (KeyboardButtonCode) {\n    KeyboardButtonCode[KeyboardButtonCode[\"Enter\"] = 13] = \"Enter\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Space\"] = 32] = \"Space\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Left\"] = 37] = \"Left\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Up\"] = 38] = \"Up\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Right\"] = 39] = \"Right\";\n    KeyboardButtonCode[KeyboardButtonCode[\"Down\"] = 40] = \"Down\";\n    KeyboardButtonCode[KeyboardButtonCode[\"W\"] = 87] = \"W\";\n    KeyboardButtonCode[KeyboardButtonCode[\"A\"] = 65] = \"A\";\n    KeyboardButtonCode[KeyboardButtonCode[\"D\"] = 68] = \"D\";\n    KeyboardButtonCode[KeyboardButtonCode[\"S\"] = 83] = \"S\";\n})(KeyboardButtonCode || (KeyboardButtonCode = {}));\nvar InputControl;\n(function (InputControl) {\n    InputControl[InputControl[\"Up\"] = 0] = \"Up\";\n    InputControl[InputControl[\"Down\"] = 1] = \"Down\";\n    InputControl[InputControl[\"Left\"] = 2] = \"Left\";\n    InputControl[InputControl[\"Right\"] = 3] = \"Right\";\n    InputControl[InputControl[\"Select\"] = 4] = \"Select\";\n})(InputControl || (InputControl = {}));\nconst binding = {\n    [InputControl.Up]: [KeyboardButtonCode.Up, KeyboardButtonCode.W],\n    [InputControl.Down]: [KeyboardButtonCode.Down, KeyboardButtonCode.S],\n    [InputControl.Left]: [KeyboardButtonCode.Left, KeyboardButtonCode.A],\n    [InputControl.Right]: [KeyboardButtonCode.Right, KeyboardButtonCode.D],\n    [InputControl.Select]: [KeyboardButtonCode.Enter, KeyboardButtonCode.Space],\n};\nclass KeyboardListener {\n    constructor() {\n        this.listenedDownCodes = [];\n        this.downCodes = [];\n        this.holdCodes = [];\n        this.upCodes = [];\n        this.handleWindowKeyDown = (ev) => {\n            const { keyCode } = ev;\n            if (!this.listenedDownCodes.includes(keyCode)) {\n                this.listenedDownCodes.push(keyCode);\n            }\n        };\n        this.handleWindowKeyUp = (ev) => {\n            const { keyCode } = ev;\n            const index = this.listenedDownCodes.indexOf(keyCode);\n            if (index !== -1) {\n                this.listenedDownCodes.splice(index, 1);\n            }\n        };\n        this.handleWindowBlur = () => {\n            this.listenedDownCodes = [];\n        };\n    }\n    listen() {\n        document.addEventListener('keydown', this.handleWindowKeyDown);\n        document.addEventListener('keyup', this.handleWindowKeyUp);\n        window.addEventListener('blur', this.handleWindowBlur);\n    }\n    unlisten() {\n        document.removeEventListener('keydown', this.handleWindowKeyDown);\n        document.removeEventListener('keyup', this.handleWindowKeyUp);\n        window.removeEventListener('blur', this.handleWindowBlur);\n    }\n    update() {\n        const codes = this.listenedDownCodes;\n        const downCodes = [];\n        const holdCodes = [];\n        for (const code of codes) {\n            // Newly pressed key, which was not previously down or hold\n            if (!this.downCodes.includes(code) && !this.holdCodes.includes(code)) {\n                downCodes.push(code);\n            }\n            // Key that was down on previous frame is now considered hold, because\n            // it is still down on current frame.\n            // Hold key continues to be hold.\n            if (this.downCodes.includes(code) || this.holdCodes.includes(code)) {\n                holdCodes.push(code);\n            }\n        }\n        // Find keycodes that were down or hold on previous frame, which means\n        // that in current frame they are considered up\n        const upCodes = [];\n        for (const code of this.downCodes) {\n            if (!codes.includes(code)) {\n                upCodes.push(code);\n            }\n        }\n        for (const code of this.holdCodes) {\n            if (!codes.includes(code)) {\n                upCodes.push(code);\n            }\n        }\n        this.downCodes = downCodes;\n        this.holdCodes = holdCodes;\n        this.upCodes = upCodes;\n    }\n    isDown(control) {\n        const codes = binding[control];\n        return codes.some((code) => this.downCodes.includes(code));\n    }\n    isHold(control) {\n        const codes = binding[control];\n        return codes.some((code) => this.holdCodes.includes(code));\n    }\n    getHoldLastOf(controls) {\n        let latestIndex = -1;\n        let latestControl = undefined;\n        for (const control of controls) {\n            const codes = binding[control];\n            for (const code of codes) {\n                const codeIndex = this.holdCodes.indexOf(code);\n                if (codeIndex !== -1 && codeIndex > latestIndex) {\n                    latestIndex = codeIndex;\n                    latestControl = control;\n                }\n            }\n        }\n        return latestControl;\n    }\n}\nfunction listenKeyboard() {\n    const listener = new KeyboardListener();\n    listener.listen();\n    return listener;\n}\n\n\n//# sourceURL=webpack:///./src/controls.ts?");

/***/ }),

/***/ "./src/curve.ts":
/*!**********************!*\
  !*** ./src/curve.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DEFAULT_BOTTOM_DELTA\": () => (/* binding */ DEFAULT_BOTTOM_DELTA),\n/* harmony export */   \"DEFAULT_BOTTOM_LEFT_X\": () => (/* binding */ DEFAULT_BOTTOM_LEFT_X),\n/* harmony export */   \"DEFAULT_BOTTOM_RIGHT_X\": () => (/* binding */ DEFAULT_BOTTOM_RIGHT_X),\n/* harmony export */   \"curveXByY\": () => (/* binding */ curveXByY),\n/* harmony export */   \"drawCurve\": () => (/* binding */ drawCurve),\n/* harmony export */   \"leftRoadCurve\": () => (/* binding */ leftRoadCurve),\n/* harmony export */   \"lerpCurve\": () => (/* binding */ lerpCurve),\n/* harmony export */   \"pointOnCurve\": () => (/* binding */ pointOnCurve),\n/* harmony export */   \"rightRoadCurve\": () => (/* binding */ rightRoadCurve),\n/* harmony export */   \"steerCurve\": () => (/* binding */ steerCurve),\n/* harmony export */   \"translateCurve\": () => (/* binding */ translateCurve),\n/* harmony export */   \"translateCurveUniform\": () => (/* binding */ translateCurveUniform)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\n// Line equation:\n// left: 5x + 18y = 2700\n// right: 18 y - 5 x = 800\nconst DEFAULT_BOTTOM_DELTA = 180 * _config__WEBPACK_IMPORTED_MODULE_0__.RENDER_SCALE;\nconst DEFAULT_BOTTOM_LEFT_X = -DEFAULT_BOTTOM_DELTA;\nconst DEFAULT_BOTTOM_RIGHT_X = _config__WEBPACK_IMPORTED_MODULE_0__.IW + DEFAULT_BOTTOM_DELTA;\nfunction leftRoadCurve(controlX, controlY, topX, topY, bottomX = DEFAULT_BOTTOM_LEFT_X, bottomY = _config__WEBPACK_IMPORTED_MODULE_0__.IH) {\n    return { controlX, controlY, topX, topY, bottomX, bottomY };\n}\nfunction rightRoadCurve(controlX, controlY, topX, topY, bottomX = DEFAULT_BOTTOM_RIGHT_X, bottomY = _config__WEBPACK_IMPORTED_MODULE_0__.IH) {\n    return { controlX, controlY, topX, topY, bottomX, bottomY };\n}\nfunction translateCurveUniform(c, offset) {\n    return translateCurve(c, { control: offset, top: offset, bottom: offset });\n}\nfunction translateCurve(c, { control = 0, top = 0, bottom = 0, }) {\n    return Object.assign(Object.assign({}, c), { controlX: c.controlX + control, topX: c.topX + top, bottomX: c.bottomX + bottom });\n}\nfunction steerCurve(curve, { steerOffset }) {\n    const adjustedSteerOffset = steerOffset * 1;\n    return Object.assign(Object.assign({}, curve), { bottomX: curve.bottomX + adjustedSteerOffset });\n}\nfunction lerpCurve(c1, c2, t) {\n    console.assert(t >= 0 && t <= 1, 'd must be normalized: %d', t);\n    const controlX = c1.controlX + (c2.controlX - c1.controlX) * t;\n    const controlY = c1.controlY + (c2.controlY - c1.controlY) * t;\n    const topX = c1.topX + (c2.topX - c1.topX) * t;\n    const topY = c1.topY + (c2.topY - c1.topY) * t;\n    const bottomX = c1.bottomX + (c2.bottomX - c1.bottomX) * t;\n    const bottomY = c1.bottomY + (c2.bottomY - c1.bottomY) * t;\n    return {\n        controlX,\n        controlY,\n        topX,\n        topY,\n        bottomX,\n        bottomY,\n    };\n}\n// https://stackoverflow.com/a/5634528/1573638\nfunction pointOnCurve(curve, t) {\n    console.assert(t >= 0 && t <= 1, 't must be normalized: %d', t);\n    const x = (1 - t) * (1 - t) * curve.bottomX +\n        2 * (1 - t) * t * curve.controlX +\n        t * t * curve.topX;\n    const y = (1 - t) * (1 - t) * curve.bottomY +\n        2 * (1 - t) * t * curve.controlY +\n        t * t * curve.topY;\n    return { x, y };\n}\nfunction curveXByY(curve, y) {\n    // TODO: optimize: binary search? lut?\n    for (let t = 0; t <= 1; t += 0.01) {\n        const p = pointOnCurve(curve, t);\n        if (Math.abs(p.y - y) <= 1) {\n            return p.x;\n        }\n    }\n    return undefined;\n}\nfunction drawCurve(ctx, originalCurve, { moveOffset, steerOffset, color = 'orange', dashPattern, }) {\n    ctx.strokeStyle = color;\n    if (dashPattern) {\n        ctx.setLineDash(dashPattern);\n    }\n    ctx.lineDashOffset = moveOffset;\n    const curve = steerCurve(originalCurve, {\n        steerOffset,\n    });\n    ctx.beginPath();\n    ctx.moveTo(curve.bottomX, curve.bottomY);\n    ctx.quadraticCurveTo(curve.controlX, curve.controlY, curve.topX, curve.topY);\n    ctx.stroke();\n}\n\n\n//# sourceURL=webpack:///./src/curve.ts?");

/***/ }),

/***/ "./src/debug.ts":
/*!**********************!*\
  !*** ./src/debug.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawDebug\": () => (/* binding */ drawDebug),\n/* harmony export */   \"drawGrid\": () => (/* binding */ drawGrid),\n/* harmony export */   \"drawHorizon\": () => (/* binding */ drawHorizon),\n/* harmony export */   \"logClientCoordsOnClick\": () => (/* binding */ logClientCoordsOnClick)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\nfunction drawDebug(ctx, { section, bgOffset, steerOffset, moveOffset, moveSpeed, moveSpeedChange, moveGear, upgrades, }) {\n    ctx.setLineDash([]);\n    ctx.strokeStyle = '#000';\n    ctx.font = '8px serif';\n    ctx.lineWidth = 1;\n    ctx.strokeText(`section kind: ${section.kind}`, 5, 10);\n    ctx.strokeText(`bg: ${bgOffset.toFixed(5)}`, 5, 20);\n    ctx.strokeText(`steer: ${steerOffset.toFixed(5)}`, 5, 30);\n    ctx.strokeText(`move offset: ${moveOffset.toFixed(5)}`, 5, 40);\n    ctx.strokeText(`move speed: ${moveSpeed.toFixed(5)}`, 5, 50);\n    ctx.strokeText(`move speed change: ${moveSpeedChange.toFixed(5)}`, 5, 60);\n    ctx.strokeText(`move gear: ${moveGear}`, 5, 70);\n    // ctx.strokeText(\n    //   'upgrades: [' + upgrades.map((u) => u.kind).join() + ']',\n    //   5,\n    //   80,\n    // );\n}\nfunction drawHorizon(ctx, { yOverride } = {}) {\n    ctx.strokeStyle = 'green';\n    ctx.lineWidth = 1;\n    ctx.setLineDash([]);\n    ctx.beginPath();\n    ctx.moveTo(0, yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    ctx.lineTo(_config__WEBPACK_IMPORTED_MODULE_0__.IW, yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    ctx.stroke();\n}\nfunction drawGrid(ctx) {\n    ctx.setLineDash([]);\n    ctx.strokeStyle = '#cccccc77';\n    ctx.moveTo(_config__WEBPACK_IMPORTED_MODULE_0__.HW, 0);\n    ctx.lineTo(_config__WEBPACK_IMPORTED_MODULE_0__.HW, _config__WEBPACK_IMPORTED_MODULE_0__.IH);\n    ctx.stroke();\n}\nfunction logClientCoordsOnClick(canvas) {\n    canvas.addEventListener('click', (ev) => {\n        console.log(ev.clientX / 2, ev.clientY / 2);\n    });\n}\n\n\n//# sourceURL=webpack:///./src/debug.ts?");

/***/ }),

/***/ "./src/decor.ts":
/*!**********************!*\
  !*** ./src/decor.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawDecors\": () => (/* binding */ drawDecors),\n/* harmony export */   \"generateDecors\": () => (/* binding */ generateDecors),\n/* harmony export */   \"generateDecorsForZones\": () => (/* binding */ generateDecorsForZones)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve */ \"./src/curve.ts\");\n/* harmony import */ var _road__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./road */ \"./src/road.ts\");\n/* harmony import */ var _stripes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stripes */ \"./src/stripes.ts\");\n/* harmony import */ var _random__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./random */ \"./src/random.ts\");\n\n\n\n\n\n// TODO: they disappear when the bottom of the image hits the bottom of the screen\n//   -> better top of the image hits the bottom of the screen\n// TODO: variation in sizes\n// TODO: z-index with the car?\n// TODO: add preshow too?\nfunction drawDecors(ctx, { decors, images, path, section, moveOffset, steerOffset, yOverride, }) {\n    var _a;\n    let roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.IH - (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    // Not using yOverride because it will re-create the stripes when the road\n    // is transitioning from straight to uphill/downhill.\n    if (section.kind === 'uphill') {\n        roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n    }\n    else if (section.kind === 'downhill') {\n        roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.HH + section.steepness;\n    }\n    const stripes = (0,_stripes__WEBPACK_IMPORTED_MODULE_3__.generateStripes)({ roadHeight });\n    const travelDistance = (0,_stripes__WEBPACK_IMPORTED_MODULE_3__.stripesUnscaledHeight)(stripes);\n    let preshowSize = 200;\n    for (const decor of decors) {\n        // Offset appearance so that decor positioned at 0 in the map is actually\n        // rendered visually at 0 right from the start.\n        const appearStart = decor.start - travelDistance;\n        const appearEnd = decor.start;\n        const preshowAppearStart = appearStart - preshowSize;\n        if (moveOffset >= preshowAppearStart && moveOffset <= appearEnd) {\n            const isPreshow = moveOffset < appearStart;\n            const curbPath = (0,_road__WEBPACK_IMPORTED_MODULE_2__.getCurbPath)(path, { steerOffset });\n            const sourceCurve = decor.placement === 'right' ? curbPath.right : curbPath.left;\n            const placementSign = decor.placement === 'right' ? 1 : -1;\n            const decorCurve = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.translateCurve)(sourceCurve, {\n                top: 5 * placementSign,\n                control: 10 * placementSign,\n                bottom: 20 * placementSign,\n            });\n            const driftedCurve = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.translateCurveUniform)(decorCurve, ((_a = decor.driftOffset) !== null && _a !== void 0 ? _a : 0) * placementSign);\n            let inOffset = moveOffset - decor.start + travelDistance;\n            if (isPreshow) {\n                inOffset = 1;\n            }\n            const stripesY = (0,_stripes__WEBPACK_IMPORTED_MODULE_3__.stripesToY)(stripes, { inOffset });\n            if (stripesY === undefined) {\n                continue;\n            }\n            const decorY = _config__WEBPACK_IMPORTED_MODULE_0__.IH - stripesY;\n            const decorX = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.curveXByY)((0,_curve__WEBPACK_IMPORTED_MODULE_1__.steerCurve)(driftedCurve, { steerOffset }), decorY);\n            if (decorX === undefined) {\n                continue;\n            }\n            let inHalfHeightT = stripesY / _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n            let imageScale = Math.max(0, 1 - (1 - 0.1 * _config__WEBPACK_IMPORTED_MODULE_0__.RENDER_SCALE) * inHalfHeightT);\n            let imageOpacity = 1;\n            if (roadHeight > _config__WEBPACK_IMPORTED_MODULE_0__.HH && decorY < _config__WEBPACK_IMPORTED_MODULE_0__.HH) {\n                const inOverHeightT = Math.max(0, 1 - (_config__WEBPACK_IMPORTED_MODULE_0__.HH - decorY) / (roadHeight - _config__WEBPACK_IMPORTED_MODULE_0__.HH));\n                imageScale = 0.1 * inOverHeightT;\n            }\n            else if (isPreshow) {\n                imageScale *= 1 - (appearStart - moveOffset) / preshowSize;\n                imageOpacity = 1 - (appearStart - moveOffset) / preshowSize;\n            }\n            const image = imageByKind(images, decor.kind);\n            const imageWidth = image.width * imageScale;\n            const imageHeight = image.height * imageScale;\n            const imageX = decor.placement === 'right' ? decorX : decorX - imageWidth;\n            const imageY = decorY - imageHeight;\n            ctx.globalAlpha = imageOpacity;\n            ctx.drawImage(image, imageX, imageY, imageWidth, imageHeight);\n            ctx.globalAlpha = 1;\n        }\n    }\n}\nfunction imageByKind(images, kind) {\n    switch (kind) {\n        case 'green-bush':\n            return images.decorGreenBush;\n        case 'green-tree':\n            return images.decorGreenTree;\n        case 'green-rock':\n            return images.decorGreenRock;\n        case 'desert-cactus':\n            return images.decorDesertCactus;\n        case 'desert-sand':\n            return images.decorDesertSand;\n        case 'desert-bush':\n            return images.decorDesertBush;\n        case 'forest-tree':\n            return images.decorForestTree;\n        case 'forest-spruce':\n            return images.decorForestSpruce;\n        case 'beach-buoy':\n            return images.decorBeachBuoy;\n        default:\n            throw new Error(`Unsupported decor kind: \"${kind}\"`);\n    }\n}\nfunction generateDecors({ startOffset, size, amount = 0, driftMax = 50, kinds = ['green-bush', 'green-rock', 'green-tree'], }) {\n    const decors = [];\n    if (size === 0 || amount === 0) {\n        return decors;\n    }\n    const areaSize = size / amount;\n    // Go reverse to have the farthest decors in the array first, which means the\n    // closest will be rendered last, which is better for zindex.\n    for (let i = amount - 1; i >= 0; i--) {\n        const areaStart = i * areaSize;\n        const inAreaOffset = (0,_random__WEBPACK_IMPORTED_MODULE_4__.randomNumber)(0, areaSize);\n        const start = startOffset + areaStart + inAreaOffset;\n        const kind = (0,_random__WEBPACK_IMPORTED_MODULE_4__.randomElement)(kinds);\n        const driftOffset = (0,_random__WEBPACK_IMPORTED_MODULE_4__.randomNumber)(0, driftMax);\n        const placement = (0,_random__WEBPACK_IMPORTED_MODULE_4__.randomElement)(['left', 'right']);\n        decors.push({\n            start,\n            kind,\n            placement,\n            driftOffset,\n        });\n    }\n    return decors;\n}\nconst KINDS_BY_ZONE = new Map();\nKINDS_BY_ZONE.set('green', ['green-bush', 'green-rock', 'green-tree']);\nKINDS_BY_ZONE.set('desert', ['desert-cactus', 'desert-bush', 'desert-sand']);\nKINDS_BY_ZONE.set('forest', ['forest-tree', 'forest-spruce']);\nKINDS_BY_ZONE.set('beach', ['beach-buoy']);\nfunction generateDecorsForZones({ zones }) {\n    var _a;\n    const decors = [];\n    for (let i = 0; i < zones.length; i++) {\n        const zone = zones[i];\n        const nextZone = zones[i + 1];\n        const zoneDecors = generateDecors({\n            startOffset: zone.start,\n            size: nextZone ? nextZone.start - zone.start : 0,\n            amount: (_a = zone.decorAmount) !== null && _a !== void 0 ? _a : 0,\n            kinds: KINDS_BY_ZONE.get(zone.kind),\n        });\n        decors.push(...zoneDecors);\n    }\n    return decors;\n}\n\n\n//# sourceURL=webpack:///./src/decor.ts?");

/***/ }),

/***/ "./src/fragment.ts":
/*!*************************!*\
  !*** ./src/fragment.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createDownhill\": () => (/* binding */ createDownhill),\n/* harmony export */   \"createTurn\": () => (/* binding */ createTurn),\n/* harmony export */   \"createUphill\": () => (/* binding */ createUphill),\n/* harmony export */   \"lerpFragments\": () => (/* binding */ lerpFragments),\n/* harmony export */   \"straightFragment\": () => (/* binding */ straightFragment)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve */ \"./src/curve.ts\");\n/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path */ \"./src/path.ts\");\n\n\n\nconst straightFragment = {\n    left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n    right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n    end: 0,\n};\nfunction createDownhill({ size, steepness, inOffset, steerOffset, }) {\n    const halfSize = size / 2;\n    const d = 1 - Math.abs((inOffset - halfSize) / halfSize);\n    const yOffset = -steepness * d;\n    const y = _config__WEBPACK_IMPORTED_MODULE_0__.HH + yOffset;\n    const minY = _config__WEBPACK_IMPORTED_MODULE_0__.HH - steepness;\n    let fragments = [\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 10, y),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 10, y),\n            end: 100 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 25, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 25, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 10, minY),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 25, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 25, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 10, minY),\n            end: 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 25, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 15, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 10, minY),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 25, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 15, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 10, minY),\n            end: size - 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        Object.assign(Object.assign({}, straightFragment), { end: size }),\n    ];\n    fragments = steerFragments(fragments, steerOffset);\n    return fragments;\n}\nfunction createUphill({ size, steepness, inOffset, steerOffset, }) {\n    const halfSize = size / 2;\n    const d = 1 - Math.abs((inOffset - halfSize) / halfSize);\n    const yOffset = steepness * d;\n    const y = _config__WEBPACK_IMPORTED_MODULE_0__.HH + yOffset;\n    const maxY = _config__WEBPACK_IMPORTED_MODULE_0__.HH + steepness;\n    const xCorrection = steerOffset * 0.15;\n    const bottomLeftCorrection = steerOffset * 0.1;\n    const cxCorrection = steerOffset * 0.2;\n    let fragments = [\n        // {\n        //   left: leftRoadCurve(\n        //     HW - 70,\n        //     y - 5,\n        //     HW - 60 + xCorrection,\n        //     y,\n        //     -180 - bottomLeftCorrection,\n        //   ),\n        //   right: rightRoadCurve(\n        //     HW + 70,\n        //     y - 5,\n        //     HW + 60 + xCorrection,\n        //     y,\n        //     560 - bottomLeftCorrection,\n        //   ),\n        //   end: 300,\n        // },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 120 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + cxCorrection, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 90 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + xCorrection, maxY, _curve__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_BOTTOM_LEFT_X - bottomLeftCorrection),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 120 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + cxCorrection, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 90 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + xCorrection, maxY, _curve__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_BOTTOM_RIGHT_X - bottomLeftCorrection),\n            end: 400 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 120 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + cxCorrection, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW - 90 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + xCorrection, maxY, _curve__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_BOTTOM_LEFT_X - bottomLeftCorrection),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 120 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + cxCorrection, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 90 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + xCorrection, maxY, _curve__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_BOTTOM_RIGHT_X - bottomLeftCorrection),\n            end: size - 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        Object.assign(Object.assign({}, straightFragment), { end: size }),\n    ];\n    fragments = steerFragments(fragments, steerOffset);\n    return fragments;\n}\nfunction createTurn({ size, direction, steerOffset, }) {\n    console.assert(size >= 600 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, 'turn too quick: %d', size);\n    let fragments = [\n        // {\n        //   left: [HW - 10, HH - 5, HW - 10, HH],\n        //   right: [HW + 190, HH + 50, HW + 10, HH],\n        //   end: 100,\n        // },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH - 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            end: 100 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 50 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH - 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 115 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 15 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 115 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            end: 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH - 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 80 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 15 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 115 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            end: size - 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        {\n            left: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.leftRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW - 30 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH - 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 60 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            right: (0,_curve__WEBPACK_IMPORTED_MODULE_1__.rightRoadCurve)(_config__WEBPACK_IMPORTED_MODULE_0__.HW + 0 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH + 20 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HW + 80 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, _config__WEBPACK_IMPORTED_MODULE_0__.HH),\n            end: size - 100 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        },\n        Object.assign(Object.assign({}, straightFragment), { end: size }),\n    ];\n    if (direction === 'left') {\n        fragments = mirrorFragments(fragments);\n    }\n    fragments = steerFragments(fragments, steerOffset);\n    return fragments;\n}\nfunction mirrorFragments(fragments) {\n    return fragments.map((fragment) => {\n        const { left, right } = fragment;\n        return Object.assign(Object.assign({}, fragment), { left: Object.assign(Object.assign({}, left), { controlX: _config__WEBPACK_IMPORTED_MODULE_0__.HW + (_config__WEBPACK_IMPORTED_MODULE_0__.HW - right.controlX), controlY: right.controlY, topX: _config__WEBPACK_IMPORTED_MODULE_0__.HW + (_config__WEBPACK_IMPORTED_MODULE_0__.HW - right.topX), topY: right.topY }), right: Object.assign(Object.assign({}, right), { controlX: _config__WEBPACK_IMPORTED_MODULE_0__.HW + (_config__WEBPACK_IMPORTED_MODULE_0__.HW - left.controlX), controlY: left.controlY, topX: _config__WEBPACK_IMPORTED_MODULE_0__.HW + (_config__WEBPACK_IMPORTED_MODULE_0__.HW - left.topX), topY: left.topY }) });\n    });\n}\nfunction steerFragments(fragments, steerOffset) {\n    const topOffset = steerOffset * 0.01;\n    return fragments.map((fragment) => {\n        const { left, right } = fragment;\n        return Object.assign(Object.assign({}, fragment), { left: Object.assign(Object.assign({}, left), { controlX: left.controlX + topOffset, topX: left.topX + topOffset }), right: Object.assign(Object.assign({}, right), { controlX: right.controlX + topOffset, topX: right.topX + topOffset }) });\n    });\n}\nfunction lerpFragments({ fragments, inOffset, }) {\n    const activeIndex = fragments.findIndex((fragment) => {\n        return inOffset < fragment.end;\n    });\n    const prevIndex = activeIndex !== -1 ? activeIndex - 1 : -1;\n    const prevFragment = fragments[prevIndex] || straightFragment;\n    const activeFragment = fragments[activeIndex] || straightFragment;\n    let d = 0;\n    const fragmentSize = activeFragment.end - prevFragment.end;\n    const inFragmentOffset = inOffset - prevFragment.end;\n    if (fragmentSize !== 0) {\n        d = inFragmentOffset / fragmentSize;\n    }\n    const path = (0,_path__WEBPACK_IMPORTED_MODULE_2__.lerpPath)(prevFragment, activeFragment, d);\n    return path;\n}\n\n\n//# sourceURL=webpack:///./src/fragment.ts?");

/***/ }),

/***/ "./src/images.ts":
/*!***********************!*\
  !*** ./src/images.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"loadImages\": () => (/* binding */ loadImages)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction loadImages() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return {\n            car: yield loadImage('data/graphics/car.png'),\n            // Backgrounds\n            bgDebug: yield loadImage('data/graphics/bg-debug.png'),\n            bgGreen: yield loadImage('data/graphics/bg-green.png'),\n            bgDesert: yield loadImage('data/graphics/bg-desert.png'),\n            bgForest: yield loadImage('data/graphics/bg-forest.png'),\n            bgBeach: yield loadImage('data/graphics/bg-beach.png'),\n            // Decor - green\n            decorGreenBush: yield loadImage('data/graphics/decor-green-bush.png'),\n            decorGreenTree: yield loadImage('data/graphics/decor-green-tree.png'),\n            decorGreenRock: yield loadImage('data/graphics/decor-green-rock.png'),\n            // Decor - desert\n            decorDesertCactus: yield loadImage('data/graphics/decor-desert-cactus.png'),\n            decorDesertSand: yield loadImage('data/graphics/decor-desert-sand.png'),\n            decorDesertBush: yield loadImage('data/graphics/decor-desert-bush.png'),\n            // Decor - forest\n            decorForestTree: yield loadImage('data/graphics/decor-forest-tree.png'),\n            decorForestSpruce: yield loadImage('data/graphics/decor-forest-spruce.png'),\n            // Decor - beach\n            decorBeachBuoy: yield loadImage('data/graphics/decor-beach-buoy.png'),\n            // Upgrades\n            upgrades: yield loadImage('data/graphics/upgrades.png'),\n            // Poles\n            poleRed: yield loadImage('data/graphics/pole-red.png'),\n            poleGreen: yield loadImage('data/graphics/pole-green.png'),\n            poleEnergy: yield loadImage('data/graphics/pole-energy.png'),\n        };\n    });\n}\nfunction loadImage(imagePath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve) => {\n            const image = new Image();\n            image.src = imagePath;\n            image.addEventListener('load', () => {\n                resolve(image);\n            });\n        });\n    });\n}\n\n\n//# sourceURL=webpack:///./src/images.ts?");

/***/ }),

/***/ "./src/loop.ts":
/*!*********************!*\
  !*** ./src/loop.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GameLoop\": () => (/* binding */ GameLoop)\n/* harmony export */ });\nconst DEFAULT_OPTIONS = {\n    deltaTimeLimit: 1,\n    // requestAnimationFrame is usually 60 fps; in seconds\n    fps: 60,\n};\nvar State;\n(function (State) {\n    State[State[\"Idle\"] = 0] = \"Idle\";\n    State[State[\"Working\"] = 1] = \"Working\";\n    State[State[\"StopRequested\"] = 2] = \"StopRequested\";\n})(State || (State = {}));\nclass GameLoop {\n    constructor(options = {}) {\n        this.lastTimestamp = null;\n        this.requestedStop = false;\n        this.state = State.Idle;\n        this.loop = (timestamp = null) => {\n            var _a, _b;\n            if (this.state === State.Idle) {\n                return;\n            }\n            if (this.state === State.StopRequested) {\n                this.state = State.Idle;\n                return;\n            }\n            const idealDeltaTime = this.getIdealDeltaTime();\n            // For the very first run loop() is called from the code and timestamp is\n            // not known. On the second call loop() is called by requestAnimationFrame,\n            // which also provides a timestamp.\n            // Use ideal fixed delta value for the first run.\n            let deltaTime = idealDeltaTime;\n            if (timestamp !== null) {\n                // Timestamp is originally in milliseconds, convert to seconds\n                deltaTime = (timestamp - this.lastTimestamp) / 1000;\n                // If delta is too large, we must have resumed from stop() or breakpoint.\n                // Use ideal default delta only for this frame.\n                if (deltaTime > this.options.deltaTimeLimit) {\n                    deltaTime = idealDeltaTime;\n                }\n            }\n            this.lastTimestamp = timestamp;\n            (_b = (_a = this.options).onTick) === null || _b === void 0 ? void 0 : _b.call(_a, { deltaTime });\n            window.requestAnimationFrame(this.loop);\n        };\n        this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n    }\n    start() {\n        if (this.state !== State.Idle) {\n            return;\n        }\n        this.state = State.Working;\n        this.loop();\n    }\n    // WARNING: a couple of already queued callbacks might still fire after stop\n    stop() {\n        if (this.state !== State.Working) {\n            return;\n        }\n        this.state = State.StopRequested;\n    }\n    // For manual stepping over frames when loop is paused\n    next(ticks = 1) {\n        var _a, _b;\n        for (let i = 0; i < ticks; i += 1) {\n            (_b = (_a = this.options).onTick) === null || _b === void 0 ? void 0 : _b.call(_a, { deltaTime: this.getIdealDeltaTime() });\n        }\n    }\n    getIdealDeltaTime() {\n        return 1 / this.options.fps;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/loop.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _car__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./car */ \"./src/car.ts\");\n/* harmony import */ var _collision__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./collision */ \"./src/collision.ts\");\n/* harmony import */ var _controls__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./controls */ \"./src/controls.ts\");\n/* harmony import */ var _background__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./background */ \"./src/background.ts\");\n/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./debug */ \"./src/debug.ts\");\n/* harmony import */ var _decor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./decor */ \"./src/decor.ts\");\n/* harmony import */ var _images__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./images */ \"./src/images.ts\");\n/* harmony import */ var _loop__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./loop */ \"./src/loop.ts\");\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./map */ \"./src/map.ts\");\n/* harmony import */ var _pole__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./pole */ \"./src/pole.ts\");\n/* harmony import */ var _prop__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./prop */ \"./src/prop.ts\");\n/* harmony import */ var _road__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./road */ \"./src/road.ts\");\n/* harmony import */ var _section__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./section */ \"./src/section.ts\");\n/* harmony import */ var _stripes__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./stripes */ \"./src/stripes.ts\");\n/* harmony import */ var _zone__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./zone */ \"./src/zone.ts\");\n/* harmony import */ var _upgrade__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./upgrade */ \"./src/upgrade.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst canvas = document.querySelector('canvas');\nconst ctx = canvas.getContext('2d');\ncanvas.width = _config__WEBPACK_IMPORTED_MODULE_0__.IW;\ncanvas.height = _config__WEBPACK_IMPORTED_MODULE_0__.IH;\nconst offCanvas = new OffscreenCanvas(_config__WEBPACK_IMPORTED_MODULE_0__.IW, _config__WEBPACK_IMPORTED_MODULE_0__.IH);\nconst offCtx = offCanvas.getContext('2d');\nconst keyboardListener = (0,_controls__WEBPACK_IMPORTED_MODULE_3__.listenKeyboard)();\nconst muteControl = document.querySelector('[data-control=\"mute\"]');\nconst audioCtx = new AudioContext();\nconst moveAudio = new _car__WEBPACK_IMPORTED_MODULE_1__.MoveAudio(audioCtx);\nconst resources = {\n    map: _map__WEBPACK_IMPORTED_MODULE_9__.coolMap,\n    images: undefined,\n};\nconst state = {\n    speedState: _car__WEBPACK_IMPORTED_MODULE_1__.defaultMoveSpeedState,\n    steerState: _car__WEBPACK_IMPORTED_MODULE_1__.defaultSteerState,\n    upgradeState: _upgrade__WEBPACK_IMPORTED_MODULE_16__.defaultUpgradeState,\n    moveOffset: 0,\n    moveOffsetChange: 0,\n    bgOffset: 0,\n};\nconst loop = new _loop__WEBPACK_IMPORTED_MODULE_8__.GameLoop({\n    onTick: tick,\n});\n(0,_debug__WEBPACK_IMPORTED_MODULE_5__.logClientCoordsOnClick)(canvas);\nfunction draw({ deltaTime, zone, nextZone, section, path, propBoxes, yOverride, }) {\n    ctx.clearRect(0, 0, _config__WEBPACK_IMPORTED_MODULE_0__.IW, _config__WEBPACK_IMPORTED_MODULE_0__.IH);\n    const { bgOffset, moveOffset, steerState: { steerOffset }, } = state;\n    // Draw the road stripes full width. Then cut it out and keep the area that is\n    // actually covered by the road (the ground area will become transparent\n    // again). Do it offscreen because we have to apply another mask and it's hard\n    // to do on a single canvas.\n    offCtx.globalCompositeOperation = 'source-over';\n    (0,_stripes__WEBPACK_IMPORTED_MODULE_14__.drawRoadStripes)(offCtx, { zone, nextZone, moveOffset, yOverride });\n    offCtx.globalCompositeOperation = 'destination-in';\n    (0,_road__WEBPACK_IMPORTED_MODULE_12__.drawRoadMask)(offCtx, path, { steerOffset });\n    ctx.drawImage(offCanvas, 0, 0);\n    // Ditto for the road. Except the curbs are drawn to the main canvas behind\n    // the already present road.\n    offCtx.globalCompositeOperation = 'source-over';\n    (0,_stripes__WEBPACK_IMPORTED_MODULE_14__.drawCurbStripes)(offCtx, { zone, nextZone, moveOffset, yOverride });\n    offCtx.globalCompositeOperation = 'destination-in';\n    (0,_road__WEBPACK_IMPORTED_MODULE_12__.drawCurbMask)(offCtx, path, { steerOffset });\n    ctx.globalCompositeOperation = 'destination-over';\n    ctx.drawImage(offCanvas, 0, 0);\n    // Then draw the ground stripes full widths but behind the road - it will keep\n    // the road+curbs that were drawn on the previous step and only fill in the\n    // ground stripes on the sides.\n    ctx.globalCompositeOperation = 'destination-over';\n    (0,_stripes__WEBPACK_IMPORTED_MODULE_14__.drawGroundStripes)(ctx, { zone, nextZone, moveOffset, yOverride });\n    // Then draw everything on top\n    ctx.globalCompositeOperation = 'source-over';\n    (0,_background__WEBPACK_IMPORTED_MODULE_4__.drawBackground)(ctx, {\n        images: resources.images,\n        zone,\n        nextZone,\n        moveOffset,\n        bgOffset,\n        yOverride,\n    });\n    (0,_decor__WEBPACK_IMPORTED_MODULE_6__.drawDecors)(ctx, {\n        decors: resources.map.decors,\n        images: resources.images,\n        path,\n        section,\n        moveOffset,\n        steerOffset,\n        yOverride,\n    });\n    (0,_prop__WEBPACK_IMPORTED_MODULE_11__.drawProps)(ctx, {\n        propBoxes,\n        images: resources.images,\n        moveOffset,\n        steerOffset,\n    });\n    (0,_pole__WEBPACK_IMPORTED_MODULE_10__.drawPoles)(ctx, {\n        images: resources.images,\n        poles: resources.map.poles,\n        deltaTime,\n        path,\n        zone,\n        nextZone,\n        moveOffset,\n        steerOffset,\n        yOverride,\n    });\n    (0,_car__WEBPACK_IMPORTED_MODULE_1__.drawCar)(ctx, { images: resources.images, steerOffset });\n    (0,_debug__WEBPACK_IMPORTED_MODULE_5__.drawDebug)(ctx, Object.assign(Object.assign({ section,\n        bgOffset,\n        moveOffset, upgrades: state.upgradeState.upgrades }, state.speedState), state.steerState));\n    // drawHorizon(ctx);\n    (0,_upgrade__WEBPACK_IMPORTED_MODULE_16__.drawActiveUpgrades)(ctx, {\n        images: resources.images,\n        state: state.upgradeState,\n    });\n    (0,_upgrade__WEBPACK_IMPORTED_MODULE_16__.drawUpgradeDialog)(ctx, {\n        images: resources.images,\n        state: state.upgradeState,\n    });\n}\nfunction main() {\n    return __awaiter(this, void 0, void 0, function* () {\n        resources.images = yield (0,_images__WEBPACK_IMPORTED_MODULE_7__.loadImages)();\n        loop.start();\n    });\n}\nfunction getInput() {\n    const isUp = keyboardListener.isHold(_controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Up);\n    const isDown = keyboardListener.isHold(_controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Down);\n    const lastPressedThrottleControl = keyboardListener.getHoldLastOf([\n        _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Up,\n        _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Down,\n    ]);\n    const isThrottleActive = lastPressedThrottleControl === _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Up;\n    const isReverseActive = lastPressedThrottleControl === _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Down;\n    const lastPressedTurnControl = keyboardListener.getHoldLastOf([\n        _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Left,\n        _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Right,\n    ]);\n    const isLeftTurnActive = lastPressedTurnControl === _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Left;\n    const isRightTurnActive = lastPressedTurnControl === _controls__WEBPACK_IMPORTED_MODULE_3__.InputControl.Right;\n    return {\n        isThrottleActive,\n        isReverseActive,\n        isRightTurnActive,\n        isLeftTurnActive,\n    };\n}\nfunction updateLevelState() {\n    // NOTE: don't destructure the state here because it is constantly updated\n    if (state.upgradeState.isDialogOpen) {\n        return;\n    }\n    const { isThrottleActive, isReverseActive, isRightTurnActive, isLeftTurnActive, } = getInput();\n    const section = (0,_section__WEBPACK_IMPORTED_MODULE_13__.getActiveSection)({\n        sections: resources.map.sections,\n        moveOffset: state.moveOffset,\n    });\n    const nextPole = (0,_pole__WEBPACK_IMPORTED_MODULE_10__.getNextPole)({\n        poles: resources.map.poles,\n        moveOffset: state.moveOffset,\n    });\n    state.speedState = (0,_car__WEBPACK_IMPORTED_MODULE_1__.updateMoveSpeedState)(Object.assign({ nextPole, moveOffset: state.moveOffset, isThrottleActive,\n        isReverseActive }, state.speedState));\n    state.moveOffsetChange = state.speedState.moveSpeed;\n    state.moveOffset += state.moveOffsetChange;\n    state.steerState = (0,_car__WEBPACK_IMPORTED_MODULE_1__.updateSteerState)(Object.assign({ section, upgrades: state.upgradeState.upgrades, nextPole,\n        isLeftTurnActive,\n        isRightTurnActive, moveSpeed: state.speedState.moveSpeed, moveOffset: state.moveOffset }, state.steerState));\n    state.bgOffset = (0,_background__WEBPACK_IMPORTED_MODULE_4__.updateBackgroundOffset)({\n        section,\n        bgOffset: state.bgOffset,\n        moveOffset: state.moveOffset,\n        moveOffsetChange: state.moveOffsetChange,\n        moveSpeed: state.speedState.moveSpeed,\n    });\n}\nfunction updateCollisions({ path, section, nextSection, roadDepth, yOverride, }) {\n    const carBox = (0,_car__WEBPACK_IMPORTED_MODULE_1__.getCarBox)({\n        images: resources.images,\n        roadDepth,\n        moveOffset: state.moveOffset,\n        steerOffset: state.steerState.steerOffset,\n    });\n    const propBoxes = (0,_prop__WEBPACK_IMPORTED_MODULE_11__.getPropBoxes)({\n        props: resources.map.props,\n        images: resources.images,\n        path,\n        section,\n        nextSection,\n        moveOffset: state.moveOffset,\n        steerOffset: state.steerState.steerOffset,\n        yOverride,\n    });\n    const collidedBoxes = [];\n    const uncollidedBoxes = [];\n    const targetIndexes = (0,_collision__WEBPACK_IMPORTED_MODULE_2__.findCollisions)(carBox, propBoxes);\n    if (targetIndexes.length > 0) {\n        collidedBoxes.push(carBox);\n        collidedBoxes.push(...targetIndexes.map((index) => propBoxes[index]));\n    }\n    else {\n        uncollidedBoxes.push(carBox, ...propBoxes);\n    }\n    return {\n        collidedBoxes,\n        uncollidedBoxes,\n        propBoxes,\n    };\n}\nfunction tick({ deltaTime }) {\n    keyboardListener.update();\n    // NOTE: Don't destructure until after all state updates\n    const nextPole = (0,_pole__WEBPACK_IMPORTED_MODULE_10__.getNextPole)({\n        poles: resources.map.poles,\n        moveOffset: state.moveOffset,\n    });\n    state.upgradeState = (0,_upgrade__WEBPACK_IMPORTED_MODULE_16__.updateUpgradeState)({\n        keyboardListener,\n        deltaTime,\n        state: state.upgradeState,\n        nextPole,\n        moveOffset: state.moveOffset,\n    });\n    updateLevelState();\n    // NOTE: Can destructure after state has updated\n    const { map: { sections, zones }, } = resources;\n    const { moveOffset, steerState: { steerOffset }, } = state;\n    const section = (0,_section__WEBPACK_IMPORTED_MODULE_13__.getActiveSection)({ sections, moveOffset });\n    const nextSection = (0,_section__WEBPACK_IMPORTED_MODULE_13__.getNextSection)({ sections, moveOffset });\n    const zone = (0,_zone__WEBPACK_IMPORTED_MODULE_15__.getActiveZone)({ zones, moveOffset });\n    const nextZone = (0,_zone__WEBPACK_IMPORTED_MODULE_15__.getNextZone)({ zones, moveOffset });\n    const { path, yOverride } = (0,_section__WEBPACK_IMPORTED_MODULE_13__.createSectionFragments)({\n        section,\n        moveOffset,\n        steerOffset,\n    });\n    let roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.IH - (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    const stripes = (0,_stripes__WEBPACK_IMPORTED_MODULE_14__.generateStripes)({ roadHeight });\n    const roadDepth = (0,_stripes__WEBPACK_IMPORTED_MODULE_14__.stripesUnscaledHeight)(stripes);\n    const { collidedBoxes, uncollidedBoxes, propBoxes } = updateCollisions({\n        section,\n        nextSection,\n        path,\n        roadDepth,\n        yOverride,\n    });\n    draw({ deltaTime, zone, nextZone, section, path, yOverride, propBoxes });\n    // drawCollisionBoxes(ctx, collidedBoxes, uncollidedBoxes, {\n    //   stripes,\n    //   roadDepth,\n    // });\n    const isMuted = !muteControl.checked;\n    if (isMuted && audioCtx.state === 'running') {\n        audioCtx.suspend();\n    }\n    else if (!isMuted && audioCtx.state !== 'running') {\n        audioCtx.resume();\n    }\n    moveAudio.update(Object.assign({ isMuted }, state.speedState));\n}\nmain();\n\n\n//# sourceURL=webpack:///./src/main.ts?");

/***/ }),

/***/ "./src/map.ts":
/*!********************!*\
  !*** ./src/map.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"coolMap\": () => (/* binding */ coolMap),\n/* harmony export */   \"longLeftTurnMap\": () => (/* binding */ longLeftTurnMap),\n/* harmony export */   \"longUphillMap\": () => (/* binding */ longUphillMap),\n/* harmony export */   \"straightMap\": () => (/* binding */ straightMap)\n/* harmony export */ });\n/* harmony import */ var _decor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decor */ \"./src/decor.ts\");\n/* harmony import */ var _pole__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pole */ \"./src/pole.ts\");\n/* harmony import */ var _prop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./prop */ \"./src/prop.ts\");\n\n\n\nconst zones = [\n    {\n        start: 0,\n        kind: 'green',\n        decorAmount: 0,\n        skipPole: true,\n    },\n    {\n        start: 1000,\n        kind: 'green',\n        decorAmount: 60,\n    },\n    {\n        start: 6000,\n        kind: 'desert',\n        decorAmount: 60,\n    },\n    {\n        start: 12000,\n        kind: 'beach',\n        decorAmount: 10,\n    },\n    {\n        start: 18000,\n        kind: 'forest',\n        decorAmount: 1000,\n    },\n    {\n        start: 24000,\n        kind: 'forest',\n        decorAmount: 0,\n    },\n];\nconst decors = (0,_decor__WEBPACK_IMPORTED_MODULE_0__.generateDecorsForZones)({ zones });\nconst poles = (0,_pole__WEBPACK_IMPORTED_MODULE_1__.generatePolesForZones)({ zones });\nconst straightMap = {\n    zones,\n    decors,\n    poles,\n    sections: [],\n    props: [],\n};\nconst longUphillMap = {\n    zones,\n    decors,\n    poles,\n    sections: [\n        {\n            kind: 'uphill',\n            start: 100,\n            size: 15000,\n            steepness: 30,\n        },\n    ],\n    props: [\n        // {\n        //   kind: 'rock',\n        //   start: 500,\n        //   position: 0.1,\n        // },\n        ...(0,_prop__WEBPACK_IMPORTED_MODULE_2__.generateProps)({\n            startOffset: 300,\n            size: 15000,\n            amount: 30,\n        }),\n    ],\n};\nconst longLeftTurnMap = {\n    zones,\n    decors,\n    poles,\n    sections: [\n        {\n            kind: 'turn-right',\n            start: 0,\n            size: Infinity,\n        },\n    ],\n    props: [\n        ...(0,_prop__WEBPACK_IMPORTED_MODULE_2__.generateProps)({\n            startOffset: 300,\n            size: 15000,\n            amount: 30,\n        }),\n    ],\n};\nconst coolMap = {\n    zones,\n    decors,\n    poles,\n    sections: [\n        {\n            kind: 'uphill',\n            start: 1500,\n            size: 700,\n            steepness: 30,\n        },\n        {\n            kind: 'turn-left',\n            start: 3000,\n            size: 600,\n        },\n        {\n            kind: 'turn-right',\n            start: 3500,\n            size: 1000,\n        },\n        {\n            kind: 'downhill',\n            start: 4600,\n            size: 1000,\n            steepness: 50,\n        },\n    ],\n    props: [\n    // ...generateProps({\n    //   startOffset: 300,\n    //   size: 15000,\n    //   amount: 30,\n    // }),\n    ],\n};\n\n\n//# sourceURL=webpack:///./src/map.ts?");

/***/ }),

/***/ "./src/path.ts":
/*!*********************!*\
  !*** ./src/path.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getCenterCurve\": () => (/* binding */ getCenterCurve),\n/* harmony export */   \"lerpPath\": () => (/* binding */ lerpPath),\n/* harmony export */   \"steerPath\": () => (/* binding */ steerPath),\n/* harmony export */   \"translatePath\": () => (/* binding */ translatePath)\n/* harmony export */ });\n/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve */ \"./src/curve.ts\");\n\nfunction getCenterCurve(path) {\n    return {\n        topX: path.left.topX + (path.right.topX - path.left.topX) / 2,\n        topY: path.left.topY,\n        controlX: path.left.controlX + (path.right.controlX - path.left.controlX) / 2,\n        controlY: path.left.controlY,\n        bottomX: path.left.bottomX + (path.right.bottomX - path.left.bottomX) / 2,\n        bottomY: path.left.bottomY,\n    };\n}\nfunction steerPath(path, { steerOffset }) {\n    return Object.assign(Object.assign({}, path), { left: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.steerCurve)(path.left, { steerOffset }), right: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.steerCurve)(path.right, { steerOffset }) });\n}\nfunction translatePath(path, { top, bottom, }) {\n    return Object.assign(Object.assign({}, path), { left: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.translateCurve)(path.left, { top: -top, bottom: -bottom }), right: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.translateCurve)(path.right, { top, bottom }) });\n}\nfunction lerpPath(p1, p2, d) {\n    return {\n        left: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.lerpCurve)(p1.left, p2.left, d),\n        right: (0,_curve__WEBPACK_IMPORTED_MODULE_0__.lerpCurve)(p1.right, p2.right, d),\n    };\n}\n\n\n//# sourceURL=webpack:///./src/path.ts?");

/***/ }),

/***/ "./src/pole.ts":
/*!*********************!*\
  !*** ./src/pole.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawPoles\": () => (/* binding */ drawPoles),\n/* harmony export */   \"generatePolesForZones\": () => (/* binding */ generatePolesForZones),\n/* harmony export */   \"getNextPole\": () => (/* binding */ getNextPole)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve */ \"./src/curve.ts\");\n/* harmony import */ var _road__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./road */ \"./src/road.ts\");\n/* harmony import */ var _stripes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stripes */ \"./src/stripes.ts\");\n\n\n\n\nfunction getNextPole({ poles, moveOffset, }) {\n    return poles.find((pole) => {\n        return pole.start > moveOffset && !pole.granted;\n    });\n}\nfunction drawPoles(ctx, { poles, images, deltaTime, path, zone, nextZone, moveOffset, steerOffset, yOverride, }) {\n    let roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.IH - (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    const stripes = (0,_stripes__WEBPACK_IMPORTED_MODULE_3__.generateStripes)({ roadHeight });\n    const travelDistance = (0,_stripes__WEBPACK_IMPORTED_MODULE_3__.stripesUnscaledHeight)(stripes);\n    let preshowSize = 200;\n    let pole;\n    for (let i = poles.length - 1; i >= 0; i--) {\n        const appearStart = poles[i].start - travelDistance;\n        const preshowAppearStart = appearStart - preshowSize;\n        if (moveOffset >= preshowAppearStart) {\n            pole = poles[i];\n            break;\n        }\n    }\n    if (!pole) {\n        return;\n    }\n    const appearStart = pole.start - travelDistance;\n    const isPreshow = moveOffset < appearStart;\n    const curbPath = (0,_road__WEBPACK_IMPORTED_MODULE_2__.getCurbPath)(path, { steerOffset });\n    let inOffset = moveOffset - pole.start + travelDistance;\n    if (isPreshow) {\n        inOffset = 1;\n    }\n    const stripesY = (0,_stripes__WEBPACK_IMPORTED_MODULE_3__.stripesToY)(stripes, { inOffset });\n    if (stripesY === undefined) {\n        return;\n    }\n    const poleY = _config__WEBPACK_IMPORTED_MODULE_0__.IH - stripesY;\n    const poleRightX = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.curveXByY)((0,_curve__WEBPACK_IMPORTED_MODULE_1__.steerCurve)(curbPath.right, { steerOffset }), poleY);\n    const poleLeftX = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.curveXByY)((0,_curve__WEBPACK_IMPORTED_MODULE_1__.steerCurve)(curbPath.left, { steerOffset }), poleY);\n    let inHalfHeightT = stripesY / _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n    let imageScale = Math.max(0, 1 - (1 - 0.1 * _config__WEBPACK_IMPORTED_MODULE_0__.RENDER_SCALE) * inHalfHeightT);\n    let imageOpacity = 1;\n    if (poleRightX) {\n        drawPole(ctx, {\n            side: 'right',\n            images,\n            pole,\n            poleX: poleRightX,\n            poleY,\n            imageScale,\n            imageOpacity,\n        });\n    }\n    if (poleLeftX) {\n        drawPole(ctx, {\n            side: 'left',\n            images,\n            pole,\n            poleX: poleLeftX,\n            poleY,\n            imageScale,\n            imageOpacity,\n        });\n    }\n}\nfunction drawPole(ctx, { side, images, pole, poleX, poleY, imageScale, imageOpacity, }) {\n    const image = pole.granted ? images.poleGreen : images.poleRed;\n    const sourceWidth = 64;\n    const sourceHeight = 256;\n    const sourceX = 0;\n    const sourceY = 0;\n    const imageWidth = sourceWidth * imageScale;\n    const imageHeight = sourceHeight * imageScale;\n    const imageX = poleX - imageWidth / 3;\n    const imageY = poleY - imageHeight;\n    ctx.globalAlpha = imageOpacity;\n    ctx.drawImage(image, sourceX, sourceY, sourceWidth, sourceHeight, imageX, imageY, imageWidth, imageHeight);\n    ctx.globalAlpha = 1;\n    const animationEnd = 1;\n    if (!pole.granted) {\n        if (pole.energyFrameTime == null) {\n            pole.energyFrameTime = 0;\n            pole.energyFrameIndex = 0;\n        }\n        else {\n            pole.energyFrameTime += 0.1;\n        }\n        if (pole.energyFrameTime >= animationEnd) {\n            pole.energyFrameTime = 0;\n            pole.energyFrameIndex = pole.energyFrameIndex === 0 ? 1 : 0;\n        }\n        const energyImage = images.poleEnergy;\n        const energyWidth = energyImage.width * imageScale * 1.5;\n        const energyHeight = energyImage.height * imageScale;\n        const energyX = side === 'right' ? imageX - energyWidth : imageX + 20;\n        const energyY = imageY;\n        if (pole.energyFrameIndex === 1) {\n            ctx.globalAlpha = pole.energyFrameTime / animationEnd;\n        }\n        ctx.drawImage(energyImage, energyX, energyY, energyWidth, energyHeight);\n        ctx.globalAlpha = 1;\n    }\n}\nfunction generatePolesForZones({ zones }) {\n    const poles = [];\n    zones.forEach((zone) => {\n        if (!zone.skipPole) {\n            poles.push({\n                start: zone.start,\n            });\n        }\n    });\n    return poles;\n}\n\n\n//# sourceURL=webpack:///./src/pole.ts?");

/***/ }),

/***/ "./src/prop.ts":
/*!*********************!*\
  !*** ./src/prop.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawProps\": () => (/* binding */ drawProps),\n/* harmony export */   \"generateProps\": () => (/* binding */ generateProps),\n/* harmony export */   \"getPropBoxes\": () => (/* binding */ getPropBoxes)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve */ \"./src/curve.ts\");\n/* harmony import */ var _stripes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stripes */ \"./src/stripes.ts\");\n/* harmony import */ var _random__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./random */ \"./src/random.ts\");\n/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./path */ \"./src/path.ts\");\n\n\n\n\n\nfunction getPropBoxes({ props, images, path, section, nextSection, moveOffset, steerOffset, yOverride, }) {\n    var _a;\n    let roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.IH - (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    const stripes = (0,_stripes__WEBPACK_IMPORTED_MODULE_2__.generateStripes)({ roadHeight });\n    const roadDepth = (0,_stripes__WEBPACK_IMPORTED_MODULE_2__.stripesUnscaledHeight)(stripes);\n    const propBoxes = [];\n    let preshowSize = 700;\n    if (section.kind === 'uphill' || (nextSection === null || nextSection === void 0 ? void 0 : nextSection.kind) === 'uphill') {\n        preshowSize = 400;\n    }\n    else if (section.kind === 'downhill' || (nextSection === null || nextSection === void 0 ? void 0 : nextSection.kind) === 'downhill') {\n        preshowSize = 0;\n    }\n    for (const prop of props) {\n        const propMoveOffset = (_a = prop.moveOffset) !== null && _a !== void 0 ? _a : 0;\n        const appearStart = prop.start - propMoveOffset - roadDepth;\n        const appearEnd = prop.start - propMoveOffset;\n        const preshowAppearStart = appearStart - preshowSize;\n        if (moveOffset >= preshowAppearStart && moveOffset <= appearEnd) {\n            const isPreshow = moveOffset < appearStart;\n            const centerCurve = (0,_path__WEBPACK_IMPORTED_MODULE_4__.getCenterCurve)(path);\n            let curve = centerCurve;\n            if (prop.position > 0.5) {\n                curve = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.lerpCurve)(centerCurve, path.right, (prop.position - 0.5) * 2);\n            }\n            else if (prop.position < 0.5) {\n                curve = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.lerpCurve)(path.left, centerCurve, prop.position * 2);\n            }\n            const steeredCurve = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.steerCurve)(curve, { steerOffset });\n            if (prop.moveSpeed != null) {\n                prop.moveOffset = propMoveOffset - prop.moveSpeed;\n            }\n            let inOffset = moveOffset - prop.start + roadDepth + propMoveOffset;\n            if (isPreshow) {\n                inOffset = 1;\n            }\n            const stripesY = (0,_stripes__WEBPACK_IMPORTED_MODULE_2__.stripesToY)(stripes, { inOffset });\n            if (stripesY === undefined) {\n                continue;\n            }\n            const propY = _config__WEBPACK_IMPORTED_MODULE_0__.IH - stripesY;\n            const propX = (0,_curve__WEBPACK_IMPORTED_MODULE_1__.curveXByY)(steeredCurve, propY);\n            if (propX === undefined) {\n                continue;\n            }\n            let inHalfHeightT = stripesY / _config__WEBPACK_IMPORTED_MODULE_0__.HH;\n            let imageScale = Math.max(0, 1 - (1 - 0.1 * _config__WEBPACK_IMPORTED_MODULE_0__.RS) * inHalfHeightT);\n            let imageOpacity = 1;\n            if (roadHeight > _config__WEBPACK_IMPORTED_MODULE_0__.HH && propY < _config__WEBPACK_IMPORTED_MODULE_0__.HH) {\n                const inOverHeightT = Math.max(0, 1 - (_config__WEBPACK_IMPORTED_MODULE_0__.HH - propY) / (roadHeight - _config__WEBPACK_IMPORTED_MODULE_0__.HH));\n                imageScale = 0.1 * inOverHeightT;\n            }\n            else if (isPreshow) {\n                imageScale *= 1 - (appearStart - moveOffset) / preshowSize;\n                imageOpacity = 1 - (appearStart - moveOffset) / preshowSize;\n            }\n            const image = imageByKind(images, prop.kind);\n            const imageWidth = image.width * imageScale;\n            const imageHeight = image.height * imageScale;\n            const imageX = propX - imageWidth / 2;\n            const imageY = propY - imageHeight;\n            propBoxes.push({\n                prop,\n                curve: steeredCurve,\n                x: imageX,\n                y: imageY,\n                z: roadDepth - inOffset,\n                width: imageWidth,\n                height: imageHeight,\n                depth: 20,\n                opacity: imageOpacity,\n            });\n        }\n    }\n    return propBoxes;\n}\nfunction drawProps(ctx, { propBoxes, images, moveOffset, steerOffset, }) {\n    for (const propBox of propBoxes) {\n        const image = imageByKind(images, propBox.prop.kind);\n        // drawCurve(ctx, propBox.curve, { moveOffset, steerOffset: 0 });\n        ctx.globalAlpha = propBox.opacity;\n        ctx.drawImage(image, propBox.x, propBox.y, propBox.width, propBox.height);\n        ctx.globalAlpha = 1;\n    }\n}\nfunction imageByKind(images, kind) {\n    switch (kind) {\n        case 'bush':\n            return images.decorBush;\n        case 'tree':\n            return images.decorTree;\n        case 'rock':\n            return images.decorRock;\n        default:\n            throw new Error(`Unsupported decor kind: \"${kind}\"`);\n    }\n}\nfunction generateProps({ startOffset, size, amount, }) {\n    const props = [];\n    const areaSize = size / amount;\n    // Go reverse to have the farthest props in the array first, which means the\n    // closest will be rendered last, which is better for zindex.\n    for (let i = amount - 1; i >= 0; i--) {\n        const areaStart = i * areaSize;\n        const inAreaOffset = (0,_random__WEBPACK_IMPORTED_MODULE_3__.randomNumber)(0, areaSize);\n        const start = startOffset + areaStart + inAreaOffset;\n        const kind = (0,_random__WEBPACK_IMPORTED_MODULE_3__.randomElement)(['bush', 'tree', 'rock']);\n        const position = (0,_random__WEBPACK_IMPORTED_MODULE_3__.randomNumber)(10, 90) / 100;\n        props.push({\n            start,\n            kind,\n            position,\n        });\n    }\n    return props;\n}\n\n\n//# sourceURL=webpack:///./src/prop.ts?");

/***/ }),

/***/ "./src/random.ts":
/*!***********************!*\
  !*** ./src/random.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"randomElement\": () => (/* binding */ randomElement),\n/* harmony export */   \"randomElements\": () => (/* binding */ randomElements),\n/* harmony export */   \"randomNumber\": () => (/* binding */ randomNumber)\n/* harmony export */ });\nfunction randomElement(items) {\n    const index = Math.floor(Math.random() * items.length);\n    return items[index];\n}\nfunction randomElements(items, count) {\n    const clonedItems = items.slice();\n    const pickedItems = [];\n    for (let i = 0; i < Math.min(items.length, count); i++) {\n        const index = Math.floor(Math.random() * clonedItems.length);\n        pickedItems.push(...clonedItems.splice(index, 1));\n    }\n    return pickedItems;\n}\nfunction randomNumber(from = 0, to = 1) {\n    return Math.floor(Math.random() * (to - from + 1) + from);\n}\n\n\n//# sourceURL=webpack:///./src/random.ts?");

/***/ }),

/***/ "./src/road.ts":
/*!*********************!*\
  !*** ./src/road.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawCurbMask\": () => (/* binding */ drawCurbMask),\n/* harmony export */   \"drawRoadLines\": () => (/* binding */ drawRoadLines),\n/* harmony export */   \"drawRoadMask\": () => (/* binding */ drawRoadMask),\n/* harmony export */   \"getCurbPath\": () => (/* binding */ getCurbPath)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path */ \"./src/path.ts\");\n\n\nfunction drawRoadMask(ctx, path, { steerOffset, color = 'black' }) {\n    const { left, right } = (0,_path__WEBPACK_IMPORTED_MODULE_1__.steerPath)(path, {\n        steerOffset,\n    });\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(left.bottomX, left.bottomY);\n    ctx.quadraticCurveTo(left.controlX, left.controlY, left.topX, left.topY);\n    ctx.lineTo(right.topX, right.topY);\n    ctx.quadraticCurveTo(right.controlX, right.controlY, right.bottomX, right.bottomY);\n    ctx.lineTo(left.bottomX, left.bottomY);\n    ctx.fill();\n}\nfunction getCurbPath(path, { steerOffset }) {\n    return (0,_path__WEBPACK_IMPORTED_MODULE_1__.translatePath)(path, {\n        // TODO: maybe make it wider for uphills\n        top: 1 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n        bottom: 50 * _config__WEBPACK_IMPORTED_MODULE_0__.RS,\n    });\n}\nfunction drawCurbMask(ctx, path, { steerOffset, color = 'black' }) {\n    const steeredPath = (0,_path__WEBPACK_IMPORTED_MODULE_1__.steerPath)(path, {\n        steerOffset,\n    });\n    const { left, right } = getCurbPath(steeredPath, { steerOffset });\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(left.bottomX, left.bottomY);\n    ctx.quadraticCurveTo(left.controlX, left.controlY, left.topX, left.topY);\n    ctx.lineTo(right.topX, right.topY);\n    ctx.quadraticCurveTo(right.controlX, right.controlY, right.bottomX, right.bottomY);\n    ctx.fill();\n}\nfunction drawRoadLines(ctx, path, { moveOffset, steerOffset, color = 'red' }) {\n    ctx.strokeStyle = color;\n    ctx.setLineDash([10]);\n    ctx.lineDashOffset = moveOffset;\n    const { left, right } = (0,_path__WEBPACK_IMPORTED_MODULE_1__.steerPath)(path, {\n        steerOffset,\n    });\n    ctx.beginPath();\n    ctx.moveTo(left.bottomX, left.bottomY);\n    ctx.quadraticCurveTo(left.controlX, left.controlY, left.topX, left.topY);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.moveTo(right.bottomX, right.bottomY);\n    ctx.quadraticCurveTo(right.controlX, right.controlY, right.topX, right.topY);\n    ctx.stroke();\n}\n\n\n//# sourceURL=webpack:///./src/road.ts?");

/***/ }),

/***/ "./src/section.ts":
/*!************************!*\
  !*** ./src/section.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createSectionFragments\": () => (/* binding */ createSectionFragments),\n/* harmony export */   \"getActiveSection\": () => (/* binding */ getActiveSection),\n/* harmony export */   \"getNextSection\": () => (/* binding */ getNextSection)\n/* harmony export */ });\n/* harmony import */ var _fragment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fragment */ \"./src/fragment.ts\");\n\nfunction createSectionFragments({ section, moveOffset, steerOffset, }) {\n    const inSectionOffset = moveOffset - section.start;\n    if (section.kind === 'straight') {\n        return { path: _fragment__WEBPACK_IMPORTED_MODULE_0__.straightFragment };\n    }\n    if (section.kind === 'turn-right' || section.kind === 'turn-left') {\n        const fragments = (0,_fragment__WEBPACK_IMPORTED_MODULE_0__.createTurn)({\n            size: section.size,\n            direction: section.kind === 'turn-right' ? 'right' : 'left',\n            steerOffset,\n        });\n        const path = (0,_fragment__WEBPACK_IMPORTED_MODULE_0__.lerpFragments)({\n            fragments,\n            inOffset: inSectionOffset,\n        });\n        return { path };\n    }\n    if (section.kind === 'downhill') {\n        const fragments = (0,_fragment__WEBPACK_IMPORTED_MODULE_0__.createDownhill)({\n            size: section.size,\n            inOffset: inSectionOffset,\n            steepness: section.steepness,\n            steerOffset,\n        });\n        const path = (0,_fragment__WEBPACK_IMPORTED_MODULE_0__.lerpFragments)({\n            fragments,\n            inOffset: inSectionOffset,\n        });\n        const yOverride = path.left.topY;\n        return { path, yOverride };\n    }\n    if (section.kind === 'uphill') {\n        const fragments = (0,_fragment__WEBPACK_IMPORTED_MODULE_0__.createUphill)({\n            size: section.size,\n            inOffset: inSectionOffset,\n            steepness: section.steepness,\n            steerOffset,\n        });\n        const path = (0,_fragment__WEBPACK_IMPORTED_MODULE_0__.lerpFragments)({\n            fragments,\n            inOffset: inSectionOffset,\n        });\n        const yOverride = path.left.topY;\n        return { path, yOverride };\n    }\n    throw new Error(`Unknown section: \"${section.kind}\"`);\n}\nfunction getActiveSection({ sections, moveOffset, }) {\n    let activeSection = sections.find((s) => {\n        return moveOffset >= s.start && moveOffset <= s.start + s.size;\n    });\n    if (!activeSection || hasSectionEnded(activeSection, moveOffset)) {\n        activeSection = { start: moveOffset, kind: 'straight', size: 0 };\n    }\n    return activeSection;\n}\nfunction getNextSection({ sections, moveOffset, }) {\n    const activeSectionIndex = sections.findIndex((s) => {\n        return moveOffset >= s.start && moveOffset <= s.start + s.size;\n    });\n    if (activeSectionIndex !== -1) {\n        const nextSectionIndex = activeSectionIndex + 1;\n        return sections[nextSectionIndex];\n    }\n    return sections.find((s) => {\n        return s.start > moveOffset;\n    });\n}\nfunction hasSectionEnded(section, moveOffset) {\n    return section.start + section.size < moveOffset;\n}\n\n\n//# sourceURL=webpack:///./src/section.ts?");

/***/ }),

/***/ "./src/stripes.ts":
/*!************************!*\
  !*** ./src/stripes.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawCurbStripes\": () => (/* binding */ drawCurbStripes),\n/* harmony export */   \"drawGroundStripes\": () => (/* binding */ drawGroundStripes),\n/* harmony export */   \"drawRoadStripes\": () => (/* binding */ drawRoadStripes),\n/* harmony export */   \"generateStripes\": () => (/* binding */ generateStripes),\n/* harmony export */   \"stripesToY\": () => (/* binding */ stripesToY),\n/* harmony export */   \"stripesUnscaledHeight\": () => (/* binding */ stripesUnscaledHeight)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\nconst NEAR_TEXTURE_HEIGHT = 32 * _config__WEBPACK_IMPORTED_MODULE_0__.RENDER_SCALE;\nconst GROUND_COLORS = new Map();\nGROUND_COLORS.set('green', ['#889827', '#9aa545']);\nGROUND_COLORS.set('desert', ['#b7b467', '#c9c67c']);\nGROUND_COLORS.set('forest', ['#0c405e', '#1e4f6b']);\nGROUND_COLORS.set('beach', ['#579eb7', '#579eb7']);\nfunction drawGroundStripes(ctx, opts) {\n    const colors = GROUND_COLORS.get(opts.zone.kind);\n    drawStripes(ctx, Object.assign(Object.assign({}, opts), { colorMap: GROUND_COLORS }));\n}\nconst ROAD_COLORS = new Map();\nROAD_COLORS.set('green', ['#69696a', '#444446']);\nROAD_COLORS.set('desert', ['#9d7634', '#8b6b36']);\nROAD_COLORS.set('forest', ['#497d7a', '#2f706c']);\nROAD_COLORS.set('beach', ['#36291a', '#4c3821']);\nfunction drawRoadStripes(ctx, opts) {\n    const colors = ROAD_COLORS.get(opts.zone.kind);\n    drawStripes(ctx, Object.assign(Object.assign({}, opts), { colorMap: ROAD_COLORS }));\n}\nconst CURB_COLORS = new Map();\nCURB_COLORS.set('green', ['#c5bfbf', '#dc3961']);\nCURB_COLORS.set('desert', ['#c57f4c', '#a15541']);\nCURB_COLORS.set('forest', ['#867794', '#64497d']);\nCURB_COLORS.set('beach', ['#626262', '#626262']);\n// TODO: make them appear more often?? but keep stripes match with bigger ones\nfunction drawCurbStripes(ctx, opts) {\n    drawStripes(ctx, Object.assign(Object.assign({}, opts), { colorMap: CURB_COLORS }));\n}\nfunction drawStripes(ctx, { colorMap, zone, nextZone, moveOffset, yOverride, }) {\n    const colors = colorMap.get(zone.kind);\n    const nextColors = colorMap.get(nextZone.kind);\n    const roadHeight = _config__WEBPACK_IMPORTED_MODULE_0__.IH - (yOverride !== null && yOverride !== void 0 ? yOverride : _config__WEBPACK_IMPORTED_MODULE_0__.HH);\n    // const roadHeight = HH;\n    const nextZoneIn = nextZone.start - moveOffset;\n    const stripes = generateStripes({ roadHeight });\n    const texturedStripes = textureSplitStripes(stripes, { moveOffset });\n    const roadDepth = stripesUnscaledHeight(stripes);\n    if (nextZoneIn > 0 && nextZoneIn < roadDepth) {\n        const inOffset = roadDepth - nextZoneIn;\n        const divideY = stripesToY(stripes, { inOffset });\n        const closestStripe = texturedStripes.find((stripe, i) => {\n            var _a;\n            return (stripe.y2 >= divideY &&\n                stripe.textureIndex === 0 &&\n                ((_a = texturedStripes[i + 1]) === null || _a === void 0 ? void 0 : _a.textureIndex) !== 0);\n        });\n        for (let i = 0; i < texturedStripes.length; i++) {\n            const stripe = texturedStripes[i];\n            const nextStripe = texturedStripes[i + 1];\n            let usedColors = colors;\n            if (stripe.stripeIndex >= (closestStripe === null || closestStripe === void 0 ? void 0 : closestStripe.stripeIndex)) {\n                usedColors = nextColors;\n            }\n            if (stripe.stripeIndex + 1 === (closestStripe === null || closestStripe === void 0 ? void 0 : closestStripe.stripeIndex) &&\n                stripe.textureIndex === (nextStripe === null || nextStripe === void 0 ? void 0 : nextStripe.textureIndex) &&\n                stripe.textureIndex === 0) {\n                usedColors = nextColors;\n            }\n            ctx.fillStyle = usedColors[stripe.textureIndex];\n            ctx.fillRect(0, _config__WEBPACK_IMPORTED_MODULE_0__.IH - stripe.y2, _config__WEBPACK_IMPORTED_MODULE_0__.IW, stripe.height);\n        }\n    }\n    else {\n        for (const stripe of texturedStripes) {\n            ctx.fillStyle = colors[stripe.textureIndex];\n            ctx.fillRect(0, _config__WEBPACK_IMPORTED_MODULE_0__.IH - stripe.y2, _config__WEBPACK_IMPORTED_MODULE_0__.IW, stripe.height);\n        }\n    }\n}\nfunction stripesUnscaledHeight(stripes) {\n    const nearTextureHeight = stripes[0].height;\n    return stripes.length * nearTextureHeight;\n}\nfunction stripesToY(stripes, { inOffset }) {\n    // First stripe travels 1 to 1 with the move offset -> 32 to 32.\n    // Let's say second stripe is smaller in size by 2 (32 / 2 = 16), which means\n    // that if inOffset travels +32, then this stripe will travel +16,\n    // or if inOffset travels +16, then this stripe will travel +8.\n    // Find a stripe we are in first using inOffset. Then figure out how much\n    // into a stripe we have travelled and return it as an y position.\n    const nearTextureHeight = stripes[0].height;\n    const roadHeight = stripes[stripes.length - 1].y2;\n    let unscaledOffset = 0;\n    let scaledY = 0;\n    const unscaledHeight = stripes.length * nearTextureHeight;\n    const unscaledIn = unscaledHeight - inOffset;\n    const unscaledT = unscaledIn / nearTextureHeight;\n    const stripeIndex = Math.floor(unscaledT);\n    const inStripeT = unscaledT % 1;\n    if (stripeIndex < 0) {\n        const firstStripe = stripes[0];\n        return undefined;\n        // return firstStripe.y2;\n    }\n    if (stripeIndex > stripes.length - 1) {\n        const lastStripe = stripes[stripes.length - 1];\n        return undefined;\n        // return lastStripe.y2;\n    }\n    const stripe = stripes[stripeIndex];\n    if (stripe == null) {\n        return undefined;\n    }\n    const y = stripe.y + stripe.height * inStripeT;\n    return y;\n}\nfunction generateStripes({ roadHeight, nearTextureHeight = NEAR_TEXTURE_HEIGHT, }) {\n    const stripes = [];\n    // Will be used in a function to calculate how much the next road stripe will\n    // be downscaled compared to the previous one because next stripe is further\n    // into the road.\n    let downscaleIndex = 1;\n    let stripeIndex = 0;\n    let currentY = 0;\n    let roadLeftToParse = roadHeight;\n    while (roadLeftToParse >= 0) {\n        const y = currentY;\n        if (y >= roadHeight) {\n            break;\n        }\n        const downscaleMultiplier = 1 / downscaleIndex;\n        const stripeHeight = Math.ceil(downscaleMultiplier * nearTextureHeight);\n        let y2 = y + stripeHeight;\n        let height = stripeHeight;\n        if (y2 > roadHeight) {\n            y2 = roadHeight;\n            height = Math.round(y2 - y);\n        }\n        if (height > 0) {\n            stripes.push({\n                y,\n                y2,\n                height,\n                stripeIndex,\n            });\n        }\n        roadLeftToParse -= stripeHeight;\n        currentY += stripeHeight;\n        downscaleIndex++;\n        stripeIndex++;\n    }\n    return stripes;\n}\n// TODO: allow custom texture count, not just two, to split the curb\nfunction textureSplitStripes(stripes, { moveOffset, }) {\n    const splitStripes = [];\n    if (stripes.length === 0) {\n        return splitStripes;\n    }\n    const isNegativeMoveOffset = moveOffset < 0;\n    const nearTextureHeight = stripes[0].height;\n    // Based on the nearest stripe and global offset calculate how much this\n    // nearest stripe is offset from zero position. We are going to offset\n    // all of the following stripes based on the same percentages.\n    let restFillPercent = Math.abs(moveOffset % nearTextureHeight) / nearTextureHeight;\n    let primFillPercent = 1 - restFillPercent;\n    // If we are going below zero swap the percentages because the other texture\n    // will be rendered first\n    if (isNegativeMoveOffset) {\n        primFillPercent = 1 - primFillPercent;\n        restFillPercent = 1 - restFillPercent;\n    }\n    // Figure out which texture is rendered first in the current loop based on the\n    // global offset\n    let primTextureIndex = Math.floor(Math.abs(moveOffset) / nearTextureHeight) % 2;\n    // If we are going negative choose the other texture\n    if (isNegativeMoveOffset) {\n        primTextureIndex = 1 - primTextureIndex;\n    }\n    let stripeIndex = 0;\n    for (const stripe of stripes) {\n        // Stripe is split into two sub-stripes based on the global offset.\n        // Each stripe has it's own texture.\n        const primTextureHeight = Math.round(stripe.height * primFillPercent);\n        const restTextureHeight = stripe.height - primTextureHeight;\n        // Add both sub-stripes as separate entries of their own height with\n        // corresponding texture indexes\n        if (primTextureHeight !== 0) {\n            splitStripes.push(Object.assign(Object.assign({}, stripe), { height: primTextureHeight, y2: stripe.y + primTextureHeight, textureIndex: primTextureIndex, stripeIndex }));\n        }\n        if (restTextureHeight !== 0) {\n            splitStripes.push(Object.assign(Object.assign({}, stripe), { height: restTextureHeight, y: stripe.y2 - restTextureHeight, textureIndex: 1 - primTextureIndex, stripeIndex }));\n        }\n        // Alernate to the other texture and make it primary\n        primTextureIndex = 1 - primTextureIndex;\n        stripeIndex++;\n    }\n    return splitStripes;\n}\n\n\n//# sourceURL=webpack:///./src/stripes.ts?");

/***/ }),

/***/ "./src/upgrade.ts":
/*!************************!*\
  !*** ./src/upgrade.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ALL_UPGRADES\": () => (/* binding */ ALL_UPGRADES),\n/* harmony export */   \"defaultUpgradeState\": () => (/* binding */ defaultUpgradeState),\n/* harmony export */   \"drawActiveUpgrades\": () => (/* binding */ drawActiveUpgrades),\n/* harmony export */   \"drawUpgradeDialog\": () => (/* binding */ drawUpgradeDialog),\n/* harmony export */   \"updateUpgradeState\": () => (/* binding */ updateUpgradeState)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _controls__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./controls */ \"./src/controls.ts\");\n/* harmony import */ var _random__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./random */ \"./src/random.ts\");\n\n\n\nconst ALL_UPGRADES = [\n    {\n        kind: 'improved-steering',\n        description: 'Improved handling',\n        active: false,\n    },\n    {\n        kind: 'lower-max-speed',\n        description: 'Reduces max speed',\n        active: false,\n    },\n    {\n        kind: 'bumper',\n        description: 'Slows by bumping into obstacles. Cooldown: 10 sec',\n        active: false,\n        cooldown: 10,\n        // breaks and blocks a slot?\n    },\n    {\n        kind: 'lives',\n        description: 'Protects from an obstacle hit. Lives: 3',\n        active: false,\n        count: 3,\n        // slow down?\n        // expires? blocks a slot?\n    },\n    {\n        kind: 'parachute',\n        description: 'Decelerates to 0',\n        active: true,\n        cooldown: 10,\n        // count?\n        // cd?\n    },\n    {\n        kind: 'anti-nitro',\n        description: 'Backwards nitro',\n        active: true,\n        cooldown: 10,\n        // cd?\n    },\n    // {\n    //   kind: 'rocket-launcher',\n    //   description: 'Shoot rockets to kill obstacles. Cooldown: 10 sec',\n    //   active: true,\n    //   // cd?\n    //   // count\n    // },\n    {\n        kind: 'curb-stop',\n        description: 'Use curb to slow down. Heats up.',\n        active: false,\n        cooldown: 10,\n        // heat? cd?\n    },\n    {\n        kind: 'turn-uphill-slow',\n        description: 'Slows down on turns and uphills',\n        active: false,\n    },\n    // timestop?\n    // reduce amount of obstacles\n    //\n];\nconst defaultUpgradeState = {\n    isDialogOpen: false,\n    dialogSelectedIndex: 0,\n    dialogUpgrades: [],\n    upgrades: [],\n};\nfunction updateUpgradeState({ keyboardListener, deltaTime, state, nextPole, moveOffset, }) {\n    const shouldOpenUpgrade = nextPole.arrived && !nextPole.granted && !state.isDialogOpen;\n    if (shouldOpenUpgrade) {\n        const hasActive = state.upgrades.some((u) => u.active);\n        const availableUpgrades = ALL_UPGRADES.filter((allUpgrade) => {\n            const hasIt = state.upgrades.some((u) => u.kind === allUpgrade.kind);\n            if (hasIt) {\n                return false;\n            }\n            if (allUpgrade.active && hasActive) {\n                return false;\n            }\n            return true;\n        });\n        const dialogUpgrades = (0,_random__WEBPACK_IMPORTED_MODULE_2__.randomElements)(availableUpgrades, 3);\n        return Object.assign(Object.assign({}, state), { isDialogOpen: true, dialogSelectedIndex: 0, dialogUpgrades });\n    }\n    if (!state.isDialogOpen) {\n        const isActivated = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Select);\n        if (isActivated) {\n            const activeIndex = state.upgrades.findIndex((upgrade) => {\n                return upgrade.active === true;\n            });\n            if (activeIndex !== -1) {\n                const activeUpgrade = state.upgrades[activeIndex];\n                if (activeUpgrade.cooldownPassed == null) {\n                    activeUpgrade.cooldownPassed = 0;\n                }\n            }\n        }\n        // Mutates upgrades - updates cooldowns\n        state.upgrades.forEach((upgrade) => {\n            if (upgrade.cooldown != null && upgrade.cooldownPassed != null) {\n                upgrade.cooldownPassed += deltaTime;\n                if (upgrade.cooldownPassed > upgrade.cooldown) {\n                    upgrade.cooldownPassed = null;\n                }\n            }\n        });\n        return state;\n    }\n    const isSelected = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Select);\n    if (isSelected) {\n        const newUpgrade = state.dialogUpgrades[state.dialogSelectedIndex];\n        const upgrades = [...state.upgrades, newUpgrade];\n        nextPole.granted = true;\n        return Object.assign(Object.assign({}, state), { upgrades, isDialogOpen: false, dialogUpgrades: [], dialogSelectedIndex: 0 });\n    }\n    const isLeft = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Left);\n    const isRight = keyboardListener.isDown(_controls__WEBPACK_IMPORTED_MODULE_1__.InputControl.Right);\n    let dialogSelectedIndex = state.dialogSelectedIndex;\n    if (isLeft) {\n        dialogSelectedIndex -= 1;\n        if (dialogSelectedIndex < 0) {\n            dialogSelectedIndex = state.dialogUpgrades.length - 1;\n        }\n    }\n    else if (isRight) {\n        dialogSelectedIndex += 1;\n        if (dialogSelectedIndex > state.dialogUpgrades.length - 1) {\n            dialogSelectedIndex = 0;\n        }\n    }\n    return Object.assign(Object.assign({}, state), { dialogSelectedIndex });\n}\nconst SPRITE_MAP = new Map();\nSPRITE_MAP.set('improved-steering', { x: 0, y: 0 });\nSPRITE_MAP.set('lives', { x: 32, y: 0 });\nSPRITE_MAP.set('bumper', { x: 64, y: 0 });\nSPRITE_MAP.set('curb-stop', { x: 96, y: 0 });\nSPRITE_MAP.set('turn-uphill-slow', { x: 128, y: 0 });\nSPRITE_MAP.set('anti-nitro', { x: 160, y: 0 });\nSPRITE_MAP.set('parachute', { x: 192, y: 0 });\nSPRITE_MAP.set('lower-max-speed', { x: 224, y: 0 });\nfunction drawUpgradeDialog(ctx, { images, state }) {\n    if (!state.isDialogOpen) {\n        return;\n    }\n    const width = 200 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const height = 100 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const x = (_config__WEBPACK_IMPORTED_MODULE_0__.IW - width) / 2;\n    const y = (_config__WEBPACK_IMPORTED_MODULE_0__.IH - height) / 2;\n    ctx.globalAlpha = 0.5;\n    ctx.fillStyle = 'black';\n    ctx.fillRect(0, 0, _config__WEBPACK_IMPORTED_MODULE_0__.IW, _config__WEBPACK_IMPORTED_MODULE_0__.IH);\n    ctx.globalAlpha = 1;\n    ctx.fillStyle = '#409398';\n    ctx.fillRect(x, y, width, height);\n    ctx.strokeStyle = '#2b7d82';\n    ctx.lineWidth = 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    ctx.strokeRect(x, y, width, height);\n    ctx.strokeStyle = '#000';\n    ctx.lineWidth = 1;\n    ctx.font = `${9 * _config__WEBPACK_IMPORTED_MODULE_0__.RS}px serif`;\n    ctx.strokeText('Pick an upgrade:', x + 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, y + 15 * _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n    state.dialogUpgrades.forEach((upgrade, index) => {\n        drawUpgradeDialogItem(ctx, {\n            images,\n            upgrade,\n            index,\n            isSelected: state.dialogSelectedIndex === index,\n        });\n    });\n}\n// TODO: add icons\nfunction drawUpgradeDialogItem(ctx, { images, upgrade, isSelected, index, }) {\n    const x = 130 * _config__WEBPACK_IMPORTED_MODULE_0__.RS + 45 * _config__WEBPACK_IMPORTED_MODULE_0__.RS * index;\n    const y = 80 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const size = 32 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    drawUpgradeImage(ctx, { upgrade, images, x, y, size });\n    ctx.strokeStyle = isSelected ? '#d73131' : '#fff';\n    ctx.lineWidth = 2 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    ctx.strokeRect(x, y, size, size);\n    if (isSelected) {\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = '#000';\n        ctx.font = `${10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS}px serif`;\n        ctx.strokeText(upgrade.description, 100 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, 128 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, 180 * _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n        ctx.strokeText(upgrade.active ? 'Active' : 'Passive', 100 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, 140 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, 180 * _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n    }\n}\nfunction drawUpgradeImage(ctx, { upgrade, images, x, y, size = 32, }) {\n    const image = images.upgrades;\n    const { x: sourceX, y: sourceY } = SPRITE_MAP.get(upgrade.kind);\n    const sourceWidth = 32;\n    const sourceHeight = 32;\n    ctx.drawImage(image, sourceX, sourceY, sourceWidth, sourceHeight, x, y, size, size);\n    if (upgrade.active) {\n        ctx.drawImage(image, 0, 32, sourceWidth, sourceHeight, x, y, size, size);\n    }\n    if (upgrade.kind === 'lives') {\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = '#fff';\n        if (size === 24) {\n            ctx.font = `${10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS}px serif`;\n            ctx.strokeText(upgrade.count, x + 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, y + 16 * _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n        }\n        else {\n            ctx.font = `${12 * _config__WEBPACK_IMPORTED_MODULE_0__.RS}px serif`;\n            ctx.strokeText(upgrade.count, x + 13 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, y + 21 * _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n        }\n    }\n    if (upgrade.cooldown != null && upgrade.cooldownPassed != null) {\n        const niceTime = Math.floor(upgrade.cooldown - upgrade.cooldownPassed);\n        ctx.globalAlpha = 0.5;\n        ctx.fillStyle = 'grey';\n        ctx.fillRect(x + 1, y + 1, size - 2, size - 2);\n        ctx.globalAlpha = 1;\n        ctx.lineWidth = 1;\n        ctx.font = `${12 * _config__WEBPACK_IMPORTED_MODULE_0__.RS}px serif`;\n        ctx.strokeStyle = '#fff';\n        ctx.strokeText(niceTime, x + 10 * _config__WEBPACK_IMPORTED_MODULE_0__.RS, y + 16 * _config__WEBPACK_IMPORTED_MODULE_0__.RS);\n    }\n}\nfunction drawActiveUpgrades(ctx, { state, images, }) {\n    state.upgrades.forEach((upgrade, index) => {\n        drawActiveUpgradeItem(ctx, { upgrade, images, index });\n    });\n}\nfunction drawActiveUpgradeItem(ctx, { upgrade, images, index, }) {\n    const x = 350 * _config__WEBPACK_IMPORTED_MODULE_0__.RS - 28 * _config__WEBPACK_IMPORTED_MODULE_0__.RS * index;\n    const y = 5 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    const size = 24 * _config__WEBPACK_IMPORTED_MODULE_0__.RS;\n    drawUpgradeImage(ctx, { upgrade, images, x, y, size });\n}\n\n\n//# sourceURL=webpack:///./src/upgrade.ts?");

/***/ }),

/***/ "./src/zone.ts":
/*!*********************!*\
  !*** ./src/zone.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getActiveZone\": () => (/* binding */ getActiveZone),\n/* harmony export */   \"getNextZone\": () => (/* binding */ getNextZone)\n/* harmony export */ });\nconst defaultZone = {\n    start: 0,\n    kind: 'green',\n};\nfunction getActiveZone({ zones, moveOffset, }) {\n    for (let i = zones.length - 1; i >= 0; i--) {\n        const zone = zones[i];\n        if (moveOffset >= zone.start) {\n            return zone;\n        }\n    }\n    return defaultZone;\n}\nfunction getNextZone({ zones, moveOffset, }) {\n    var _a;\n    let activeIndex = -1;\n    for (let i = zones.length - 1; i >= 0; i--) {\n        const zone = zones[i];\n        if (moveOffset >= zone.start) {\n            activeIndex = i;\n            break;\n        }\n    }\n    if (activeIndex !== -1) {\n        const nextIndex = activeIndex + 1;\n        return (_a = zones[nextIndex]) !== null && _a !== void 0 ? _a : defaultZone;\n    }\n    return defaultZone;\n}\n\n\n//# sourceURL=webpack:///./src/zone.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;